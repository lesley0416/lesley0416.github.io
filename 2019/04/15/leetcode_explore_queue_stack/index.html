<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">







  <meta name="google-site-verification" content="pufZm21A3BmHUXXeFbh5D4nwCt7ZDl8GQkMO23QOsJc">







  <meta name="baidu-site-verification" content="kygZ90QCYp">











<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="参考自LeetCode上Explore模块的Queue &amp;amp; Stack，作为笔记记录。  Overview 综述主要了解两种不同的元素处理顺序：先入先出（FIFO）和后入先出（LIFO）；以及两个相应的线性数据结构：队列（Queue）和栈（Stack）。">
<meta name="keywords" content="LeetCode,深度优先搜索,队列,栈,Queue,Stack,广度优先搜索,BFS,DFS,FIFO,LIFO">
<meta property="og:type" content="article">
<meta property="og:title" content="【LeetCode】Explore：Queue &amp; Stack 队列 &amp; 栈">
<meta property="og:url" content="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/index.html">
<meta property="og:site_name" content="Lesley&#39;s blog">
<meta property="og:description" content="参考自LeetCode上Explore模块的Queue &amp;amp; Stack，作为笔记记录。  Overview 综述主要了解两种不同的元素处理顺序：先入先出（FIFO）和后入先出（LIFO）；以及两个相应的线性数据结构：队列（Queue）和栈（Stack）。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/fifo_queue.png">
<meta property="og:image" content="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/circular_queue.gif">
<meta property="og:image" content="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/bfs.gif">
<meta property="og:image" content="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/perfect_squeres.jpg">
<meta property="og:image" content="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/lifo_stack.png">
<meta property="og:image" content="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/dfs.gif">
<meta property="og:image" content="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/113_sample.png">
<meta property="og:updated_time" content="2019-05-02T08:37:33.102Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【LeetCode】Explore：Queue &amp; Stack 队列 &amp; 栈">
<meta name="twitter:description" content="参考自LeetCode上Explore模块的Queue &amp;amp; Stack，作为笔记记录。  Overview 综述主要了解两种不同的元素处理顺序：先入先出（FIFO）和后入先出（LIFO）；以及两个相应的线性数据结构：队列（Queue）和栈（Stack）。">
<meta name="twitter:image" content="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/fifo_queue.png">



  <link rel="alternate" href="/atom.xml" title="Lesley's blog" type="application/atom+xml">




  <link rel="canonical" href="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>【LeetCode】Explore：Queue & Stack 队列 & 栈 | Lesley's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/lesley0416" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lesley's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home //首页"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user //关于"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags //标签"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th //分类"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive //归档"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lesley Shi">
      <meta itemprop="description" content="fighting~~~">
      <meta itemprop="image" content="/image/touxiang.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lesley's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【LeetCode】Explore：Queue & Stack 队列 & 栈

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-15 09:58:50" itemprop="dateCreated datePublished" datetime="2019-04-15T09:58:50+08:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-02 16:37:33" itemprop="dateModified" datetime="2019-05-02T16:37:33+08:00">2019-05-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/基础/" itemprop="url" rel="index"><span itemprop="name">基础</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/04/15/leetcode_explore_queue_stack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/15/leetcode_explore_queue_stack/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/04/15/leetcode_explore_queue_stack/" class="leancloud_visitors" data-flag-title="【LeetCode】Explore：Queue & Stack 队列 & 栈">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>参考自LeetCode上Explore模块的<a href="https://leetcode.com/explore/learn/card/queue-stack/" target="_blank" rel="noopener">Queue &amp; Stack</a>，作为笔记记录。</p>
</blockquote>
<h1 id="Overview-综述"><a href="#Overview-综述" class="headerlink" title="Overview 综述"></a>Overview 综述</h1><p>主要了解两种不同的元素处理顺序：先入先出（FIFO）和后入先出（LIFO）；以及两个相应的线性数据结构：队列（Queue）和栈（Stack）。</p>
<a id="more"></a>
<p>主要内容：</p>
<ol>
<li>了解 FIFO 和 LIFO 处理顺序的原理；</li>
<li>实现这两个数据结构；</li>
<li>熟悉内置的队列和栈结构；</li>
<li>解决基本的队列相关问题，尤其是 <code>BFS</code>；</li>
<li>解决基本的栈相关问题；</li>
<li>理解当你使用 <code>DFS</code> 和其他<code>递归</code>算法来解决问题时，系统栈是如何帮助你的。</li>
</ol>
<h1 id="Queue-First-in-first-out-Data-Structure-队列：先入先出的数据结构"><a href="#Queue-First-in-first-out-Data-Structure-队列：先入先出的数据结构" class="headerlink" title="Queue: First-in-first-out Data Structure 队列：先入先出的数据结构"></a>Queue: First-in-first-out Data Structure 队列：先入先出的数据结构</h1><h2 id="先入先出的数据结构"><a href="#先入先出的数据结构" class="headerlink" title="先入先出的数据结构"></a>先入先出的数据结构</h2><p><img src="/2019/04/15/leetcode_explore_queue_stack/fifo_queue.png" style="zoom:50%"></p>
<p>FIFO数据结构：<font color="red">首先处理添加到队列中的第一个元素</font>。</p>
<p><font color="red">队列</font>是典型的FIFO数据结构，插入删除操作被称为入队出队，新元素始终添加在<code>队列末尾</code>，只能移除<code>第一个元素</code>。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>简单的使用动态数组和指向队列头部的索引来实现队列，会导致空间的浪费。</p>
<p>更有效的方法是使用循环队列，即使用<code>固定大小的数组</code>和<code>两个指针</code>来指示起始位置和结束位置，目的是<strong>重用被浪费的存储空间</strong>。</p>
<p>示例如图：</p>
<p><img src="/2019/04/15/leetcode_explore_queue_stack/circular_queue.gif"></p>
<h2 id="练习：设计循环队列"><a href="#练习：设计循环队列" class="headerlink" title="练习：设计循环队列"></a>练习：设计循环队列</h2><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li>
<li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li>
<li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li>
<li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li>
<li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li>
<li><code>isEmpty()</code>: 检查循环队列是否为空。</li>
<li><code>isFull()</code>: 检查循环队列是否已满。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为 3</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(1);  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(2);  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(3);  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(4);  // 返回 false，队列已满</span><br><span class="line"></span><br><span class="line">circularQueue.Rear();  // 返回 3</span><br><span class="line"></span><br><span class="line">circularQueue.isFull();  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.deQueue();  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(4);  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.Rear();  // 返回 4</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>所有的值都在 0 至 1000 的范围内；</li>
<li>操作数将在 1 至 1000 的范围内；</li>
<li>请不要使用内置的队列库。</li>
</ul>
<h2 id="解答：设计循环队列"><a href="#解答：设计循环队列" class="headerlink" title="解答：设计循环队列"></a>解答：设计循环队列</h2><p>使用一个数组和两个指针（<code>tail</code>和<code>head</code>）表示队列的结束和起始位置。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    MyCircularQueue(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        data.resize(k);</span><br><span class="line">        size = k;</span><br><span class="line">        head = <span class="number">-1</span>;</span><br><span class="line">        tail = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = (tail+<span class="number">1</span>) % size;</span><br><span class="line">        data[tail] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = <span class="number">-1</span>;</span><br><span class="line">            tail = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = (head+<span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[head];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[tail];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (tail+<span class="number">1</span>) % size == head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue* obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;enQueue(value);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;Rear();</span></span><br><span class="line"><span class="comment"> * bool param_5 = obj-&gt;isEmpty();</span></span><br><span class="line"><span class="comment"> * bool param_6 = obj-&gt;isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="队列：用法"><a href="#队列：用法" class="headerlink" title="队列：用法"></a>队列：用法</h2><p>大多数语言都提供内置的队列库，无需重复造轮子。</p>
<p>以C++内置队列库使用为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. Initialize a queue.</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 2. Push new element.</span></span><br><span class="line">    q.push(<span class="number">5</span>);</span><br><span class="line">    q.push(<span class="number">13</span>);</span><br><span class="line">    q.push(<span class="number">8</span>);</span><br><span class="line">    q.push(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 3. Check if queue is empty.</span></span><br><span class="line">    <span class="keyword">if</span> (q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Queue is empty!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. Pop an element.</span></span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="comment">// 5. Get the first element.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first element is: "</span> &lt;&lt; q.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 6. Get the last element.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The last element is: "</span> &lt;&lt; q.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 7. Get the size of the queue.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size is: "</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当想要按顺序处理元素时，使用队列可能是一个很好的选择。</strong></p>
<h2 id="练习：Moving-Average-from-Data-Stream"><a href="#练习：Moving-Average-from-Data-Stream" class="headerlink" title="练习：Moving Average from Data Stream"></a>练习：<a href="https://leetcode.com/problems/moving-average-from-data-stream" target="_blank" rel="noopener">Moving Average from Data Stream</a></h2><blockquote>
<p>【LeetCode】346</p>
</blockquote>
<p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MovingAverage m = new MovingAverage(3);</span><br><span class="line">m.next(1) = 1</span><br><span class="line">m.next(10) = (1 + 10) / 2</span><br><span class="line">m.next(3) = (1 + 10 + 3) / 3</span><br><span class="line">m.next(5) = (10 + 3 + 5) / 3</span><br></pre></td></tr></table></figure>
<p>计算滑动窗口中数字的平均数。</p>
<p>用队列模拟窗口，队列长度为窗口大小，超过时则将首元素移出队列，返回当前队列的平均数即可。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MovingAverage(<span class="keyword">int</span> size): size(size), sum(<span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.size() &gt;= size)</span><br><span class="line">        &#123;</span><br><span class="line">            sum -= que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += val;</span><br><span class="line">        que.push(val);</span><br><span class="line">        <span class="keyword">return</span> sum/que.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj.next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Queue-and-BFS-队列和广度优先搜索"><a href="#Queue-and-BFS-队列和广度优先搜索" class="headerlink" title="Queue and BFS 队列和广度优先搜索"></a>Queue and BFS 队列和广度优先搜索</h1><p>广度优先搜索（BFS）是一种<strong>遍历或搜索</strong>数据结构的算法。</p>
<p>可以用BFS执行树的层序遍历，可以遍历图并找到从起始节点到目标节点的路径（特别是最短路径）。</p>
<h2 id="队列和BFS"><a href="#队列和BFS" class="headerlink" title="队列和BFS"></a>队列和BFS</h2><p><strong>BFS的一个常见应用是找从根节点到目标节点的最短路径。</strong></p>
<p>下图展示用BFS找出节点A到目标节点G的最短路径。</p>
<p><img src="/2019/04/15/leetcode_explore_queue_stack/bfs.gif" style="zoom: 80%"></p>
<p>上述过程中：</p>
<p>节点处理顺序：越是接近根节点的节点将越早被遍历，所以第一次找到目标节点时，即为最短路径。</p>
<p>入队出队顺序：首先根节点入队，之后每轮处理已经在队列中的点，并将所有邻居入队，新加入的节点将在下轮处理，节点处理顺序与入队的顺序相同，即<strong>FIFO</strong>，所以BFS过程中可以使用队列处理问题。</p>
<h2 id="广度优先搜索——模板"><a href="#广度优先搜索——模板" class="headerlink" title="广度优先搜索——模板"></a>广度优先搜索——模板</h2><p>使用BFS的两个主要场景：<strong>遍历</strong>或<strong>找出最短路径</strong>。</p>
<blockquote>
<p>BFS也可以用于更抽象的场景中，在特定问题中执行BFS之前确定节点和边缘非常重要。通常，节点是实际节点或状态，而边缘是实际边缘或可能的转换。</p>
</blockquote>
<p>伪代码模板（Java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> * 返回root和target之间的最短路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed，存储所有待处理的节点</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node，根节点到正在访问的当前节点的距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="comment">// 每循环一层，距离根节点更远一步</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="comment">// 每轮中，队列中的节点是等待处理的节点</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                add next to queue;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要确保<strong>不会访问一个节点两次</strong>，可以在上述代码中加入一个set来记录访问过的节点，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; used;     <span class="comment">// store all the used nodes</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to used;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to used;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习：walls-and-gates"><a href="#练习：walls-and-gates" class="headerlink" title="练习：walls and gates"></a>练习：walls and gates</h2><blockquote>
<p>【LeetCode】286</p>
</blockquote>
<p>You are given a $m*n$ 2D grid initialized with these three possible values.</p>
<p>给定一个的用如下三个可能值初始化的$m*n$的2D网格。</p>
<ol>
<li><code>-1</code> - A wall or an obstacle. 墙壁或障碍物。</li>
<li><code>0</code> - A gate. 门。</li>
<li><code>INF</code> - Infinity means an empty room. We use the value $2^{31}-1=2147483647$ to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>. Infinity是一个空房间，使用值$2^{31}-1=2147483647$来表示<code>INF</code>，可以假设到门的距离小于<code>2147483647</code>。</li>
</ol>
<p>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with <code>INF</code>. 在每个代表空房间的网格中填充其距离最进门的距离，如果不可能到达门，则填充<code>INF</code>。</p>
<p>For example, given the 2D grid:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INF  -1  0  INF</span><br><span class="line">INF INF INF  -1</span><br><span class="line">INF  -1 INF  -1</span><br><span class="line">  0  -1 INF INF</span><br></pre></td></tr></table></figure>
<p>After running your function, the 2D grid should be:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3  -1   0   1</span><br><span class="line">2   2   1  -1</span><br><span class="line">1  -1   2  -1</span><br><span class="line">0  -1   3   4</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<blockquote>
<p>要注意节点的判断；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; room)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (room.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = room.size();</span><br><span class="line">        <span class="keyword">int</span> col = room[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历输入，将所有门的位置入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (room[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push([i, j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="comment">// 首元素出队，并获取其坐标</span></span><br><span class="line">            <span class="keyword">auto</span> head = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> ox = head.first;</span><br><span class="line">            <span class="keyword">int</span> oy = head.second;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历门的四个相邻点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = ox + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny = oy + dy[i];</span><br><span class="line">                <span class="comment">// 如果该位置在矩阵范围内，且该位置为INF，则进行填充及入队操作，这样，等queue中所有元素都遍历完了，则矩阵所有非墙的位置就都被正确更新了</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; room[nx][ny] == INF) &#123;</span><br><span class="line">                    q.push(&#123;nx, ny&#125;);</span><br><span class="line">                    room[nx][ny] = room[ox][oy] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习：岛屿的个数"><a href="#练习：岛屿的个数" class="headerlink" title="练习：岛屿的个数"></a>练习：岛屿的个数</h2><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>采用广度优先遍历的方法还是很容易解决这个问题的，我们尝试遍历所有的点，如果一个点是陆地且从未遍历过，则认为发现了新岛屿，在发现了新岛屿后使用广度优先的方式扩展该岛屿以防止重复计数．</p>
<p>代码如下（含完整测试代码）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = row &gt; <span class="number">0</span> ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录访问过的节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(row, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 遍历与当前节点相连的所有节点</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 查看周围上下左右的节点</span></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 遍历所有为1的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    <span class="comment">// 节点为1，且没有被访问过，即为发现新的小岛</span></span><br><span class="line">                    count++; <span class="comment">// 小岛数加1</span></span><br><span class="line">                    q.push(&#123;i, j&#125;); <span class="comment">// 节点入队</span></span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>; <span class="comment">// 修改节点访问标记</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 遍历与当前节点相连的其他节点</span></span><br><span class="line">                    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> head = q.front(); <span class="comment">// 获取首元素及其坐标</span></span><br><span class="line">                        q.pop();</span><br><span class="line">                        <span class="keyword">int</span> ox = head.first;</span><br><span class="line">                        <span class="keyword">int</span> oy = head.second;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 遍历上下左右的四个节点</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="keyword">int</span> nx = ox + dx[k];</span><br><span class="line">                            <span class="keyword">int</span> ny = oy + dy[k];</span><br><span class="line">                            <span class="comment">// 如果该节点在矩阵范围内，且值为1，则入队，并修改节点访问标记，这样等队列元素遍历结束后，则当前相连区域内的节点已遍历结束，可继续寻找下一个不相连的值为1的节点，即新的岛屿</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; grid[nx][ny] == <span class="string">'1'</span> &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">                                visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                                q.push(&#123;nx, ny&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = grid.size(), cols = rows &gt; <span class="number">0</span> ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rows == <span class="number">0</span> || cols == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Empty datas."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; grid[i][j];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="keyword">int</span> count = s.numIslands(grid);</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is "</span> &lt;&lt; count &lt;&lt; <span class="string">" island."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; count &lt;&lt; <span class="string">" islands."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; grid;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; tmp;</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    test(grid);</span><br><span class="line"></span><br><span class="line">    grid.clear();</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    test(grid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习：打开转盘锁"><a href="#练习：打开转盘锁" class="headerlink" title="练习：打开转盘锁"></a>练习：打开转盘锁</h2><blockquote>
<p>【LeetCode】752</p>
</blockquote>
<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code> 。每个拨轮可以自由旋转：例如把 <code>&#39;9&#39;</code> 变为  <code>&#39;0&#39;</code>，<code>&#39;0&#39;</code> 变为 <code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 <code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p>
<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">无法旋转到目标数字且不被锁定。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>死亡列表 <code>deadends</code> 的长度范围为 <code>[1, 500]</code>。</li>
<li>目标数字 <code>target</code> 不会在 <code>deadends</code> 之中。</li>
<li>每个 <code>deadends</code> 和 <code>target</code> 中的字符串的数字会在 10,000 个可能的情况 <code>&#39;0000&#39;</code> 到 <code>&#39;9999&#39;</code> 中产生。</li>
</ol>
<p><strong>解题思路</strong></p>
<p><strong>找最短路径问题，考虑用BFS，将问题建图。</strong></p>
<p>每个字符串对应一个状态，可以转换到相邻的8个状态（每位加1减1，共4位），从“0000”开始进行BFS，最后得到总步骤数。</p>
<p>类似用BFS遍历图，找最短路径，所以第一次到达目标节点时的路径一定是最短路径（之一）。</p>
<ul>
<li>注意向相邻节点转换时的操作，“0”-&gt;“9”，“9”-&gt;“0”，加1，减1；</li>
<li>用unordered_set存储访问标记和死亡节点，节省查找过程的时间消耗；</li>
<li>首先对deadends进行去重，看讨论区有说会有重复的情况；</li>
<li>BFS：从头结点”0000”开始，遍历所有子节点，初次访问且不在deadends中的则入队；已访问过或在deadends中的则跳过；遍历到下一层时，层数step加1，且更新size为下一层的节点数量；</li>
<li>每访问一个节点，先判断是否target，若是则返回当前的step；如果队列已空但仍未返回，则说明无路可通。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (find(deadends.begin(), deadends.end(), <span class="string">"0000"</span>) != deadends.end()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// deadends去重</span></span><br><span class="line">		sort(deadends.begin(), deadends.end());</span><br><span class="line">		deadends.erase(unique(deadends.begin(), deadends.end()), deadends.end());</span><br><span class="line">		<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; deadset(deadends.begin(), deadends.end());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存储当前节点及其可转换的其他节点，以及对应的步数</span></span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">		<span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 存储当前队列中可访问元素数量（每层的数量）</span></span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        </span><br><span class="line">		visited.insert(<span class="string">"0000"</span>);</span><br><span class="line">		q.push(<span class="string">"0000"</span>);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			size = q.size();</span><br><span class="line">            <span class="comment">// 层数加1</span></span><br><span class="line">			step++;</span><br><span class="line">            <span class="comment">// 遍历当前层所有节点</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				<span class="built_in">string</span> cur = q.front();</span><br><span class="line">				q.pop();</span><br><span class="line">                <span class="comment">// 逐个遍历可转换的节点（共8个，每位加1减1）</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cur.size(); j++) &#123;</span><br><span class="line">					<span class="built_in">string</span> temp = cur;</span><br><span class="line">					<span class="keyword">if</span> (temp[j] == <span class="string">'9'</span>)</span><br><span class="line">						temp[j] = <span class="string">'0'</span>;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						temp[j] += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 找到target，返回层数</span></span><br><span class="line">					<span class="keyword">if</span> (temp == target)</span><br><span class="line">						<span class="keyword">return</span> step;</span><br><span class="line">                    <span class="comment">// 没找到target，且不是死亡数字也没有访问过，则入队</span></span><br><span class="line">					<span class="keyword">if</span> (!deadset.count(temp) &amp;&amp; !visited.count(temp)) &#123;</span><br><span class="line">						q.push(temp);</span><br><span class="line">						visited.insert(temp);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					temp = cur;</span><br><span class="line">					<span class="keyword">if</span> (temp[j] == <span class="string">'0'</span>)</span><br><span class="line">						temp[j] = <span class="string">'9'</span>;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						temp[j] -= <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (temp == target)</span><br><span class="line">						<span class="keyword">return</span> step;</span><br><span class="line">					<span class="keyword">if</span> (!deadset.count(temp) &amp;&amp; !visited.count(temp)) &#123;</span><br><span class="line">						q.push(temp);</span><br><span class="line">						visited.insert(temp);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习：完全平方数"><a href="#练习：完全平方数" class="headerlink" title="练习：完全平方数"></a>练习：完全平方数</h2><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 = 4 + 9.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>参考<a href="https://blog.csdn.net/dst111188/article/details/69950493" target="_blank" rel="noopener">网上的思路</a>，转换为最短路径问题。</p>
<p>从$0$到$n$共有$n+1$个节点，如果从$i , i\in[0,n]$到$j , j\in[0,n]$相差一个完全平方数，就可以将两个节点连接起来，这样所有的点就转化成无向图，问题转化为求从$0$到$n$的最短路径。</p>
<p>如图所示：</p>
<p><img src="/2019/04/15/leetcode_explore_queue_stack/perfect_squeres.jpg" style="zoom: 80%"></p>
<p><strong>无权最短路径问题，可以采用BFS求解。</strong></p>
<p>也就是说，先遍历从$[1,i<em>i],i</em>i\leq n$，每一步将$n$缩为$n-i*i$，广度优先搜索，直至找到第一条将$n$缩为$0$的路径，即为最短路径。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将num不断用完全平方数代表，直至其成为0，其中1是完全平方数所以总会有解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i*i&lt;=num;i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> temp = num - i*i;</span><br><span class="line">     <span class="keyword">if</span>(visit[temp] == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//将其中没有访问过的点标记，以及将改点所到达的路径录入</span></span><br><span class="line">         queue.add(<span class="keyword">new</span> numpairs(temp,step+<span class="number">1</span>));</span><br><span class="line">         visit[temp] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span> || n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从大到小初始化路径序列，如16、9、4、1</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; square;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i*i&lt;=n; i++) &#123;</span><br><span class="line">            square.insert(square.begin(), i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉某个平方数后剩余的n，步骤数</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(make_pair(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> step = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it: square) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it == num)</span><br><span class="line">                    <span class="keyword">return</span> step+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (it &lt; num) &#123;</span><br><span class="line">                    q.push(make_pair(num-it, step+<span class="number">1</span>)); <span class="comment">// num-it&gt;0,入队</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// it&lt;num/2,重新从头遍历（从最大的开始）</span></span><br><span class="line">                <span class="keyword">if</span> (it &lt; num/<span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Stack-Last-in-first-out-Data-Structure-栈：后入先出的数据结构"><a href="#Stack-Last-in-first-out-Data-Structure-栈：后入先出的数据结构" class="headerlink" title="Stack: Last-in-first-out Data Structure 栈：后入先出的数据结构"></a>Stack: Last-in-first-out Data Structure 栈：后入先出的数据结构</h1><h2 id="后入先出的数据结构"><a href="#后入先出的数据结构" class="headerlink" title="后入先出的数据结构"></a>后入先出的数据结构</h2><p><img src="/2019/04/15/leetcode_explore_queue_stack/lifo_stack.png" style="zoom:50%"></p>
<p>LIFO数据结构：<font color="red">首先处理添加到队列中的最新元素</font>。</p>
<p><font color="red">栈</font>是典型的LIFO数据结构，插入删除操作称为入栈(push)出栈(pop)，新元素始终添加在<code>堆栈的末尾</code>，只能移除堆栈中的<code>最后一个元素</code>。</p>
<p><code>动态数组</code>可用来实现堆栈结构。</p>
<h2 id="栈：用法"><a href="#栈：用法" class="headerlink" title="栈：用法"></a>栈：用法</h2><p>大部分语言都有内置的栈库，无需重复造轮子。</p>
<p>以C++内置库的使用为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. Initialize a stack.</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 2. Push new element.</span></span><br><span class="line">    s.push(<span class="number">5</span>);</span><br><span class="line">    s.push(<span class="number">13</span>);</span><br><span class="line">    s.push(<span class="number">8</span>);</span><br><span class="line">    s.push(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 3. Check if stack is empty.</span></span><br><span class="line">    <span class="keyword">if</span> (s.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is empty!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. Pop an element.</span></span><br><span class="line">    s.pop();</span><br><span class="line">    <span class="comment">// 5. Get the top element.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The top element is: "</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 6. Get the size of the stack.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size is: "</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当想要首先处理最后一个元素时，栈将是最合适的数据结构。</strong></p>
<h2 id="练习：最小栈"><a href="#练习：最小栈" class="headerlink" title="练习：最小栈"></a>练习：最小栈</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) — 将元素 x 推入栈中。</li>
<li>pop() — 删除栈顶的元素。</li>
<li>top() — 获取栈顶元素。</li>
<li>getMin() — 检索栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>方法一，可以用两个栈，一个是题意要求的栈，另一个用来存储每次push后的当前最小值，push或pop时，同时修改两个栈的内容，存最小值的栈的top即为当前全栈最小值。</p>
<p>方法二，只用一个栈，再用一个额外的变量存储当前最小值。每次push时，如果要入栈的值比当前最小值小，则将当前最小值和要入栈的值同时入栈（注意先后顺序），每次pop时，要比较即将出栈的值和当前最小值是否相同，如果相同，则意味着当前最小值要更改为下一个栈顶元素（当前最小值和更新的最小值在栈内相邻）。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> minVal;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        minVal = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= minVal) <span class="comment">// 需要更新最小值，并将之前的最小值先入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            minStack.push(minVal);</span><br><span class="line">            minVal = x;</span><br><span class="line">        &#125;</span><br><span class="line">        minStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.top() == minVal) <span class="comment">// 需要更新最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">            minVal = minStack.top();</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="练习：有效的括号"><a href="#练习：有效的括号" class="headerlink" title="练习：有效的括号"></a>练习：有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>用栈结构，遍历字符串，如果是左括号就入栈，如果是右括号就看是否和栈顶元素是一对，如果是则出栈并继续，如果不是一对则返回false，如果遍历结束时栈为空则返回true，如果遍历结束时栈不为空则返回false（如”((“的情况）。</p>
<p>需要判断一些特殊情况，如s长度为0则直接返回true，如果s长度为奇数则直接返回false，同时top时要先确认栈非空。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.size() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>)</span><br><span class="line">                temp.push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span> &amp;&amp; !temp.empty() &amp;&amp; temp.top() == <span class="string">'('</span>)</span><br><span class="line">                temp.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span> &amp;&amp; !temp.empty() &amp;&amp; temp.top() == <span class="string">'['</span>)</span><br><span class="line">                temp.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#125;'</span> &amp;&amp; !temp.empty() &amp;&amp; temp.top() == <span class="string">'&#123;'</span>)</span><br><span class="line">                temp.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习：每日温度"><a href="#练习：每日温度" class="headerlink" title="练习：每日温度"></a>练习：每日温度</h2><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入 <code>0</code> 来代替。</p>
<p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p>
<p><strong>提示：</strong><code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的都是 <code>[30, 100]</code> 范围内的整数。</p>
<p><strong>解题思路</strong></p>
<p>维护一个递减栈，<strong>存储元素下标</strong>。</p>
<p>遍历温度列表，如果栈为空则直接入栈，如果栈非空，则比较栈顶元素与当前温度，如果当前元素小于等于栈顶元素则直接入栈，如果当前元素大于栈顶元素，则表明已经找到第一次升温的位置，则直接计算下标差并修改result，之后将栈顶元素出栈，并继续比较下一个栈顶元素与当前温度值，直至当前元素小于等于栈顶元素，将当前值入栈，继续上述流程直至遍历结束。</p>
<p>实际做的时候，result直接初始化全0，所以遍历结束直接返回result即可。否则需要将栈内剩余元素对应result中的位置全部置0（没有找到升温的点）。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(T.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (T.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; indexStack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;T.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!indexStack.empty() &amp;&amp; T[i] &gt; T[indexStack.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                result[indexStack.top()] = i-indexStack.top();</span><br><span class="line">                indexStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            indexStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// result初始化全为0，所以不用再看栈中剩余元素去更新result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习：逆波兰表达式求值"><a href="#练习：逆波兰表达式求值" class="headerlink" title="练习：逆波兰表达式求值"></a>练习：逆波兰表达式求值</h2><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p>
<p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>说明：</strong></p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>典型用栈解决问题，计算的中间结果需要入栈。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> stoi(tokens[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; tag&#123;<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item: tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag.find(item) == tag.end()) <span class="comment">// 是数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.push(stoi(item));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="keyword">int</span> a = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> b = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (item == <span class="string">"+"</span>)</span><br><span class="line">                    temp = a+b;</span><br><span class="line">                <span class="keyword">if</span> (item == <span class="string">"-"</span>)</span><br><span class="line">                    temp = b-a;</span><br><span class="line">                <span class="keyword">if</span> (item == <span class="string">"*"</span>)</span><br><span class="line">                    temp = a*b;</span><br><span class="line">                <span class="keyword">if</span> (item == <span class="string">"/"</span>)</span><br><span class="line">                    temp = b/a;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Stack-and-DFS-栈和深度优先搜索"><a href="#Stack-and-DFS-栈和深度优先搜索" class="headerlink" title="Stack and DFS 栈和深度优先搜索"></a>Stack and DFS 栈和深度优先搜索</h1><p>深度优先搜索（DFS）是用于在<code>树/图</code>中进行<code>遍历/搜索</code>的另一种算法。</p>
<p>在树的遍历中，可以用DFS进行<code>前序遍历、中序遍历和后序遍历</code>，这三种遍历的共同特点是<strong>除非到达最深的节点，否则不会回溯</strong>。</p>
<p>DFS和BFS的区别：BFS永远不会深入探索，除非已经遍历过当前层级的所有节点。</p>
<p>通常使用<code>递归</code>来实现DFS。</p>
<h2 id="栈和DFS"><a href="#栈和DFS" class="headerlink" title="栈和DFS"></a>栈和DFS</h2><p>DFS也可以用于查找从根节点到目标节点的路径。</p>
<p>（BFS是可以直接找到最短路径。）</p>
<p>如图所示：</p>
<p><img src="/2019/04/15/leetcode_explore_queue_stack/dfs.gif"></p>
<p>在上述例子中：</p>
<p>首先选择节点B的路径，到达E后无法深入，故回溯到A；再次选择节点C的路径，从C开始首先到达E，但E访问过，故回到C，并尝试F，最后找到了G。</p>
<p><strong>DFS中找到的第一条路径不一定是最短的路径。</strong></p>
<p>节点的处理和回溯过程是后进先出的处理顺序，和栈相同，故在DFS中多用栈来实现。</p>
<h2 id="DFS-模板1"><a href="#DFS-模板1" class="headerlink" title="DFS-模板1"></a>DFS-模板1</h2><p>大多可以使用BFS的情况也可以使用DFS，区别主要在遍历顺序。</p>
<p><strong>BFS找到的第一条路径为最短路径，而DFS不一定。</strong></p>
<p>有两种实现DFS的方法，第一种为递归。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">    <span class="keyword">for</span> (next : each neighbor of cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">true</span> <span class="keyword">if</span> <span class="title">DFS</span><span class="params">(next, target, visited)</span> </span>== <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用递归实现DFS时，使用的是系统提供的隐式栈，也称为call stack。</p>
<p>在每个堆栈元素中，都有一个当前值，一个目标值，一个访问过的数组的引用，和一个对数组边界的引用，这些就是DFS函数中的参数。栈的大小是DFS的深度，所以最坏情况下，维护系统占需要$O(h)$，其中$h$是DFS的最大深度。</p>
<p><strong>在计算空间复杂度时，要记得考虑系统栈。</strong></p>
</blockquote>
<h2 id="练习：岛屿的个数-1"><a href="#练习：岛屿的个数-1" class="headerlink" title="练习：岛屿的个数"></a>练习：岛屿的个数</h2><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>之前用BFS方法做过该题，主要是先遍历当前节点相邻的所有节点，之后继续查找下一个为’1’的点，重复上述过程。</p>
<p>此处用DFS方法递归遍历。</p>
<p>首先建立visited数组来记录某个位置是否访问过，对于为’1’且未曾访问过的位置，递归进入其上下左右位置上为’1’且未访问过的点，将其visited置为true，并继续进入其相连的相邻位置，直至周围没有为’1’的点，如此可将整个连通区域中所有的数都找到，将count数加一。之后再寻找下一个为’1’且未访问过的点，重复上述过程，直至遍历完整个grid数组。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid.size() == <span class="number">0</span> || grid[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录访问过的节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(grid.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(grid[<span class="number">0</span>].size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 遍历grid中所有节点，遇到为1且为访问过的点，则递归遍历其所有相邻点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    helper(grid, visited, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历x,y所有相邻的点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; grid.size() &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; grid[<span class="number">0</span>].size() &amp;&amp; grid[x][y] == <span class="string">'1'</span> &amp;&amp; !visited[x][y]) &#123;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            helper(grid, visited, x<span class="number">-1</span>, y);</span><br><span class="line">            helper(grid, visited, x+<span class="number">1</span>, y);</span><br><span class="line">            helper(grid, visited, x, y<span class="number">-1</span>);</span><br><span class="line">            helper(grid, visited, x, y+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习：克隆图"><a href="#练习：克隆图" class="headerlink" title="练习：克隆图"></a>练习：克隆图</h2><p>给定无向<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin" target="_blank" rel="noopener"><strong>连通</strong></a>图中一个节点的引用，返回该图的<a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。图中的每个节点都包含它的值 <code>val</code>（<code>Int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>
<p><strong>示例：</strong></p>
<p><img src="/2019/04/15/leetcode_explore_queue_stack/113_sample.png" style="zoom: 80%"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>节点数介于 1 到 100 之间。</li>
<li>无向图是一个<a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%9B%BE/1680528?fr=aladdin" target="_blank" rel="noopener">简单图</a>，这意味着图中没有重复的边，也没有自环。</li>
<li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li>
<li>必须将<strong>给定节点的拷贝</strong>作为对克隆图的引用返回。</li>
</ol>
<p><strong>解题思路</strong></p>
<p>基本是图的遍历问题，使用DFS方法解答，要注意深度拷贝每个节点后，还要将其neighbors放到一个vector中，要注意避免重复拷贝。题意明确所有节点值不同，所以可使用map来存储已经拷贝过的节点（原节点和新的克隆节点一一对应）。</p>
<p>在递归函数中，首先判断节点是否为空，再看当前节点是否已经克隆过，若在map中存在则已经克隆过，直接返回其映射节点。否则就克隆当前节点，并在map中建立映射，并遍历该节点的所有neighbor节点，递归调用并实时更新map即可。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于存储原节点和新的克隆节点的对应，避免重复拷贝</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        <span class="keyword">return</span> helper(node, m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">helper</span><span class="params">(Node* node, <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 当前节点已经克隆过，则返回其对应的克隆节点</span></span><br><span class="line">        <span class="keyword">if</span> (m.count(node))</span><br><span class="line">            <span class="keyword">return</span> m[node];</span><br><span class="line">        <span class="comment">// 当前节点没有克隆过：</span></span><br><span class="line">        <span class="comment">// 首先克隆当前节点，更新map</span></span><br><span class="line">        Node* clone = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        m[node] = clone;</span><br><span class="line">        <span class="comment">// 克隆当前节点的所有neighbor节点，并实时更新map</span></span><br><span class="line">        <span class="keyword">for</span> (Node* neighbor : node-&gt;neighbors) &#123;</span><br><span class="line">            clone-&gt;neighbors.push_back(helper(neighbor, m));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回克隆后的节点</span></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习：目标和"><a href="#练习：目标和" class="headerlink" title="练习：目标和"></a>练习：目标和</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 <code>+</code> 和 <code>-</code>。对于数组中的任意一个整数，你都可以从 <code>+</code> 或 <code>-</code>中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>数组的长度不会超过20，并且数组中的值全为正数。</li>
<li>初始的数组的和不会超过1000。</li>
<li>保证返回的最终结果为32位整数。</li>
</ol>
<p><strong>解题思路</strong></p>
<p>从第一个数字开始，调用递归函数，分别计算加当前值和减当前值之后的和，到数组结束时，比较当前和和目标值是否相等。（开始看网上的方法用目标和加/减当前值做递归的目标值来计算，结果在某个测试用例时提示超过int范围，，，）</p>
<p>参考测试用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1,1,1,1,1]</span><br><span class="line">3</span><br><span class="line">[2,107,109,113,127,131,137,3,2,3,5,7,11,13,17,19,23,29,47,53]</span><br><span class="line">2147483647</span><br><span class="line">[5,40,23,47,43,19,36,10,28,46,14,11,5,0,5,22,39,30,50,41]</span><br><span class="line">48</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S, <span class="keyword">int</span> index, <span class="keyword">int</span> curSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(index == size)</span><br><span class="line">            <span class="keyword">return</span> curSum==S ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        res += dfs(nums, S, index+<span class="number">1</span>, curSum+nums[index]);</span><br><span class="line">        res += dfs(nums, S, index+<span class="number">1</span>, curSum-nums[index]);</span><br><span class="line">        <span class="keyword">return</span> res;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>中文版LeetCode提交上述代码时提示在上面第三个测试用例下超时，，，</p>
<p>使用数组记录中间值以减少重复计算。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">// 记录中间值，map内容  当前可得到的中间结果，得到该结果的方法数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 初始dp的首值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 修改加减当前值之后可得到的中间结果及其方法数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : dp[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = a.first, cnt = a.second;</span><br><span class="line">                dp[i + <span class="number">1</span>][sum + nums[i]] += cnt;</span><br><span class="line">                dp[i + <span class="number">1</span>][sum - nums[i]] += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从最终的总方法数中，找到目标值对应的方法数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][S];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="DFS-模板2"><a href="#DFS-模板2" class="headerlink" title="DFS-模板2"></a>DFS-模板2</h2><p>递归虽然容易实现，但如果深度太高，容易栈溢出。这时可能希望使用BFS，或者用显式栈来实现DFS。</p>
<p>显式栈模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    Stack&lt;Node&gt; s;</span><br><span class="line">    add root to s;</span><br><span class="line">    <span class="keyword">while</span> (s is not empty) &#123;</span><br><span class="line">        Node cur = the top element in s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">        <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">                add next to s;</span><br><span class="line">                add next to visited;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        remove cur from s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法使用<code>while</code>和<code>栈</code>来模拟递归时的<code>系统调用栈</code>。</p>
<h2 id="练习：二叉树的中序遍历"><a href="#练习：二叉树的中序遍历" class="headerlink" title="练习：二叉树的中序遍历"></a>练习：二叉树的中序遍历</h2><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><strong>解题思路</strong></p>
<p>中序遍历：先遍历左子树，然后访问值，再遍历右子树。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !temp.empty()) &#123;</span><br><span class="line">            <span class="comment">// 递归直至最左，将所有左节点入栈</span></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                temp.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 栈顶节点是最左节点</span></span><br><span class="line">            <span class="comment">// 开始出栈，且输出栈顶节点</span></span><br><span class="line">            <span class="keyword">if</span> (!temp.empty()) &#123;</span><br><span class="line">                root = temp.top();</span><br><span class="line">                result.push_back(root-&gt;val);</span><br><span class="line">                temp.pop();</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li><p>队列</p>
<p><strong>队列</strong>是<strong>FIFO</strong>的数据结构，首先处理第一个元素；</p>
<p>队列两个重要操作：入队和出队；</p>
<p>可以用带有两个指针的动态数组来实现队列；</p>
<p><strong>BFS</strong>方法常使用队列结构；</p>
</li>
<li><p>栈</p>
<p><strong>栈</strong>是<strong>LIFO</strong>的数据结构，首先处理最后一个元素；</p>
<p>栈两个重要操作：push和pop；</p>
<p>使用动态数组可以实现栈；</p>
<p><strong>DFS</strong>是栈的一个重要应用。</p>
</li>
</ul>
<h2 id="练习：用栈实现队列"><a href="#练习：用栈实现队列" class="headerlink" title="练习：用栈实现队列"></a>练习：用栈实现队列</h2><p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) — 将一个元素放入队列的尾部。</li>
<li>pop() — 从队列首部移除元素。</li>
<li>peek() — 返回队列首部的元素。</li>
<li>empty() — 返回队列是否为空。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // 返回 1</span><br><span class="line">queue.pop();   // 返回 1</span><br><span class="line">queue.empty(); // 返回 false</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>你只能使用标准的栈操作 — 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>栈后进先出，队列先进先出。所以，在push的时候，借用一个额外的临时栈，首先将队列内原有元素挨个pop到临时栈（临时栈的顺序和构造的队列内顺序相反），再将新值push到临时栈，此时临时栈和要构造的队列元素顺序相反，新值在尾端。最后将临时栈再挨个pop到要构造的队列（实际也是用栈实现的）中，达到元素逆序的目的。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _stk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span>(!_stk.empty()) &#123;</span><br><span class="line">            temp.push(_stk.top());</span><br><span class="line">            _stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        temp.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!temp.empty()) &#123;</span><br><span class="line">            _stk.push(temp.top());</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = _stk.top();</span><br><span class="line">        _stk.pop();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="练习：用队列实现栈"><a href="#练习：用队列实现栈" class="headerlink" title="练习：用队列实现栈"></a>练习：用队列实现栈</h2><p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) — 元素 x 入栈</li>
<li>pop() — 移除栈顶元素</li>
<li>top() — 获取栈顶元素</li>
<li>empty() — 返回栈是否为空</li>
</ul>
<p><strong>注意:</strong></p>
<ul>
<li>你只能使用队列的基本操作— 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>和用栈实现队列的思路类似，push过程借用一个临时队列。需要注意的是，队列先入先出，所以此处要实现栈后入先出的目的，push的新值需要先插入临时队列，以保证pop时后插入的值可以先出去。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _que;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        temp.push(x); <span class="comment">// 新值先插入到临时队列中</span></span><br><span class="line">        <span class="keyword">while</span>(!_que.empty()) &#123;</span><br><span class="line">            temp.push(_que.front());</span><br><span class="line">            _que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!temp.empty()) &#123;</span><br><span class="line">            _que.push(temp.front());</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = _que.front();</span><br><span class="line">        _que.pop();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _que.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _que.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="练习：字符串解码"><a href="#练习：字符串解码" class="headerlink" title="练习：字符串解码"></a>练习：字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>解题思路</strong></p>
<p>用栈，类似括号匹配，发现右括号时，开始出栈直至发现左括号，获取括号中要重复的内容，再出栈一次获取重复次数，之后将该字段重复指定次数后再入栈，直至遍历结束。将栈内容出栈，并按照指定顺序拼接成结果字符串返回即可。</p>
<p>注意的是，重复次数可能不是一位数字，所以在入栈时，对于连续的数字要拼接到一起再入栈。</p>
<p>使用的几个测试用例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"3[a]2[bc]"</span></span><br><span class="line"><span class="string">"100[leetcode]"</span></span><br><span class="line"><span class="string">"3[a2[c]]"</span></span><br><span class="line"><span class="string">"2[abc]3[cd]ef"</span></span><br><span class="line"><span class="string">"2[abc]30[cd]ef"</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; s.size(); idx++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[idx] != <span class="string">']'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[idx])) &#123; <span class="comment">// 发现数字</span></span><br><span class="line">					<span class="keyword">int</span> begin = idx;</span><br><span class="line">					idx++;</span><br><span class="line">                    <span class="comment">// 找到下一个不为数字的位置</span></span><br><span class="line">					<span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[idx])) &#123;</span><br><span class="line">						idx++;</span><br><span class="line">					&#125;</span><br><span class="line">                    <span class="comment">// 插入多位数字</span></span><br><span class="line">					stk.push(s.substr(begin, idx - begin));</span><br><span class="line">				&#125;</span><br><span class="line">				stk.push(<span class="built_in">string</span>(<span class="number">1</span>, s[idx]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 获取要重复的内容</span></span><br><span class="line">				<span class="built_in">string</span> temp = <span class="string">""</span>;</span><br><span class="line">				<span class="keyword">while</span> (stk.top() != <span class="string">"["</span>) &#123;</span><br><span class="line">					temp = stk.top() + temp;</span><br><span class="line">					stk.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// "[" 出栈</span></span><br><span class="line">				stk.pop();</span><br><span class="line">                <span class="comment">// 获取重复次数</span></span><br><span class="line">				<span class="keyword">int</span> num = stoi(stk.top());</span><br><span class="line">				stk.pop();</span><br><span class="line">                <span class="comment">// 重复内容，并将结果再次入栈</span></span><br><span class="line">				<span class="built_in">string</span> cur = <span class="string">""</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">					cur += temp;</span><br><span class="line">				&#125;</span><br><span class="line">				stk.push(cur);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">			result = stk.top() + result;</span><br><span class="line">			stk.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习：图像渲染"><a href="#练习：图像渲染" class="headerlink" title="练习：图像渲染"></a>练习：图像渲染</h2><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p>
<p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p>
<p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p>
<p>最后返回经过上色渲染后的图像。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">image = [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr = 1, sc = 1, newColor = 2</span><br><span class="line">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)=(1,1)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class="line">注意，右下角的像素没有更改为2，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li>
<li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li>
<li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li>
</ul>
<p><strong>解题思路</strong></p>
<p>和前面<code>岛屿的个数</code>类似，主要找到与初始点颜色相同且相连的节点，将其着色返回即可。</p>
<p>采用BFS或DFS递归均可，此处使用BFS，首先初始点标记访问、修改颜色、入队，后遍历其相邻节点，将颜色相同的相邻点标记访问、修改颜色、入队。直至队列为空，说明与初始点相连接的所有点均遍历结束，则返回。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="comment">// int row = image.size();</span></span><br><span class="line">        <span class="comment">// int col = row &gt; 0 ? image[0].size() : 0;</span></span><br><span class="line">        <span class="comment">// if (row == 0 || col == 0)</span></span><br><span class="line">        <span class="comment">//     return image;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 题设row col长度范围在[1,50]，所以省掉额外判断</span></span><br><span class="line">        <span class="keyword">int</span> row = image.size();</span><br><span class="line">        <span class="keyword">int</span> col = image[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录访问过的节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(row, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 记录相邻且相连的节点</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 查看上下左右的节点用</span></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 记录初始点颜色</span></span><br><span class="line">        <span class="keyword">int</span> tag = image[sr][sc];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始点入队，标记访问，修改初始点颜色</span></span><br><span class="line">        q.push(&#123;sr, sc&#125;);</span><br><span class="line">        visited[sr][sc] = <span class="literal">true</span>;</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历相邻且颜色相同的点</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> head = q.front(); <span class="comment">// 获取首元素及坐标</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> ox = head.first;</span><br><span class="line">            <span class="keyword">int</span> oy = head.second;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历上下左右的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = ox + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny = oy + dy[i];</span><br><span class="line">                <span class="comment">// 如果该节点在矩阵范围内，且颜色和初始点相同，则修改其颜色为newcolor，并标记访问，入队</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; image[nx][ny] == tag &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">                    image[nx][ny] = newColor;</span><br><span class="line">                    visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习：01矩阵"><a href="#练习：01矩阵" class="headerlink" title="练习：01矩阵"></a>练习：01矩阵</h2><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<p><strong>示例 1:</strong><br>输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong><br>输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>给定矩阵的元素个数不超过 10000。</li>
<li>给定矩阵中至少有一个元素是 0。</li>
<li>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</li>
</ol>
<p><strong>解题思路</strong></p>
<p>找到最近的0的距离，是最短路径问题，用BFS。</p>
<p>类比前面 walls and gates ，首先将原矩阵中所有值为0的点入队，值为1的点设为无限大INT_MAX（为了后续比较最小距离）。</p>
<p>遍历queue中节点的相邻节点，若该相邻节点的值大于当前节点值加1，则将其修改为当前值加1，且将该相邻节点入队，否则跳过（当相邻节点距离更小的时候，不需要更新），直至队列为空结束。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">		<span class="keyword">int</span> row = matrix.size();</span><br><span class="line">		<span class="keyword">int</span> col = row &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> matrix;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历当前节点相邻的节点</span></span><br><span class="line">		<span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">		<span class="comment">// 上下左右节点</span></span><br><span class="line">		<span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">		<span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改原矩阵，值为0的入队，值为1的将距离设为无限大INT_MAX</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">					q.push(&#123; i,j &#125;);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					matrix[i][j] = INT_MAX;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历队列内值，即所有为0的点，从相邻节点中找非零点，如果值比当前点值加一大，则修改为当前值加一，且该相邻节点入队</span></span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">auto</span> head = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="comment">// 遍历周围节点</span></span><br><span class="line">			<span class="keyword">int</span> ox = head.first;</span><br><span class="line">			<span class="keyword">int</span> oy = head.second;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">				<span class="keyword">int</span> nx = ox + dx[k];</span><br><span class="line">				<span class="keyword">int</span> ny = oy + dy[k];</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny&lt;col &amp;&amp; matrix[nx][ny]&gt;matrix[ox][oy] + <span class="number">1</span>) &#123;</span><br><span class="line">					matrix[nx][ny] = matrix[ox][oy] + <span class="number">1</span>;</span><br><span class="line">					q.push(&#123; nx, ny &#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> matrix;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习：钥匙和房间"><a href="#练习：钥匙和房间" class="headerlink" title="练习：钥匙和房间"></a>练习：钥匙和房间</h2><p>有 <code>N</code> 个房间，开始时你位于 <code>0</code> 号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p>
<p>在形式上，对于每个房间 <code>i</code> 都有一个钥匙列表 <code>rooms[i]</code>，每个钥匙 <code>rooms[i][j]</code> 由 <code>[0,1，...，N-1]</code> 中的一个整数表示，其中 <code>N = rooms.length</code>。 钥匙 <code>rooms[i][j] = v</code> 可以打开编号为 <code>v</code> 的房间。</p>
<p>最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。</p>
<p>你可以自由地在房间之间来回走动。</p>
<p>如果能进入每个房间返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1],[2],[3],[]]</span><br><span class="line">输出: true</span><br><span class="line">解释:  </span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,3],[3,0,1],[2],[0]]</span><br><span class="line">输出：false</span><br><span class="line">解释：我们不能进入 2 号房间。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= rooms.length &lt;= 1000</code></li>
<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>
<li>所有房间中的钥匙数量总计不超过 <code>3000</code>。</li>
</ol>
<p><strong>解题思路</strong></p>
<p>用栈实现，并且维护一个长度N的数组标记房间是否能够打开。</p>
<p>首先将0号房间的钥匙全部入栈，之后挨个出栈，并且判断当前的钥匙对应的房间是否已经打开，如果已经打开就跳过，如果是第一次打开，就将该房间的钥匙入栈，并标记该房间。</p>
<p>到栈为空时，如果标记房间的数组值全为true，则返回true，否则返回false。</p>
<p>同样的思路，用队列也可以，队列是BFS，栈的话就是DFS。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(rooms.size(), <span class="number">0</span>);</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; keys;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 0号房间的钥匙入栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> key : rooms[<span class="number">0</span>]) &#123;</span><br><span class="line">            keys.push(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历栈中所有钥匙，标记可打开的房间</span></span><br><span class="line">        <span class="keyword">while</span> (!keys.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = keys.top();</span><br><span class="line">            keys.pop();</span><br><span class="line">            <span class="keyword">if</span> (visited[key] == <span class="number">0</span>) &#123; <span class="comment">// 该房间之前没有打开过</span></span><br><span class="line">                visited[key] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> temp : rooms[key]) &#123;</span><br><span class="line">                    keys.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有钥匙遍历结束，看visited中是否有没有打开的房间</span></span><br><span class="line">        <span class="keyword">return</span> find(visited.begin(), visited.end(), <span class="number">0</span>) == visited.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    


<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

  
</div>

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i> LeetCode</a>
          
            <a href="/tags/深度优先搜索/" rel="tag"><i class="fa fa-tag"></i> 深度优先搜索</a>
          
            <a href="/tags/队列/" rel="tag"><i class="fa fa-tag"></i> 队列</a>
          
            <a href="/tags/栈/" rel="tag"><i class="fa fa-tag"></i> 栈</a>
          
            <a href="/tags/Queue/" rel="tag"><i class="fa fa-tag"></i> Queue</a>
          
            <a href="/tags/Stack/" rel="tag"><i class="fa fa-tag"></i> Stack</a>
          
            <a href="/tags/广度优先搜索/" rel="tag"><i class="fa fa-tag"></i> 广度优先搜索</a>
          
            <a href="/tags/BFS/" rel="tag"><i class="fa fa-tag"></i> BFS</a>
          
            <a href="/tags/DFS/" rel="tag"><i class="fa fa-tag"></i> DFS</a>
          
            <a href="/tags/FIFO/" rel="tag"><i class="fa fa-tag"></i> FIFO</a>
          
            <a href="/tags/LIFO/" rel="tag"><i class="fa fa-tag"></i> LIFO</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/02/leetcode_explore_binary_tree/" rel="next" title="【LeetCode】Explore：Binary Tree 二叉树">
                <i class="fa fa-chevron-left"></i> 【LeetCode】Explore：Binary Tree 二叉树
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/image/touxiang.JPG" alt="Lesley Shi">
            
              <p class="site-author-name" itemprop="name">Lesley Shi</p>
              <p class="site-description motion-element" itemprop="description">fighting~~~</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">48</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:shilixin16@163.com" title="E-Mail &rarr; mailto:shilixin16@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Overview-综述"><span class="nav-number">1.</span> <span class="nav-text">Overview 综述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Queue-First-in-first-out-Data-Structure-队列：先入先出的数据结构"><span class="nav-number">2.</span> <span class="nav-text">Queue: First-in-first-out Data Structure 队列：先入先出的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#先入先出的数据结构"><span class="nav-number">2.1.</span> <span class="nav-text">先入先出的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环队列"><span class="nav-number">2.2.</span> <span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：设计循环队列"><span class="nav-number">2.3.</span> <span class="nav-text">练习：设计循环队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解答：设计循环队列"><span class="nav-number">2.4.</span> <span class="nav-text">解答：设计循环队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列：用法"><span class="nav-number">2.5.</span> <span class="nav-text">队列：用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：Moving-Average-from-Data-Stream"><span class="nav-number">2.6.</span> <span class="nav-text">练习：Moving Average from Data Stream</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Queue-and-BFS-队列和广度优先搜索"><span class="nav-number">3.</span> <span class="nav-text">Queue and BFS 队列和广度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#队列和BFS"><span class="nav-number">3.1.</span> <span class="nav-text">队列和BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广度优先搜索——模板"><span class="nav-number">3.2.</span> <span class="nav-text">广度优先搜索——模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：walls-and-gates"><span class="nav-number">3.3.</span> <span class="nav-text">练习：walls and gates</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：岛屿的个数"><span class="nav-number">3.4.</span> <span class="nav-text">练习：岛屿的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：打开转盘锁"><span class="nav-number">3.5.</span> <span class="nav-text">练习：打开转盘锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：完全平方数"><span class="nav-number">3.6.</span> <span class="nav-text">练习：完全平方数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stack-Last-in-first-out-Data-Structure-栈：后入先出的数据结构"><span class="nav-number">4.</span> <span class="nav-text">Stack: Last-in-first-out Data Structure 栈：后入先出的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#后入先出的数据结构"><span class="nav-number">4.1.</span> <span class="nav-text">后入先出的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈：用法"><span class="nav-number">4.2.</span> <span class="nav-text">栈：用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：最小栈"><span class="nav-number">4.3.</span> <span class="nav-text">练习：最小栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：有效的括号"><span class="nav-number">4.4.</span> <span class="nav-text">练习：有效的括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：每日温度"><span class="nav-number">4.5.</span> <span class="nav-text">练习：每日温度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：逆波兰表达式求值"><span class="nav-number">4.6.</span> <span class="nav-text">练习：逆波兰表达式求值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stack-and-DFS-栈和深度优先搜索"><span class="nav-number">5.</span> <span class="nav-text">Stack and DFS 栈和深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈和DFS"><span class="nav-number">5.1.</span> <span class="nav-text">栈和DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS-模板1"><span class="nav-number">5.2.</span> <span class="nav-text">DFS-模板1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：岛屿的个数-1"><span class="nav-number">5.3.</span> <span class="nav-text">练习：岛屿的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：克隆图"><span class="nav-number">5.4.</span> <span class="nav-text">练习：克隆图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：目标和"><span class="nav-number">5.5.</span> <span class="nav-text">练习：目标和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS-模板2"><span class="nav-number">5.6.</span> <span class="nav-text">DFS-模板2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：二叉树的中序遍历"><span class="nav-number">5.7.</span> <span class="nav-text">练习：二叉树的中序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：用栈实现队列"><span class="nav-number">6.1.</span> <span class="nav-text">练习：用栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：用队列实现栈"><span class="nav-number">6.2.</span> <span class="nav-text">练习：用队列实现栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：字符串解码"><span class="nav-number">6.3.</span> <span class="nav-text">练习：字符串解码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：图像渲染"><span class="nav-number">6.4.</span> <span class="nav-text">练习：图像渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：01矩阵"><span class="nav-number">6.5.</span> <span class="nav-text">练习：01矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习：钥匙和房间"><span class="nav-number">6.6.</span> <span class="nav-text">练习：钥匙和房间</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lesley Shi</span>

  

  
</div>

<!-- 隐藏底部 由hexo强力驱动，主题next

  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.0</div>



-->

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共57.9k字</span>
</div>

        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.0"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>




<script src="//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'rj24gpfj5X7r5bXpsBTb1Hm5-gzGzoHsz',
    appKey: 'tkke5f1SGYEVh8claojD4gVU',
    placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
    avatar: 'monsterid',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow-x: scroll;
  overflow-y: hidden;
}
</style>

    
  


  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>
  <script>
    
    
  </script>


  

  

  

  

  

  

</body>
</html>
