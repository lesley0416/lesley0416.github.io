<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[拼音输入法实现&文本服务框架TSF相关知识点记录]]></title>
    <url>%2F2019%2F05%2F29%2FTSF%2F</url>
    <content type="text"><![CDATA[最近一直在做一个拼音输入法的项目，需要使用微软的文本服务框架（Text Service Framework，简称TSF），第一次使用TSF，记录其中的一些知识点。 TSF技术TSF工作原理TSF是一个与输入设备无关、与输入语言无关的可扩展系统，可以向文本输入和语言处理提供相关服务。TSF以一组COM接口的方式向应用程序和文本服务公开其框架。 TSF基本体系结构如下图（图源网络）所示： 一般应用程序会包括显示、直接编辑、文本存储几个主要功能，通过实现一个COM服务来提供文本访问能力。 文本服务的功能是向应用程序提供文本，文本服务也是以COM来实现的，系统中允许同时注册多个文本服务。（像通常见到的拼音输入、语音输入、手写输入，就是几种不同的文本服务） TSF管理器的功能由操作系统实现，不能被任何形式的应用程序代替。允许一个应用程序和一个或多个文本服务共享文本内容。 TSF主要概念 概念主要参考网上的一些资料，感觉有些不是很确切的明白，，， 文本存储 文本存储是由应用程序提供来源，通过TSF管理器实现的一种在应用程序和文本服务之间共享文本流的机制，将文档看作是包含Unicode字符和控制代码的文本流，使用字符的应用程序字符位置（ACP）来定位和操作文本流。 片段 应该就是指ITfRange，所有文本都存储在被称为片段的对象中，片段是描述文本流中的某一小段文本的对象，不与文本流上的字符位置相关联，与特定的文本段相关联。所以这段文本在文本流中位置变化时也不用重新定义片段，也就是说，片段是可游移的。 range由两个锚点来界定，一个start anchors，一个end anchors。 属性 ITfProperty，属性用来关联文本片段和元数据。 获取特定属性时，使用ITfContext::GetProperty方法，调用该方法时，必须指定一个特定的属性类型。 公共缓冲池 客户端程序之间通过公共缓冲池来实现数据共享，为数据共享提供一个数据存储和消息处理的机制。缓冲池通过GUID标识，客户端通过发布GUID来实现公共缓冲池的共享，只有注册为TSF客户端的程序才能修改公共缓冲池的数据。 文档锁 文档锁的作用是允许TSF管理器对文本内容进行互斥访问。 TSF主要接口 线程管理器（ITfThreadMgr） 完成有关应用程序和文本服务（客户端）之间进行联系的公共任务，包括激活或挂起TSF文本服务、文档管理器的创建、维护文档和输入焦点之间的正确关联等各种任务。 客户端标识符（ITfClientId） 应用程序和文本服务被定义为客户端，需要维护一个客户端标识符。 编辑内容（ITfContext） 基本的文本输入模型，可以理解为一个通过ITfContext接口创建的连续的文本流。 文档管理器（ITfDocumentMgr） 通过ITfDocumentMgr接口创建并用来管理编辑内容的。 输入组合（ITfComposition） 输入组合是一个临时输入状态，应用程序需要获取ITfComposition的显示属性信息，通过判断输入组合是否存在，来将其状态显示给用户。 编辑会话（ITfEditSession） 编辑会话由文本服务实现，并由TSF管理器调用来读取或修改文本和属性的上下文。 其他一些点 获取某个文本片段所有者的CLSID（类标识符）时，应该先用ITfContext::GetProperty方法获取属性对象，然后用ITfProperty::FindRange方法得到覆盖该属性的文本片段，最后用ITfReadOnlyProperty::GetValue方法得到一个TfGuidAtom类型数据，表示拥有这个片段的文本服务的CLSID。 通过ITfContext::EnumProperties方法返回的IEnumTfProperties接口，可以列举出所有的属性对象。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>TSF</tag>
        <tag>文本服务框架</tag>
        <tag>输入法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Understanding LSTM Networks]]></title>
    <url>%2F2019%2F05%2F21%2FUnderstandingLSTM%2F</url>
    <content type="text"><![CDATA[翻译自 Understanding LSTM Networks 部分内容有点直译，领会精神，，， 循环神经网络人类不会每秒都从头开始新的想法。正如阅读这篇文章时，我们会基于对上文的理解，去理解当前的文字。我们不会抛开所有去重新开始理解。也就是说，我们的思考是具有连续性的。 传统的神经网络的一个主要缺点就是做不到“具有持续性”这一点。例如，假设我们想要对电影中某个时间点所发生的事件进行分类，目前，我们尚不清楚如何使用传统的神经网络，来完成“利用该时间点的前续内容进行推导并得到后续时间点发生的事情”这一过程。 循环神经网络（RNN，Recurrent Neural Networks）解决了这个问题。RNN是带有循环的网络，允许信息的持久化。 图示为带有循环的RNN。 在上图中，神经网络的一个chunk, $A$，接受输入$x_t$，并输出$h_t$。循环允许信息从网络中的一个步骤传递到下一个步骤。 这些循环使得RNN看起来有点神秘。但事实上，RNN并不是完全不同于普通的神经网络。RNN可以认为是同一个网络的多个副本，每一个副本都将信息传递给下一个。想象，如果将RNN的循环展开，如下图： 图示为展开的RNN。 这种链式结构表明，RNN和序列及列表密切相关，是用于序列及列表结构数据的神经网络的一种自然结构。 在过去几年里，RNN在很多问题上都有令人难以置信的成功应用，如语音识别、语言模型、机器翻译、图像字幕等等。关于RNN效果的讨论可以参考Andrej Karpathy的文章，The Unreasonable Effectiveness of Recurrent Neural Networks 。 RNN取得上述成功的关键在于LSTM的使用，LSTM是RNN中的一个特殊结构，在很多任务上，都优于普通的RNN。RNN上几乎所有难以置信的效果有是基于LSTM实现的。本文将对LSTM进行探讨。 长期依赖问题RNN的诉求之一就是能够将先前的信息连接到当前任务，如通过先前的视频片段可以理解当前的视频片段。如果RNN可以做到这一点，那网络将会非常有效。RNN是否可以呢？视情况而定。 有时，我们只需要通过最近的信息就可以完成当前的任务。例如，对于一个通过前一个词来预测下一个词的语言模型。如果我们希望预测the clouds are in the sky这句话的最后一个单词sky，我们不需要更多的上下文，很明显最后一个单词就应该是sky。在这种情况下，相关信息之间的距离很小，RNN可以学到过去的信息并加以使用。 但是也有一些需要更多上下文的情况。假设我们希望预测片段I grew up in France… I speak fluent French.的最后一个单词。通过距离最近的信息我们可以推测最后一个词可能是一种语言的名称，但如果我们想确定到底是哪一种语言，就需要距离更远的关于France的上文信息。可见，相关信息之间的距离以及所需的信息点跨度是完全有可能非常大的。 不幸的是，随着跨度的增大，RNN对于先前信息的感知能力会下降。 理论上，RNN绝对可以处理这种长期依赖问题。我们可以通过仔细的调整相应参数来解决这种形式的小问题。但很不幸，在实践中，RNN似乎不能很好的处理这类情况。关于这个问题，Hochreiter(1991)[German] 和 Bengio, et al. (1994) 已经进行了深入的探讨，并发现了RNN之所以难以解决该类问题的一些很根本的原因。 好在，LSTM并没有上述问题。 LSTM网络长短时记忆网络（Long Short Term Memory networks，LSTM）是RNN的一种特例，能够解决长期依赖的问题。LSTM由 Hochreiter &amp; Schmidhuber (1997) 提出，并在之后的工作中被大家扩展及推广。LSTM在很多问题上表现都非常好，因此被广泛使用。 LSTM是明确为了避免长期依赖的问题而设计的。对信息的长时间记录是LSTM的默认行为，而不需要进行努力的学习来获取。 所有的RNN都有链式的形式来重复神经网络的某个模块。在标准的RNN中，这个重复的模块可能结构非常简单，例如只是一个$tanh​$层。 图示：标准RNN中的重复模块包含一个单一的tanh层 LSTM也有这种链式结构，但是其中重复模块的结构相对复杂。不再是一个单一的神经网络层，而是四个，以一种非常特殊的形式进行交互。 图示：LSTM的重复模块包含四个交互层 不用担心细节是如何进行的。我们后面会一步一步了解LSTM。现在，先熟悉接下来即将使用到的一些符号。 在上图中，从一个节点的输出到另一个节点的输入，每一行都有一个完整的向量。粉色圆圈表示点态操作（点态指向量计算后得到的向量），如向量加法，黄色方框表示神经网络层。箭头合并表示向量合并，箭头分叉表示向量复制到不同位置。 LSTMs背后的核心思想LSTMs的关键在于cell state（细胞状态？），即下图横穿顶部的水平线。 Cell state像传送带一样，横穿整个链路，但只有很少的线性交互。所以信息可以很容易的传递并且不被改变。 LSTM可以从cell state上添加或删除信息，这种功能是由一种叫gates的结构仔细调控的。 Gates是一种选择性让信息通过的方法，由一个sigmoid神经网络层和一个点态乘法操作组成。 sigmoid层输出值在0~1之间，描述了每个组件可以通过多少。0表示全部不许通过，1表示全部可以通过。 一个LSTM有三个这样的gates，来保护和控制cell state。 LSTM的详细原理LSTM的第一步是决定要哪些信息可以继续通过cell state（就是决定丢掉哪些信息）。这个决定是由一个叫做遗忘门，forget gate layer的sigmoid层决定的。遗忘门的输入是$h_{t-1}$和$x_t $，输出一个0~1之间的值（输出内容是一个和$C_{t-1}$同维度的0/1向量），表示在cell state $C_{t-1}$ 中每部分内容通过的比重。1表示全部保留，0表示全部放弃。 回到上文我们提到的基于所有前文来预测接下来内容的语言模型的例子。在这个问题中，cell state 可以包含当前主语的性别信息（保留信息），所以可以使用正确的代词。当我们开始一个新的主语时，我们会想要忘掉前一个主语的性别信息（遗忘信息）。 接下来的一步是决定要在cell state中新增哪些信息。主要包括两部分。首先，由一个叫做input gate layer的sigmoid层决定要更新哪些维度的信息。还有一个tanh层生成一个新的可以被新增到state中的候选向量$\tilde{C}_t​$。之后，我们将这两层进行合并，从而对state进行更新。 在我们的语言模型的例子中，我们将新主语的性别信息加入到cell state中，替代遗忘掉的旧的性别信息。 现在，我们将旧的cell state，更新到新的 cell state，即把$C_{t-1}$ 更新为$C_t$。上述步骤已经描述了具体要做的内容，只需要实际实现即可。 我们将旧的state乘以 $f_t$ ，来遗忘掉决定忘掉的内容。然后再加上 $i_t\times \tilde{C}_t$ ，这是新的候选向量，取决于我们决定对state值更新多少。 在语言模型的例子中，就是我们要丢掉旧主语的性别信息，并且按照上述步骤所描述的，添加新的性别信息。 最后，我们需要决定将要输出什么。输出取决于cell state，但是是一个过滤后的版本。首先，我们通过一个sigmoid层（output gate）决定要输出cell state的哪些部分，以及对应的比例。然后，将cell state通过一个tanh层（将值映射到-1~1之间）后，和sigmoid层的输出相乘，从而得到我们想要的输出。 对于语言模型的例子中，当刚刚看到一个主语的时候，接下来想要输出一个动词的时候，这个动词就和主语的信息相关了。例如，根据主语是单数还是复数形式，来决定动词应该采用什么格式来加入到后续内容中。 LSTM的变种到目前为止所描述的都是普通的LSTM。但是，不是所有的LSTMs都和上文描述的一样。实际上，每篇涉及到LSTMs的论文，都会有一些轻微的改动。通常改动都很小，但也有必要了解一些。 一个流行的LSTM变种，是由Gers &amp; Schmidhuber (2000) 提出的，加入了一个peephole connections。意味着，每一个gate层，都可以用cell state做输入。 上图对所有的gates都增加了peepholes，但是在很多论文中，是对有些门加peepholes，有些门不加。 另一个变种是将遗忘门和输入门组合使用。不同于单独决定要遗忘和要新增的信息，而是将两个信息放在一起决定。只有当某个维度有新信息加入时，才需要遗忘掉旧的信息。只有当遗忘掉旧的信息时，才新增新的信息。 LSTM另一个更厉害的变种是门控循环单元GRU（Gated Recurrent Unit），由Cho, et al. (2014) 提出。GRU将遗忘门和输入门组合成一个单独的更新门update gate。同时，将cell state和隐藏状态hidden state进行合并，并做了一些其他修改。最终得到的模型要比标准的LSTM模型更简单，并且广受欢迎。 在GRU中，只有两个门：重置门“reset gate”和更新门“update gate”。 上图中，$r_t$ 表示重置门，$z_t$ 表示更新门。重置门决定是否将之前的state遗忘。当 $r_t$ 趋于0的时候，前一个时刻的state信息 $h_{t-1}$ 会被遗忘，隐藏状态 $\tilde{h}_t$ 会被重置为当前的输入信息。更新门决定是否要将隐藏状态更新为新的状态 $\tilde{h}_t$ ，作用相当于合并了LSTM中的遗忘门和输入门。 GRU和LSTM简单比较一下： GRU少一个门，同时也少了cell state $C_t$ ； 在LSTM中，通过遗忘门和输入门控制信息的遗忘和输入；GRU则通过重置门来控制是否要保留原来hidden state的信息，但是不再限制当前信息的输入； 在LSTM中，虽然得到了新的cell state $C_t$ ，但是不能直接输出，而是要经过一个过滤处理；同样，在GRU中，虽然也得到了新的hidden state $\tilde{h}_t$ ，但是不能直接输出，而是通过更新门来控制最后的输出。 这些只是LSTM的几个有名的变种。还有很多其他变种，如Depth Gated RNNs by Yao, et al. (2015) 。也有一些完全不同的处理长期依赖问题的方法，如Clockwork RNNs by Koutnik, et al. (2014) 。 哪种变种更好呢？这些不同有什么影响呢？Greff, et al. (2015) 对这些流行的变种进行了非常好的对比，发现他们都是一致的。Jozefowicz, et al. (2015) 在测试了一万多种RNN结构后，发现其中一些在特定任务上效果要好于LSTMs（该论文值得推荐）。 结论在上文提到的一些使用RNN达到的非常显著的成果。本质上都是通过LSTMs实现的。在很多任务上，LSTM确实表现非常好。 LSTM的一系列公式看起来很吓人，希望通过本文的逐步解释能使其便于理解一些。 LSTMs是RNNs的一个巨大进步。很自然的想到，是否有另一个巨大进步？研究者的普遍共识是：有，确实有下一步，就是 attention。Attention的思想是让RNN的每一步都从一些更大的信息集合中采集信息。例如，如果你使用RNN来为图片创造标题时，可能会选择部分图片来查找其输出的每一个词。实际上，Xu, et al. (2015) 做了这部分工作，如果想要了解attention的话，这篇论文可以作为一个很好的起点。已经有很多使用attention得到很好效果的应用，但大部分似乎是比较偏僻的方向。 Attention并不是RNN研究的唯一兴奋点。例如，Kalchbrenner, et al. (2015) 提出的Grid LSTMs似乎也很有前途。另外，在生成式模型中使用RNN，如 Gregor, et al. (2015) 、Chung, et al. (2015) 或者 Bayer &amp; Osendorfer (2015) ，看起来也很有趣。过去几年是RNN令人兴奋的时期，接下来几年相信会更好。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LSTM</tag>
        <tag>RNN</tag>
        <tag>循环神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】Explore：Array & String 数组 & 字符串]]></title>
    <url>%2F2019%2F05%2F04%2Fleetcode_explore_array_string%2F</url>
    <content type="text"><![CDATA[参考自LeetCode上Explore模块的Array &amp; String，作为笔记记录。 Overview 综述字符串是字符数组，主要了解数组和动态数组之间的区别以及基本操作。理解多维数组的使用，以及双指针技巧的使用。 主要内容： 了解数组和动态数组之间的区别； 熟悉数组和动态数组中的基本操作； 理解多维数组并能够掌握二维数组的使用； 明白字符串的概念以及字符串所具有的不同特性； 能够运用双指针技巧解决实际问题。 Introduction to Array 数组简介主要了解数组和动态数组。 数组简介 数组用于按顺序存储元素的集合。图示是一位数组的例子。数组中的元素可以随机存取，通过数组索引来识别。 数组的用法示例： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;int main() &#123; // 1. Initialize int a0[5]; int a1[5] = &#123;1, 2, 3&#125;; // other element will be set as the default value // 2. Get Length int size = sizeof(a1) / sizeof(*a1); cout &lt;&lt; "The size of a1 is: " &lt;&lt; size &lt;&lt; endl; // 3. Access Element cout &lt;&lt; "The first element is: " &lt;&lt; a1[0] &lt;&lt; endl; // 4. Iterate all Elements cout &lt;&lt; "[Version 1] The contents of a1 are:"; for (int i = 0; i &lt; size; ++i) &#123; cout &lt;&lt; " " &lt;&lt; a1[i]; &#125; cout &lt;&lt; endl; cout &lt;&lt; "[Version 2] The contents of a1 are:"; for (int&amp; item: a1) &#123; cout &lt;&lt; " " &lt;&lt; item; &#125; cout &lt;&lt; endl; // 5. Modify Element a1[0] = 4; // 6. Sort sort(a1, a1 + size);&#125; 动态数组简介多数编程语言提供内置的动态数组，例如C++中的vector，Java中的ArrayList。 动态数组用法示例： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;int main() &#123; // 1. initialize vector&lt;int&gt; v0; vector&lt;int&gt; v1(5, 0); // 2. make a copy vector&lt;int&gt; v2(v1.begin(), v1.end()); vector&lt;int&gt; v3(v2); // 2. cast an array to a vector int a[5] = &#123;0, 1, 2, 3, 4&#125;; vector&lt;int&gt; v4(a, *(&amp;a + 1)); // 3. get length cout &lt;&lt; "The size of v4 is: " &lt;&lt; v4.size() &lt;&lt; endl; // 4. access element cout &lt;&lt; "The first element in v4 is: " &lt;&lt; v4[0] &lt;&lt; endl; // 5. iterate the vector cout &lt;&lt; "[Version 1] The contents of v4 are:"; for (int i = 0; i &lt; v4.size(); ++i) &#123; cout &lt;&lt; " " &lt;&lt; v4[i]; &#125; cout &lt;&lt; endl; cout &lt;&lt; "[Version 2] The contents of v4 are:"; for (int&amp; item : v4) &#123; cout &lt;&lt; " " &lt;&lt; item; &#125; cout &lt;&lt; endl; cout &lt;&lt; "[Version 3] The contents of v4 are:"; for (auto item = v4.begin(); item != v4.end(); ++item) &#123; cout &lt;&lt; " " &lt;&lt; *item; &#125; cout &lt;&lt; endl; // 6. modify element v4[0] = 5; // 7. sort sort(v4.begin(), v4.end()); // 8. add new element at the end of the vector v4.push_back(-1); // 9. delete the last element v4.pop_back();&#125; 练习：寻找数组的中心索引给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1: 123456输入: nums = [1, 7, 3, 6, 5, 6]输出: 3解释: 索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。 示例 2: 12345输入: nums = [1, 2, 3]输出: -1解释: 数组中不存在满足此条件的中心索引。 说明: nums 的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 解题思路 首先计算数组元素总和，之后顺序遍历数组，如果当前位置左侧的和，乘以2加上当前位置的值等于数组总和，则当前位置为中心索引。 需要注意的是边界值的判断。 用到的测试用例： 123456789[1][-1,-1,-1,0,1,1][1,7,3,6,5,6][1,2,3][1,2][][1,2,3,4,6][1,2,3,6][1,1,1] 代码如下： 12345678910111213141516171819202122class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0 || nums.size() == 2) return -1; if (nums.size() == 1) return 0; int sum = 0; for (int i: nums) &#123; sum += i; &#125; int temp = 0; for (int i=0; i&lt;nums.size(); i++) &#123; if (temp * 2 + nums[i] == sum) &#123; return i; &#125; temp += nums[i]; &#125; return -1; &#125;&#125;; 其中，C++中对vector元素求和，可使用accumulate函数，头文件#include &lt;numeric&gt;如下： 1234567891011121314151617181920212223class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0 || nums.size() == 2) return -1; if (nums.size() == 1) return 0; // int sum = 0; // for (int i: nums) &#123; // sum += i; // &#125; int sum = accumulate(nums.begin(), nums.end(), 0); int temp = 0; for (int i=0; i&lt;nums.size(); i++) &#123; if (temp * 2 + nums[i] == sum) &#123; return i; &#125; temp += nums[i]; &#125; return -1; &#125;&#125;; 循环队列简单的使用动态数组和指向队列头部的索引来实现队列，会导致空间的浪费。 更有效的方法是使用循环队列，即使用固定大小的数组和两个指针来指示起始位置和结束位置，目的是重用被浪费的存储空间。 示例如图： 练习：设计循环队列设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例： 12345678910111213141516171819MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 提示： 所有的值都在 0 至 1000 的范围内； 操作数将在 1 至 1000 的范围内； 请不要使用内置的队列库。 解答：设计循环队列使用一个数组和两个指针（tail和head）表示队列的结束和起始位置。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class MyCircularQueue &#123;private: vector&lt;int&gt; data; int head; int tail; int size; public: /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue(int k) &#123; data.resize(k); size = k; head = -1; tail = -1; &#125; /** Insert an element into the circular queue. Return true if the operation is successful. */ bool enQueue(int value) &#123; if (isFull()) &#123; return false; &#125; if (isEmpty()) &#123; head = 0; &#125; tail = (tail+1) % size; data[tail] = value; return true; &#125; /** Delete an element from the circular queue. Return true if the operation is successful. */ bool deQueue() &#123; if (isEmpty()) &#123; return false; &#125; if (head == tail) &#123; head = -1; tail = -1; return true; &#125; head = (head+1) % size; return true; &#125; /** Get the front item from the queue. */ int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return data[head]; &#125; /** Get the last item from the queue. */ int Rear() &#123; if (isEmpty()) &#123; return -1; &#125; return data[tail]; &#125; /** Checks whether the circular queue is empty or not. */ bool isEmpty() &#123; return head == -1; &#125; /** Checks whether the circular queue is full or not. */ bool isFull() &#123; return (tail+1) % size == head; &#125;&#125;;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue* obj = new MyCircularQueue(k); * bool param_1 = obj-&gt;enQueue(value); * bool param_2 = obj-&gt;deQueue(); * int param_3 = obj-&gt;Front(); * int param_4 = obj-&gt;Rear(); * bool param_5 = obj-&gt;isEmpty(); * bool param_6 = obj-&gt;isFull(); */ 队列：用法大多数语言都提供内置的队列库，无需重复造轮子。 以C++内置队列库使用为例： 123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; // 1. Initialize a queue. queue&lt;int&gt; q; // 2. Push new element. q.push(5); q.push(13); q.push(8); q.push(6); // 3. Check if queue is empty. if (q.empty()) &#123; cout &lt;&lt; "Queue is empty!" &lt;&lt; endl; return 0; &#125; // 4. Pop an element. q.pop(); // 5. Get the first element. cout &lt;&lt; "The first element is: " &lt;&lt; q.front() &lt;&lt; endl; // 6. Get the last element. cout &lt;&lt; "The last element is: " &lt;&lt; q.back() &lt;&lt; endl; // 7. Get the size of the queue. cout &lt;&lt; "The size is: " &lt;&lt; q.size() &lt;&lt; endl;&#125; 当想要按顺序处理元素时，使用队列可能是一个很好的选择。 练习：Moving Average from Data Stream 【LeetCode】346 Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. For example, 12345MovingAverage m = new MovingAverage(3);m.next(1) = 1m.next(10) = (1 + 10) / 2m.next(3) = (1 + 10 + 3) / 3m.next(5) = (10 + 3 + 5) / 3 计算滑动窗口中数字的平均数。 用队列模拟窗口，队列长度为窗口大小，超过时则将首元素移出队列，返回当前队列的平均数即可。 代码如下： 12345678910111213141516171819202122232425262728class MovingAverage &#123;private: queue&lt;int&gt; que; int size; double sum;public: /** Initialize your data structure here. */ MovingAverage(int size): size(size), sum(0) &#123; &#125; double next(int val) &#123; if(que.size() &gt;= size) &#123; sum -= que.front(); que.pop(); &#125; sum += val; que.push(val); return sum/que.size(); &#125;&#125;; /** * Your MovingAverage object will be instantiated and called as such: * MovingAverage obj = new MovingAverage(size); * double param_1 = obj.next(val); */ Queue and BFS 队列和广度优先搜索广度优先搜索（BFS）是一种遍历或搜索数据结构的算法。 可以用BFS执行树的层序遍历，可以遍历图并找到从起始节点到目标节点的路径（特别是最短路径）。 队列和BFSBFS的一个常见应用是找从根节点到目标节点的最短路径。 下图展示用BFS找出节点A到目标节点G的最短路径。 上述过程中： 节点处理顺序：越是接近根节点的节点将越早被遍历，所以第一次找到目标节点时，即为最短路径。 入队出队顺序：首先根节点入队，之后每轮处理已经在队列中的点，并将所有邻居入队，新加入的节点将在下轮处理，节点处理顺序与入队的顺序相同，即FIFO，所以BFS过程中可以使用队列处理问题。 广度优先搜索——模板使用BFS的两个主要场景：遍历或找出最短路径。 BFS也可以用于更抽象的场景中，在特定问题中执行BFS之前确定节点和边缘非常重要。通常，节点是实际节点或状态，而边缘是实际边缘或可能的转换。 伪代码模板（Java）： 12345678910111213141516171819202122232425262728/** * Return the length of the shortest path between root and target node. * 返回root和target之间的最短路径 */int BFS(Node root, Node target) &#123; Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed，存储所有待处理的节点 int step = 0; // number of steps neeeded from root to current node，根节点到正在访问的当前节点的距离 // initialize add root to queue; // BFS // 每循环一层，距离根节点更远一步 while (queue is not empty) &#123; step = step + 1; // iterate the nodes which are already in the queue // 每轮中，队列中的节点是等待处理的节点 int size = queue.size(); for (int i = 0; i &lt; size; ++i) &#123; Node cur = the first node in queue; return step if cur is target; for (Node next : the neighbors of cur) &#123; add next to queue; &#125; remove the first node from queue; &#125; &#125; return -1; // there is no path from root to target&#125; 如果需要确保不会访问一个节点两次，可以在上述代码中加入一个set来记录访问过的节点，如下所示： 1234567891011121314151617181920212223242526272829/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) &#123; Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed Set&lt;Node&gt; used; // store all the used nodes int step = 0; // number of steps neeeded from root to current node // initialize add root to queue; add root to used; // BFS while (queue is not empty) &#123; step = step + 1; // iterate the nodes which are already in the queue int size = queue.size(); for (int i = 0; i &lt; size; ++i) &#123; Node cur = the first node in queue; return step if cur is target; for (Node next : the neighbors of cur) &#123; if (next is not in used) &#123; add next to queue; add next to used; &#125; &#125; remove the first node from queue; &#125; &#125; return -1; // there is no path from root to target&#125; 练习：walls and gates 【LeetCode】286 You are given a $m*n$ 2D grid initialized with these three possible values. 给定一个的用如下三个可能值初始化的$m*n$的2D网格。 -1 - A wall or an obstacle. 墙壁或障碍物。 0 - A gate. 门。 INF - Infinity means an empty room. We use the value $2^{31}-1=2147483647$ to represent INF as you may assume that the distance to a gate is less than 2147483647. Infinity是一个空房间，使用值$2^{31}-1=2147483647$来表示INF，可以假设到门的距离小于2147483647。 Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF. 在每个代表空房间的网格中填充其距离最进门的距离，如果不可能到达门，则填充INF。 For example, given the 2D grid: 1234INF -1 0 INFINF INF INF -1INF -1 INF -1 0 -1 INF INF After running your function, the 2D grid should be: 12343 -1 0 12 2 1 -11 -1 2 -10 -1 3 4 代码如下： 要注意节点的判断； 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: static const int INF = 2147483647; void wallsAndGates(vector&lt;vector&lt;int&gt;&gt;&amp; room) &#123; if (room.size() == 0) return; int row = room.size(); int col = room[0].size(); int dx[] = &#123;0, 1, 0, -1&#125;; int dy[] = &#123;1, 0, -1, 0&#125;; queue&lt;pair&lt;int, int&gt;&gt; q; // 遍历输入，将所有门的位置入队 for (int i=0; i&lt;row; i++) &#123; for (int j=0; j&lt;col; j++) &#123; if (room[i][j] == 0) &#123; q.push([i, j]); &#125; &#125; &#125; while (!q.empty()) &#123; // 首元素出队，并获取其坐标 auto head = q.front(); q.pop(); int ox = head.first; int oy = head.second; // 遍历门的四个相邻点 for (int i=0; i&lt;4; i++) &#123; int nx = ox + dx[i]; int ny = oy + dy[i]; // 如果该位置在矩阵范围内，且该位置为INF，则进行填充及入队操作，这样，等queue中所有元素都遍历完了，则矩阵所有非墙的位置就都被正确更新了 if (0 &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; room[nx][ny] == INF) &#123; q.push(&#123;nx, ny&#125;); room[nx][ny] = room[ox][oy] + 1; &#125; &#125; &#125; &#125;&#125; 练习：岛屿的个数给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 解题思路 采用广度优先遍历的方法还是很容易解决这个问题的，我们尝试遍历所有的点，如果一个点是陆地且从未遍历过，则认为发现了新岛屿，在发现了新岛屿后使用广度优先的方式扩展该岛屿以防止重复计数． 代码如下（含完整测试代码）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int count = 0; int row = grid.size(); int col = row &gt; 0 ? grid[0].size() : 0; if (row == 0 || col == 0) &#123; return count; &#125; // 记录访问过的节点 vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col, false)); // 遍历与当前节点相连的所有节点 queue&lt;pair&lt;int, int&gt;&gt; q; // 查看周围上下左右的节点 int dx[] = &#123;0, 1, 0, -1&#125;; int dy[] = &#123;1, 0, -1, 0&#125;; // 遍历所有为1的节点 for (int i=0; i&lt;row; i++) &#123; for (int j=0; j&lt;col; j++) &#123; if (grid[i][j] == '1' &amp;&amp; !visited[i][j]) &#123; // 节点为1，且没有被访问过，即为发现新的小岛 count++; // 小岛数加1 q.push(&#123;i, j&#125;); // 节点入队 visited[i][j] = true; // 修改节点访问标记 // 遍历与当前节点相连的其他节点 while (!q.empty()) &#123; auto head = q.front(); // 获取首元素及其坐标 q.pop(); int ox = head.first; int oy = head.second; // 遍历上下左右的四个节点 for (int k=0; k&lt;4; k++) &#123; int nx = ox + dx[k]; int ny = oy + dy[k]; // 如果该节点在矩阵范围内，且值为1，则入队，并修改节点访问标记，这样等队列元素遍历结束后，则当前相连区域内的节点已遍历结束，可继续寻找下一个不相连的值为1的节点，即新的岛屿 if (0 &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; grid[nx][ny] == '1' &amp;&amp; !visited[nx][ny]) &#123; visited[nx][ny] = true; q.push(&#123;nx, ny&#125;); &#125; &#125; &#125; &#125; &#125; &#125; return count; &#125;&#125;;void test(vector&lt;vector&lt;char&gt; &gt; grid) &#123; int rows = grid.size(), cols = rows &gt; 0 ? grid[0].size() : 0; if (rows == 0 || cols == 0) cout &lt;&lt; "Empty datas." &lt;&lt; endl; for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; cols; ++j) cout &lt;&lt; grid[i][j]; cout &lt;&lt; endl; &#125; Solution s; int count = s.numIslands(grid); if (count &lt;= 1) cout &lt;&lt; "There is " &lt;&lt; count &lt;&lt; " island." &lt;&lt; endl; else cout &lt;&lt; "There are " &lt;&lt; count &lt;&lt; " islands." &lt;&lt; endl;&#125;int main() &#123; vector&lt;vector&lt;char&gt; &gt; grid; vector&lt;char&gt; tmp; tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('1'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); test(grid); grid.clear(); tmp.clear(); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('1'); tmp.push_back('1'); grid.push_back(tmp); test(grid); return 0;&#125; 练习：打开转盘锁 【LeetCode】752 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; 。每个拨轮可以自由旋转：例如把 &#39;9&#39; 变为 &#39;0&#39;，&#39;0&#39; 变为 &#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 &#39;0000&#39; ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。 示例 1: 123456输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;输出：6解释：可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。 示例 2: 1234输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;输出：1解释：把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。 示例 3: 1234输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;输出：-1解释：无法旋转到目标数字且不被锁定。 示例 4: 12输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot;输出：-1 提示： 死亡列表 deadends 的长度范围为 [1, 500]。 目标数字 target 不会在 deadends 之中。 每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 &#39;0000&#39; 到 &#39;9999&#39; 中产生。 解题思路 找最短路径问题，考虑用BFS，将问题建图。 每个字符串对应一个状态，可以转换到相邻的8个状态（每位加1减1，共4位），从“0000”开始进行BFS，最后得到总步骤数。 类似用BFS遍历图，找最短路径，所以第一次到达目标节点时的路径一定是最短路径（之一）。 注意向相邻节点转换时的操作，“0”-&gt;“9”，“9”-&gt;“0”，加1，减1； 用unordered_set存储访问标记和死亡节点，节省查找过程的时间消耗； 首先对deadends进行去重，看讨论区有说会有重复的情况； BFS：从头结点”0000”开始，遍历所有子节点，初次访问且不在deadends中的则入队；已访问过或在deadends中的则跳过；遍历到下一层时，层数step加1，且更新size为下一层的节点数量； 每访问一个节点，先判断是否target，若是则返回当前的step；如果队列已空但仍未返回，则说明无路可通。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123;public: int openLock(vector&lt;string&gt;&amp; deadends, string target) &#123; if (find(deadends.begin(), deadends.end(), "0000") != deadends.end()) &#123; return -1; &#125; // deadends去重 sort(deadends.begin(), deadends.end()); deadends.erase(unique(deadends.begin(), deadends.end()), deadends.end()); unordered_set&lt;string&gt; deadset(deadends.begin(), deadends.end()); // 存储当前节点及其可转换的其他节点，以及对应的步数 queue&lt;string&gt; q; int step = 0; // 存储当前队列中可访问元素数量（每层的数量） int size = 0; unordered_set&lt;string&gt; visited; visited.insert("0000"); q.push("0000"); while (!q.empty()) &#123; size = q.size(); // 层数加1 step++; // 遍历当前层所有节点 for (int i = 0; i &lt; size; i++) &#123; string cur = q.front(); q.pop(); // 逐个遍历可转换的节点（共8个，每位加1减1） for (int j = 0; j &lt; cur.size(); j++) &#123; string temp = cur; if (temp[j] == '9') temp[j] = '0'; else temp[j] += 1; // 找到target，返回层数 if (temp == target) return step; // 没找到target，且不是死亡数字也没有访问过，则入队 if (!deadset.count(temp) &amp;&amp; !visited.count(temp)) &#123; q.push(temp); visited.insert(temp); &#125; temp = cur; if (temp[j] == '0') temp[j] = '9'; else temp[j] -= 1; if (temp == target) return step; if (!deadset.count(temp) &amp;&amp; !visited.count(temp)) &#123; q.push(temp); visited.insert(temp); &#125; &#125; &#125; &#125; return -1; &#125;&#125;; 练习：完全平方数给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 123输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路 参考网上的思路，转换为最短路径问题。 从$0$到$n$共有$n+1$个节点，如果从$i , i\in[0,n]$到$j , j\in[0,n]$相差一个完全平方数，就可以将两个节点连接起来，这样所有的点就转化成无向图，问题转化为求从$0$到$n$的最短路径。 如图所示： 无权最短路径问题，可以采用BFS求解。 也就是说，先遍历从$[1,ii],ii\leq n$，每一步将$n$缩为$n-i*i$，广度优先搜索，直至找到第一条将$n$缩为$0$的路径，即为最短路径。如下所示： 1234567891011//将num不断用完全平方数代表，直至其成为0，其中1是完全平方数所以总会有解for(int i = 1;i*i&lt;=num;i++)&#123; int temp = num - i*i; if(visit[temp] == 0) &#123; //将其中没有访问过的点标记，以及将改点所到达的路径录入 queue.add(new numpairs(temp,step+1)); visit[temp] = 1; &#125;&#125; 完整代码如下： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int numSquares(int n) &#123; if (n==0 || n==1) &#123; return n; &#125; // 从大到小初始化路径序列，如16、9、4、1 vector&lt;int&gt; square; for (int i=1; i*i&lt;=n; i++) &#123; square.insert(square.begin(), i*i); &#125; // 去掉某个平方数后剩余的n，步骤数 queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(n,0)); while(!q.empty()) &#123; int num = q.front().first; int step = q.front().second; q.pop(); for (auto it: square) &#123; if (it == num) return step+1; if (it &lt; num) &#123; q.push(make_pair(num-it, step+1)); // num-it&gt;0,入队 continue; &#125; // it&lt;num/2,重新从头遍历（从最大的开始） if (it &lt; num/2) break; &#125; &#125; &#125;&#125;; Stack: Last-in-first-out Data Structure 栈：后入先出的数据结构后入先出的数据结构 LIFO数据结构：首先处理添加到队列中的最新元素。 栈是典型的LIFO数据结构，插入删除操作称为入栈(push)出栈(pop)，新元素始终添加在堆栈的末尾，只能移除堆栈中的最后一个元素。 动态数组可用来实现堆栈结构。 栈：用法大部分语言都有内置的栈库，无需重复造轮子。 以C++内置库的使用为例： 12345678910111213141516171819202122#include &lt;iostream&gt;int main() &#123; // 1. Initialize a stack. stack&lt;int&gt; s; // 2. Push new element. s.push(5); s.push(13); s.push(8); s.push(6); // 3. Check if stack is empty. if (s.empty()) &#123; cout &lt;&lt; "Stack is empty!" &lt;&lt; endl; return 0; &#125; // 4. Pop an element. s.pop(); // 5. Get the top element. cout &lt;&lt; "The top element is: " &lt;&lt; s.top() &lt;&lt; endl; // 6. Get the size of the stack. cout &lt;&lt; "The size is: " &lt;&lt; s.size() &lt;&lt; endl;&#125; 当想要首先处理最后一个元素时，栈将是最合适的数据结构。 练习：最小栈设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) — 将元素 x 推入栈中。 pop() — 删除栈顶的元素。 top() — 获取栈顶元素。 getMin() — 检索栈中的最小元素。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解题思路 方法一，可以用两个栈，一个是题意要求的栈，另一个用来存储每次push后的当前最小值，push或pop时，同时修改两个栈的内容，存最小值的栈的top即为当前全栈最小值。 方法二，只用一个栈，再用一个额外的变量存储当前最小值。每次push时，如果要入栈的值比当前最小值小，则将当前最小值和要入栈的值同时入栈（注意先后顺序），每次pop时，要比较即将出栈的值和当前最小值是否相同，如果相同，则意味着当前最小值要更改为下一个栈顶元素（当前最小值和更新的最小值在栈内相邻）。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MinStack &#123;private: int minVal; stack&lt;int&gt; minStack;public: /** initialize your data structure here. */ MinStack() &#123; minVal = INT_MAX; &#125; void push(int x) &#123; if (x &lt;= minVal) // 需要更新最小值，并将之前的最小值先入栈 &#123; minStack.push(minVal); minVal = x; &#125; minStack.push(x); &#125; void pop() &#123; if (minStack.top() == minVal) // 需要更新最小值 &#123; minStack.pop(); minVal = minStack.top(); minStack.pop(); &#125; else minStack.pop(); &#125; int top() &#123; return minStack.top(); &#125; int getMin() &#123; return minVal; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 练习：有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 12输入: &quot;()&quot;输出: true 示例 2: 12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3: 12输入: &quot;(]&quot;输出: false 示例 4: 12输入: &quot;([)]&quot;输出: false 示例 5: 12输入: &quot;&#123;[]&#125;&quot;输出: true 解题思路 用栈结构，遍历字符串，如果是左括号就入栈，如果是右括号就看是否和栈顶元素是一对，如果是则出栈并继续，如果不是一对则返回false，如果遍历结束时栈为空则返回true，如果遍历结束时栈不为空则返回false（如”((“的情况）。 需要判断一些特殊情况，如s长度为0则直接返回true，如果s长度为奇数则直接返回false，同时top时要先确认栈非空。 代码如下： 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isValid(string s) &#123; if (s.size() == 0) return true; if (s.size() % 2 != 0) return false; stack&lt;char&gt; temp; for (auto c: s) &#123; if (c == '(' || c == '[' || c == '&#123;') temp.push(c); else if (c == ')' &amp;&amp; !temp.empty() &amp;&amp; temp.top() == '(') temp.pop(); else if (c == ']' &amp;&amp; !temp.empty() &amp;&amp; temp.top() == '[') temp.pop(); else if (c == '&#125;' &amp;&amp; !temp.empty() &amp;&amp; temp.top() == '&#123;') temp.pop(); else return false; &#125; if (temp.empty()) return true; else return false; &#125;&#125;; 练习：每日温度根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的都是 [30, 100] 范围内的整数。 解题思路 维护一个递减栈，存储元素下标。 遍历温度列表，如果栈为空则直接入栈，如果栈非空，则比较栈顶元素与当前温度，如果当前元素小于等于栈顶元素则直接入栈，如果当前元素大于栈顶元素，则表明已经找到第一次升温的位置，则直接计算下标差并修改result，之后将栈顶元素出栈，并继续比较下一个栈顶元素与当前温度值，直至当前元素小于等于栈顶元素，将当前值入栈，继续上述流程直至遍历结束。 实际做的时候，result直接初始化全0，所以遍历结束直接返回result即可。否则需要将栈内剩余元素对应result中的位置全部置0（没有找到升温的点）。 代码如下： 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; vector&lt;int&gt; result(T.size(), 0); if (T.size() &lt;= 1) &#123; return result; &#125; stack&lt;int&gt; indexStack; for (int i=0; i&lt;T.size(); i++) &#123; while (!indexStack.empty() &amp;&amp; T[i] &gt; T[indexStack.top()]) &#123; result[indexStack.top()] = i-indexStack.top(); indexStack.pop(); &#125; indexStack.push(i); &#125; return result; // result初始化全为0，所以不用再看栈中剩余元素去更新result &#125;&#125;; 练习：逆波兰表达式求值根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例 2： 123输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 示例 3： 12345678910输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 解题思路 典型用栈解决问题，计算的中间结果需要入栈。 代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; if(tokens.size() == 1) return stoi(tokens[0]); set&lt;string&gt; tag&#123;"+", "-", "*", "/"&#125;; stack&lt;int&gt; s; for(auto item: tokens) &#123; if (tag.find(item) == tag.end()) // 是数字 &#123; s.push(stoi(item)); &#125; else &#123; int temp; int a = s.top(); s.pop(); int b = s.top(); s.pop(); if (item == "+") temp = a+b; if (item == "-") temp = b-a; if (item == "*") temp = a*b; if (item == "/") temp = b/a; s.push(temp); &#125; &#125; return s.top(); &#125;&#125;; Stack and DFS 栈和深度优先搜索深度优先搜索（DFS）是用于在树/图中进行遍历/搜索的另一种算法。 在树的遍历中，可以用DFS进行前序遍历、中序遍历和后序遍历，这三种遍历的共同特点是除非到达最深的节点，否则不会回溯。 DFS和BFS的区别：BFS永远不会深入探索，除非已经遍历过当前层级的所有节点。 通常使用递归来实现DFS。 栈和DFSDFS也可以用于查找从根节点到目标节点的路径。 （BFS是可以直接找到最短路径。） 如图所示： 在上述例子中： 首先选择节点B的路径，到达E后无法深入，故回溯到A；再次选择节点C的路径，从C开始首先到达E，但E访问过，故回到C，并尝试F，最后找到了G。 DFS中找到的第一条路径不一定是最短的路径。 节点的处理和回溯过程是后进先出的处理顺序，和栈相同，故在DFS中多用栈来实现。 DFS-模板1大多可以使用BFS的情况也可以使用DFS，区别主要在遍历顺序。 BFS找到的第一条路径为最短路径，而DFS不一定。 有两种实现DFS的方法，第一种为递归。 伪代码如下： 12345678910111213/* * Return true if there is a path from cur to target. */boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) &#123; return true if cur is target; for (next : each neighbor of cur) &#123; if (next is not in visited) &#123; add next to visted; return true if DFS(next, target, visited) == true; &#125; &#125; return false;&#125; 使用递归实现DFS时，使用的是系统提供的隐式栈，也称为call stack。 在每个堆栈元素中，都有一个当前值，一个目标值，一个访问过的数组的引用，和一个对数组边界的引用，这些就是DFS函数中的参数。栈的大小是DFS的深度，所以最坏情况下，维护系统占需要$O(h)$，其中$h$是DFS的最大深度。 在计算空间复杂度时，要记得考虑系统栈。 练习：岛屿的个数给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 解题思路 之前用BFS方法做过该题，主要是先遍历当前节点相邻的所有节点，之后继续查找下一个为’1’的点，重复上述过程。 此处用DFS方法递归遍历。 首先建立visited数组来记录某个位置是否访问过，对于为’1’且未曾访问过的位置，递归进入其上下左右位置上为’1’且未访问过的点，将其visited置为true，并继续进入其相连的相邻位置，直至周围没有为’1’的点，如此可将整个连通区域中所有的数都找到，将count数加一。之后再寻找下一个为’1’且未访问过的点，重复上述过程，直至遍历完整个grid数组。 代码如下： 1234567891011121314151617181920212223242526272829303132333435// DFSclass Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int count = 0; if (grid.size() == 0 || grid[0].size() == 0) &#123; return count; &#125; // 记录访问过的节点 vector&lt;vector&lt;bool&gt;&gt; visited(grid.size(), vector&lt;bool&gt;(grid[0].size(), false)); // 遍历grid中所有节点，遇到为1且为访问过的点，则递归遍历其所有相邻点 for (int i=0; i&lt;grid.size(); i++) &#123; for (int j=0; j&lt;grid[0].size(); j++) &#123; if (grid[i][j] == '1' &amp;&amp; !visited[i][j]) &#123; helper(grid, visited, i, j); count++; &#125; &#125; &#125; return count; &#125; // 递归遍历x,y所有相邻的点 void helper(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; if (0 &lt;= x &amp;&amp; x &lt; grid.size() &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; grid[0].size() &amp;&amp; grid[x][y] == '1' &amp;&amp; !visited[x][y]) &#123; visited[x][y] = true; helper(grid, visited, x-1, y); helper(grid, visited, x+1, y); helper(grid, visited, x, y-1); helper(grid, visited, x, y+1); &#125; &#125;&#125;; 练习：克隆图给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。 示例： 12345678输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;解释：节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 提示： 节点数介于 1 到 100 之间。 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。 必须将给定节点的拷贝作为对克隆图的引用返回。 解题思路 基本是图的遍历问题，使用DFS方法解答，要注意深度拷贝每个节点后，还要将其neighbors放到一个vector中，要注意避免重复拷贝。题意明确所有节点值不同，所以可使用map来存储已经拷贝过的节点（原节点和新的克隆节点一一对应）。 在递归函数中，首先判断节点是否为空，再看当前节点是否已经克隆过，若在map中存在则已经克隆过，直接返回其映射节点。否则就克隆当前节点，并在map中建立映射，并遍历该节点的所有neighbor节点，递归调用并实时更新map即可。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; neighbors; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;;*/class Solution &#123;public: Node* cloneGraph(Node* node) &#123; // 用于存储原节点和新的克隆节点的对应，避免重复拷贝 unordered_map&lt;Node*, Node*&gt; m; return helper(node, m); &#125; Node* helper(Node* node, unordered_map&lt;Node*, Node*&gt;&amp; m) &#123; if (!node) return NULL; // 当前节点已经克隆过，则返回其对应的克隆节点 if (m.count(node)) return m[node]; // 当前节点没有克隆过： // 首先克隆当前节点，更新map Node* clone = new Node(node-&gt;val); m[node] = clone; // 克隆当前节点的所有neighbor节点，并实时更新map for (Node* neighbor : node-&gt;neighbors) &#123; clone-&gt;neighbors.push_back(helper(neighbor, m)); &#125; // 返回克隆后的节点 return clone; &#125;&#125;; 练习：目标和给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例 1: 1234567891011输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 注意: 数组的长度不会超过20，并且数组中的值全为正数。 初始的数组的和不会超过1000。 保证返回的最终结果为32位整数。 解题思路 从第一个数字开始，调用递归函数，分别计算加当前值和减当前值之后的和，到数组结束时，比较当前和和目标值是否相等。（开始看网上的方法用目标和加/减当前值做递归的目标值来计算，结果在某个测试用例时提示超过int范围，，，） 参考测试用例： 123456[1,1,1,1,1]3[2,107,109,113,127,131,137,3,2,3,5,7,11,13,17,19,23,29,47,53]2147483647[5,40,23,47,43,19,36,10,28,46,14,11,5,0,5,22,39,30,50,41]48 代码如下： 1234567891011121314151617class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; return dfs(nums, S, 0, 0); &#125; int dfs(vector&lt;int&gt;&amp; nums, int S, int index, int curSum) &#123; int res = 0; int size = nums.size(); if(index == size) return curSum==S ? 1 : 0; res += dfs(nums, S, index+1, curSum+nums[index]); res += dfs(nums, S, index+1, curSum-nums[index]); return res; &#125;&#125;; 中文版LeetCode提交上述代码时提示在上面第三个测试用例下超时，，， 使用数组记录中间值以减少重复计算。 代码如下： 123456789101112131415161718192021class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n = nums.size(); // 记录中间值，map内容 当前可得到的中间结果，得到该结果的方法数 vector&lt;unordered_map&lt;int, int&gt;&gt; dp(n + 1); // 初始dp的首值 dp[0][0] = 1; // 遍历数组 for (int i = 0; i &lt; n; ++i) &#123; // 修改加减当前值之后可得到的中间结果及其方法数 for (auto &amp;a : dp[i]) &#123; int sum = a.first, cnt = a.second; dp[i + 1][sum + nums[i]] += cnt; dp[i + 1][sum - nums[i]] += cnt; &#125; &#125; // 从最终的总方法数中，找到目标值对应的方法数 return dp[n][S]; &#125;&#125;; DFS-模板2递归虽然容易实现，但如果深度太高，容易栈溢出。这时可能希望使用BFS，或者用显式栈来实现DFS。 显式栈模板： 1234567891011121314151617181920/* * Return true if there is a path from cur to target. */boolean DFS(int root, int target) &#123; Set&lt;Node&gt; visited; Stack&lt;Node&gt; s; add root to s; while (s is not empty) &#123; Node cur = the top element in s; return true if cur is target; for (Node next : the neighbors of cur) &#123; if (next is not in visited) &#123; add next to s; add next to visited; &#125; &#125; remove cur from s; &#125; return false;&#125; 这种方法使用while和栈来模拟递归时的系统调用栈。 练习：二叉树的中序遍历给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路 中序遍历：先遍历左子树，然后访问值，再遍历右子树。 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; temp; while(root != NULL || !temp.empty()) &#123; // 递归直至最左，将所有左节点入栈 while(root != NULL) &#123; temp.push(root); root = root-&gt;left; &#125; // 栈顶节点是最左节点 // 开始出栈，且输出栈顶节点 if (!temp.empty()) &#123; root = temp.top(); result.push_back(root-&gt;val); temp.pop(); root = root-&gt;right; &#125; &#125; return result; &#125;&#125;; 小结 队列 队列是FIFO的数据结构，首先处理第一个元素； 队列两个重要操作：入队和出队； 可以用带有两个指针的动态数组来实现队列； BFS方法常使用队列结构； 栈 栈是LIFO的数据结构，首先处理最后一个元素； 栈两个重要操作：push和pop； 使用动态数组可以实现栈； DFS是栈的一个重要应用。 练习：用栈实现队列使用栈实现队列的下列操作： push(x) — 将一个元素放入队列的尾部。 pop() — 从队列首部移除元素。 peek() — 返回队列首部的元素。 empty() — 返回队列是否为空。 示例: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 — 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 解题思路 栈后进先出，队列先进先出。所以，在push的时候，借用一个额外的临时栈，首先将队列内原有元素挨个pop到临时栈（临时栈的顺序和构造的队列内顺序相反），再将新值push到临时栈，此时临时栈和要构造的队列元素顺序相反，新值在尾端。最后将临时栈再挨个pop到要构造的队列（实际也是用栈实现的）中，达到元素逆序的目的。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; stack&lt;int&gt; _stk; /** Push element x to the back of queue. */ void push(int x) &#123; stack&lt;int&gt; temp; while(!_stk.empty()) &#123; temp.push(_stk.top()); _stk.pop(); &#125; temp.push(x); while(!temp.empty()) &#123; _stk.push(temp.top()); temp.pop(); &#125; &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; int r = _stk.top(); _stk.pop(); return r; &#125; /** Get the front element. */ int peek() &#123; return _stk.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return _stk.empty(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */ 练习：用队列实现栈使用队列实现栈的下列操作： push(x) — 元素 x 入栈 pop() — 移除栈顶元素 top() — 获取栈顶元素 empty() — 返回栈是否为空 注意: 你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 解题思路 和用栈实现队列的思路类似，push过程借用一个临时队列。需要注意的是，队列先入先出，所以此处要实现栈后入先出的目的，push的新值需要先插入临时队列，以保证pop时后插入的值可以先出去。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; queue&lt;int&gt; _que; /** Push element x onto stack. */ void push(int x) &#123; queue&lt;int&gt; temp; temp.push(x); // 新值先插入到临时队列中 while(!_que.empty()) &#123; temp.push(_que.front()); _que.pop(); &#125; while(!temp.empty()) &#123; _que.push(temp.front()); temp.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int r = _que.front(); _que.pop(); return r; &#125; /** Get the top element. */ int top() &#123; return _que.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return _que.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 练习：字符串解码给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: 123s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. 解题思路 用栈，类似括号匹配，发现右括号时，开始出栈直至发现左括号，获取括号中要重复的内容，再出栈一次获取重复次数，之后将该字段重复指定次数后再入栈，直至遍历结束。将栈内容出栈，并按照指定顺序拼接成结果字符串返回即可。 注意的是，重复次数可能不是一位数字，所以在入栈时，对于连续的数字要拼接到一起再入栈。 使用的几个测试用例： 12345"3[a]2[bc]""100[leetcode]""3[a2[c]]""2[abc]3[cd]ef""2[abc]30[cd]ef" 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: string decodeString(string s) &#123; stack&lt;string&gt; stk; for (int idx = 0; idx &lt; s.size(); idx++) &#123; if (s[idx] != ']') &#123; if (isdigit(s[idx])) &#123; // 发现数字 int begin = idx; idx++; // 找到下一个不为数字的位置 while (isdigit(s[idx])) &#123; idx++; &#125; // 插入多位数字 stk.push(s.substr(begin, idx - begin)); &#125; stk.push(string(1, s[idx])); &#125; else &#123; // 获取要重复的内容 string temp = ""; while (stk.top() != "[") &#123; temp = stk.top() + temp; stk.pop(); &#125; // "[" 出栈 stk.pop(); // 获取重复次数 int num = stoi(stk.top()); stk.pop(); // 重复内容，并将结果再次入栈 string cur = ""; for (int i = 0; i &lt; num; i++) &#123; cur += temp; &#125; stk.push(cur); &#125; &#125; string result = ""; while (!stk.empty()) &#123; result = stk.top() + result; stk.pop(); &#125; return result; &#125;&#125;; 练习：图像渲染有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 示例 1: 123456789输入: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。 注意: image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。 解题思路 和前面岛屿的个数类似，主要找到与初始点颜色相同且相连的节点，将其着色返回即可。 采用BFS或DFS递归均可，此处使用BFS，首先初始点标记访问、修改颜色、入队，后遍历其相邻节点，将颜色相同的相邻点标记访问、修改颜色、入队。直至队列为空，说明与初始点相连接的所有点均遍历结束，则返回。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; // int row = image.size(); // int col = row &gt; 0 ? image[0].size() : 0; // if (row == 0 || col == 0) // return image; // 题设row col长度范围在[1,50]，所以省掉额外判断 int row = image.size(); int col = image[0].size(); // 记录访问过的节点 vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col,false)); // 记录相邻且相连的节点 queue&lt;pair&lt;int,int&gt;&gt; q; // 查看上下左右的节点用 int dx[] = &#123;0, 1, 0, -1&#125;; int dy[] = &#123;1, 0, -1, 0&#125;; // 记录初始点颜色 int tag = image[sr][sc]; // 初始点入队，标记访问，修改初始点颜色 q.push(&#123;sr, sc&#125;); visited[sr][sc] = true; image[sr][sc] = newColor; // 遍历相邻且颜色相同的点 while(!q.empty()) &#123; auto head = q.front(); // 获取首元素及坐标 q.pop(); int ox = head.first; int oy = head.second; // 遍历上下左右的点 for (int i=0; i&lt;4; i++) &#123; int nx = ox + dx[i]; int ny = oy + dy[i]; // 如果该节点在矩阵范围内，且颜色和初始点相同，则修改其颜色为newcolor，并标记访问，入队 if (0 &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; image[nx][ny] == tag &amp;&amp; !visited[nx][ny]) &#123; image[nx][ny] = newColor; visited[nx][ny] = true; q.push(&#123;nx, ny&#125;); &#125; &#125; &#125; return image; &#125;&#125;; 练习：01矩阵给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 示例 1:输入: 1230 0 00 1 00 0 0 输出: 1230 0 00 1 00 0 0 示例 2:输入: 1230 0 00 1 01 1 1 输出: 1230 0 00 1 01 2 1 注意: 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。 解题思路 找到最近的0的距离，是最短路径问题，用BFS。 类比前面 walls and gates ，首先将原矩阵中所有值为0的点入队，值为1的点设为无限大INT_MAX（为了后续比较最小距离）。 遍历queue中节点的相邻节点，若该相邻节点的值大于当前节点值加1，则将其修改为当前值加1，且将该相邻节点入队，否则跳过（当相邻节点距离更小的时候，不需要更新），直至队列为空结束。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int row = matrix.size(); int col = row &gt; 0 ? matrix[0].size() : 0; if (row == 0 || col == 0) &#123; return matrix; &#125; // 遍历当前节点相邻的节点 queue&lt;pair&lt;int, int&gt;&gt; q; // 上下左右节点 int dx[] = &#123; 0, 1, 0, -1 &#125;; int dy[] = &#123; 1, 0, -1, 0 &#125;; // 修改原矩阵，值为0的入队，值为1的将距离设为无限大INT_MAX for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (matrix[i][j] == 0) q.push(&#123; i,j &#125;); else matrix[i][j] = INT_MAX; &#125; &#125; // 遍历队列内值，即所有为0的点，从相邻节点中找非零点，如果值比当前点值加一大，则修改为当前值加一，且该相邻节点入队 while (!q.empty()) &#123; auto head = q.front(); q.pop(); // 遍历周围节点 int ox = head.first; int oy = head.second; for (int k = 0; k &lt; 4; k++) &#123; int nx = ox + dx[k]; int ny = oy + dy[k]; if (0 &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; 0 &lt;= ny &amp;&amp; ny&lt;col &amp;&amp; matrix[nx][ny]&gt;matrix[ox][oy] + 1) &#123; matrix[nx][ny] = matrix[ox][oy] + 1; q.push(&#123; nx, ny &#125;); &#125; &#125; &#125; return matrix; &#125;&#125;; 练习：钥匙和房间有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。 最初，除 0 号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回 true，否则返回 false。 示例 1： 12345678输入: [[1],[2],[3],[]]输出: true解释: 我们从 0 号房间开始，拿到钥匙 1。之后我们去 1 号房间，拿到钥匙 2。然后我们去 2 号房间，拿到钥匙 3。最后我们去了 3 号房间。由于我们能够进入每个房间，我们返回 true。 示例 2： 123输入：[[1,3],[3,0,1],[2],[0]]输出：false解释：我们不能进入 2 号房间。 提示： 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 所有房间中的钥匙数量总计不超过 3000。 解题思路 用栈实现，并且维护一个长度N的数组标记房间是否能够打开。 首先将0号房间的钥匙全部入栈，之后挨个出栈，并且判断当前的钥匙对应的房间是否已经打开，如果已经打开就跳过，如果是第一次打开，就将该房间的钥匙入栈，并标记该房间。 到栈为空时，如果标记房间的数组值全为true，则返回true，否则返回false。 同样的思路，用队列也可以，队列是BFS，栈的话就是DFS。 代码如下： 12345678910111213141516171819202122232425262728class Solution &#123;public: bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) &#123; vector&lt;int&gt; visited(rooms.size(), 0); visited[0] = 1; stack&lt;int&gt; keys; // 0号房间的钥匙入栈 for (auto key : rooms[0]) &#123; keys.push(key); &#125; // 遍历栈中所有钥匙，标记可打开的房间 while (!keys.empty()) &#123; int key = keys.top(); keys.pop(); if (visited[key] == 0) &#123; // 该房间之前没有打开过 visited[key] = 1; for (auto temp : rooms[key]) &#123; keys.push(temp); &#125; &#125; &#125; // 所有钥匙遍历结束，看visited中是否有没有打开的房间 return find(visited.begin(), visited.end(), 0) == visited.end(); &#125;&#125;;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>Array</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】Explore：Queue & Stack 队列 & 栈]]></title>
    <url>%2F2019%2F04%2F15%2Fleetcode_explore_queue_stack%2F</url>
    <content type="text"><![CDATA[参考自LeetCode上Explore模块的Queue &amp; Stack，作为笔记记录。 Overview 综述主要了解两种不同的元素处理顺序：先入先出（FIFO）和后入先出（LIFO）；以及两个相应的线性数据结构：队列（Queue）和栈（Stack）。 主要内容： 了解 FIFO 和 LIFO 处理顺序的原理； 实现这两个数据结构； 熟悉内置的队列和栈结构； 解决基本的队列相关问题，尤其是 BFS； 解决基本的栈相关问题； 理解当你使用 DFS 和其他递归算法来解决问题时，系统栈是如何帮助你的。 Queue: First-in-first-out Data Structure 队列：先入先出的数据结构先入先出的数据结构 FIFO数据结构：首先处理添加到队列中的第一个元素。 队列是典型的FIFO数据结构，插入删除操作被称为入队出队，新元素始终添加在队列末尾，只能移除第一个元素。 循环队列简单的使用动态数组和指向队列头部的索引来实现队列，会导致空间的浪费。 更有效的方法是使用循环队列，即使用固定大小的数组和两个指针来指示起始位置和结束位置，目的是重用被浪费的存储空间。 示例如图： 练习：设计循环队列设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例： 12345678910111213141516171819MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为 3circularQueue.enQueue(1); // 返回 truecircularQueue.enQueue(2); // 返回 truecircularQueue.enQueue(3); // 返回 truecircularQueue.enQueue(4); // 返回 false，队列已满circularQueue.Rear(); // 返回 3circularQueue.isFull(); // 返回 truecircularQueue.deQueue(); // 返回 truecircularQueue.enQueue(4); // 返回 truecircularQueue.Rear(); // 返回 4 提示： 所有的值都在 0 至 1000 的范围内； 操作数将在 1 至 1000 的范围内； 请不要使用内置的队列库。 解答：设计循环队列使用一个数组和两个指针（tail和head）表示队列的结束和起始位置。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class MyCircularQueue &#123;private: vector&lt;int&gt; data; int head; int tail; int size; public: /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue(int k) &#123; data.resize(k); size = k; head = -1; tail = -1; &#125; /** Insert an element into the circular queue. Return true if the operation is successful. */ bool enQueue(int value) &#123; if (isFull()) &#123; return false; &#125; if (isEmpty()) &#123; head = 0; &#125; tail = (tail+1) % size; data[tail] = value; return true; &#125; /** Delete an element from the circular queue. Return true if the operation is successful. */ bool deQueue() &#123; if (isEmpty()) &#123; return false; &#125; if (head == tail) &#123; head = -1; tail = -1; return true; &#125; head = (head+1) % size; return true; &#125; /** Get the front item from the queue. */ int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return data[head]; &#125; /** Get the last item from the queue. */ int Rear() &#123; if (isEmpty()) &#123; return -1; &#125; return data[tail]; &#125; /** Checks whether the circular queue is empty or not. */ bool isEmpty() &#123; return head == -1; &#125; /** Checks whether the circular queue is full or not. */ bool isFull() &#123; return (tail+1) % size == head; &#125;&#125;;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue* obj = new MyCircularQueue(k); * bool param_1 = obj-&gt;enQueue(value); * bool param_2 = obj-&gt;deQueue(); * int param_3 = obj-&gt;Front(); * int param_4 = obj-&gt;Rear(); * bool param_5 = obj-&gt;isEmpty(); * bool param_6 = obj-&gt;isFull(); */ 队列：用法大多数语言都提供内置的队列库，无需重复造轮子。 以C++内置队列库使用为例： 123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; // 1. Initialize a queue. queue&lt;int&gt; q; // 2. Push new element. q.push(5); q.push(13); q.push(8); q.push(6); // 3. Check if queue is empty. if (q.empty()) &#123; cout &lt;&lt; "Queue is empty!" &lt;&lt; endl; return 0; &#125; // 4. Pop an element. q.pop(); // 5. Get the first element. cout &lt;&lt; "The first element is: " &lt;&lt; q.front() &lt;&lt; endl; // 6. Get the last element. cout &lt;&lt; "The last element is: " &lt;&lt; q.back() &lt;&lt; endl; // 7. Get the size of the queue. cout &lt;&lt; "The size is: " &lt;&lt; q.size() &lt;&lt; endl;&#125; 当想要按顺序处理元素时，使用队列可能是一个很好的选择。 练习：Moving Average from Data Stream 【LeetCode】346 Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. For example, 12345MovingAverage m = new MovingAverage(3);m.next(1) = 1m.next(10) = (1 + 10) / 2m.next(3) = (1 + 10 + 3) / 3m.next(5) = (10 + 3 + 5) / 3 计算滑动窗口中数字的平均数。 用队列模拟窗口，队列长度为窗口大小，超过时则将首元素移出队列，返回当前队列的平均数即可。 代码如下： 12345678910111213141516171819202122232425262728class MovingAverage &#123;private: queue&lt;int&gt; que; int size; double sum;public: /** Initialize your data structure here. */ MovingAverage(int size): size(size), sum(0) &#123; &#125; double next(int val) &#123; if(que.size() &gt;= size) &#123; sum -= que.front(); que.pop(); &#125; sum += val; que.push(val); return sum/que.size(); &#125;&#125;; /** * Your MovingAverage object will be instantiated and called as such: * MovingAverage obj = new MovingAverage(size); * double param_1 = obj.next(val); */ Queue and BFS 队列和广度优先搜索广度优先搜索（BFS）是一种遍历或搜索数据结构的算法。 可以用BFS执行树的层序遍历，可以遍历图并找到从起始节点到目标节点的路径（特别是最短路径）。 队列和BFSBFS的一个常见应用是找从根节点到目标节点的最短路径。 下图展示用BFS找出节点A到目标节点G的最短路径。 上述过程中： 节点处理顺序：越是接近根节点的节点将越早被遍历，所以第一次找到目标节点时，即为最短路径。 入队出队顺序：首先根节点入队，之后每轮处理已经在队列中的点，并将所有邻居入队，新加入的节点将在下轮处理，节点处理顺序与入队的顺序相同，即FIFO，所以BFS过程中可以使用队列处理问题。 广度优先搜索——模板使用BFS的两个主要场景：遍历或找出最短路径。 BFS也可以用于更抽象的场景中，在特定问题中执行BFS之前确定节点和边缘非常重要。通常，节点是实际节点或状态，而边缘是实际边缘或可能的转换。 伪代码模板（Java）： 12345678910111213141516171819202122232425262728/** * Return the length of the shortest path between root and target node. * 返回root和target之间的最短路径 */int BFS(Node root, Node target) &#123; Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed，存储所有待处理的节点 int step = 0; // number of steps neeeded from root to current node，根节点到正在访问的当前节点的距离 // initialize add root to queue; // BFS // 每循环一层，距离根节点更远一步 while (queue is not empty) &#123; step = step + 1; // iterate the nodes which are already in the queue // 每轮中，队列中的节点是等待处理的节点 int size = queue.size(); for (int i = 0; i &lt; size; ++i) &#123; Node cur = the first node in queue; return step if cur is target; for (Node next : the neighbors of cur) &#123; add next to queue; &#125; remove the first node from queue; &#125; &#125; return -1; // there is no path from root to target&#125; 如果需要确保不会访问一个节点两次，可以在上述代码中加入一个set来记录访问过的节点，如下所示： 1234567891011121314151617181920212223242526272829/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) &#123; Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed Set&lt;Node&gt; used; // store all the used nodes int step = 0; // number of steps neeeded from root to current node // initialize add root to queue; add root to used; // BFS while (queue is not empty) &#123; step = step + 1; // iterate the nodes which are already in the queue int size = queue.size(); for (int i = 0; i &lt; size; ++i) &#123; Node cur = the first node in queue; return step if cur is target; for (Node next : the neighbors of cur) &#123; if (next is not in used) &#123; add next to queue; add next to used; &#125; &#125; remove the first node from queue; &#125; &#125; return -1; // there is no path from root to target&#125; 练习：walls and gates 【LeetCode】286 You are given a $m*n$ 2D grid initialized with these three possible values. 给定一个的用如下三个可能值初始化的$m*n$的2D网格。 -1 - A wall or an obstacle. 墙壁或障碍物。 0 - A gate. 门。 INF - Infinity means an empty room. We use the value $2^{31}-1=2147483647$ to represent INF as you may assume that the distance to a gate is less than 2147483647. Infinity是一个空房间，使用值$2^{31}-1=2147483647$来表示INF，可以假设到门的距离小于2147483647。 Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF. 在每个代表空房间的网格中填充其距离最进门的距离，如果不可能到达门，则填充INF。 For example, given the 2D grid: 1234INF -1 0 INFINF INF INF -1INF -1 INF -1 0 -1 INF INF After running your function, the 2D grid should be: 12343 -1 0 12 2 1 -11 -1 2 -10 -1 3 4 代码如下： 要注意节点的判断； 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: static const int INF = 2147483647; void wallsAndGates(vector&lt;vector&lt;int&gt;&gt;&amp; room) &#123; if (room.size() == 0) return; int row = room.size(); int col = room[0].size(); int dx[] = &#123;0, 1, 0, -1&#125;; int dy[] = &#123;1, 0, -1, 0&#125;; queue&lt;pair&lt;int, int&gt;&gt; q; // 遍历输入，将所有门的位置入队 for (int i=0; i&lt;row; i++) &#123; for (int j=0; j&lt;col; j++) &#123; if (room[i][j] == 0) &#123; q.push([i, j]); &#125; &#125; &#125; while (!q.empty()) &#123; // 首元素出队，并获取其坐标 auto head = q.front(); q.pop(); int ox = head.first; int oy = head.second; // 遍历门的四个相邻点 for (int i=0; i&lt;4; i++) &#123; int nx = ox + dx[i]; int ny = oy + dy[i]; // 如果该位置在矩阵范围内，且该位置为INF，则进行填充及入队操作，这样，等queue中所有元素都遍历完了，则矩阵所有非墙的位置就都被正确更新了 if (0 &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; room[nx][ny] == INF) &#123; q.push(&#123;nx, ny&#125;); room[nx][ny] = room[ox][oy] + 1; &#125; &#125; &#125; &#125;&#125; 练习：岛屿的个数给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 解题思路 采用广度优先遍历的方法还是很容易解决这个问题的，我们尝试遍历所有的点，如果一个点是陆地且从未遍历过，则认为发现了新岛屿，在发现了新岛屿后使用广度优先的方式扩展该岛屿以防止重复计数． 代码如下（含完整测试代码）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int count = 0; int row = grid.size(); int col = row &gt; 0 ? grid[0].size() : 0; if (row == 0 || col == 0) &#123; return count; &#125; // 记录访问过的节点 vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col, false)); // 遍历与当前节点相连的所有节点 queue&lt;pair&lt;int, int&gt;&gt; q; // 查看周围上下左右的节点 int dx[] = &#123;0, 1, 0, -1&#125;; int dy[] = &#123;1, 0, -1, 0&#125;; // 遍历所有为1的节点 for (int i=0; i&lt;row; i++) &#123; for (int j=0; j&lt;col; j++) &#123; if (grid[i][j] == '1' &amp;&amp; !visited[i][j]) &#123; // 节点为1，且没有被访问过，即为发现新的小岛 count++; // 小岛数加1 q.push(&#123;i, j&#125;); // 节点入队 visited[i][j] = true; // 修改节点访问标记 // 遍历与当前节点相连的其他节点 while (!q.empty()) &#123; auto head = q.front(); // 获取首元素及其坐标 q.pop(); int ox = head.first; int oy = head.second; // 遍历上下左右的四个节点 for (int k=0; k&lt;4; k++) &#123; int nx = ox + dx[k]; int ny = oy + dy[k]; // 如果该节点在矩阵范围内，且值为1，则入队，并修改节点访问标记，这样等队列元素遍历结束后，则当前相连区域内的节点已遍历结束，可继续寻找下一个不相连的值为1的节点，即新的岛屿 if (0 &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; grid[nx][ny] == '1' &amp;&amp; !visited[nx][ny]) &#123; visited[nx][ny] = true; q.push(&#123;nx, ny&#125;); &#125; &#125; &#125; &#125; &#125; &#125; return count; &#125;&#125;;void test(vector&lt;vector&lt;char&gt; &gt; grid) &#123; int rows = grid.size(), cols = rows &gt; 0 ? grid[0].size() : 0; if (rows == 0 || cols == 0) cout &lt;&lt; "Empty datas." &lt;&lt; endl; for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; cols; ++j) cout &lt;&lt; grid[i][j]; cout &lt;&lt; endl; &#125; Solution s; int count = s.numIslands(grid); if (count &lt;= 1) cout &lt;&lt; "There is " &lt;&lt; count &lt;&lt; " island." &lt;&lt; endl; else cout &lt;&lt; "There are " &lt;&lt; count &lt;&lt; " islands." &lt;&lt; endl;&#125;int main() &#123; vector&lt;vector&lt;char&gt; &gt; grid; vector&lt;char&gt; tmp; tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('1'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); test(grid); grid.clear(); tmp.clear(); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('1'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('1'); tmp.push_back('0'); tmp.push_back('0'); grid.push_back(tmp); tmp.clear(); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('0'); tmp.push_back('1'); tmp.push_back('1'); grid.push_back(tmp); test(grid); return 0;&#125; 练习：打开转盘锁 【LeetCode】752 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; 。每个拨轮可以自由旋转：例如把 &#39;9&#39; 变为 &#39;0&#39;，&#39;0&#39; 变为 &#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 &#39;0000&#39; ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。 示例 1: 123456输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;输出：6解释：可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。 示例 2: 1234输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;输出：1解释：把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。 示例 3: 1234输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;输出：-1解释：无法旋转到目标数字且不被锁定。 示例 4: 12输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot;输出：-1 提示： 死亡列表 deadends 的长度范围为 [1, 500]。 目标数字 target 不会在 deadends 之中。 每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 &#39;0000&#39; 到 &#39;9999&#39; 中产生。 解题思路 找最短路径问题，考虑用BFS，将问题建图。 每个字符串对应一个状态，可以转换到相邻的8个状态（每位加1减1，共4位），从“0000”开始进行BFS，最后得到总步骤数。 类似用BFS遍历图，找最短路径，所以第一次到达目标节点时的路径一定是最短路径（之一）。 注意向相邻节点转换时的操作，“0”-&gt;“9”，“9”-&gt;“0”，加1，减1； 用unordered_set存储访问标记和死亡节点，节省查找过程的时间消耗； 首先对deadends进行去重，看讨论区有说会有重复的情况； BFS：从头结点”0000”开始，遍历所有子节点，初次访问且不在deadends中的则入队；已访问过或在deadends中的则跳过；遍历到下一层时，层数step加1，且更新size为下一层的节点数量； 每访问一个节点，先判断是否target，若是则返回当前的step；如果队列已空但仍未返回，则说明无路可通。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123;public: int openLock(vector&lt;string&gt;&amp; deadends, string target) &#123; if (find(deadends.begin(), deadends.end(), "0000") != deadends.end()) &#123; return -1; &#125; // deadends去重 sort(deadends.begin(), deadends.end()); deadends.erase(unique(deadends.begin(), deadends.end()), deadends.end()); unordered_set&lt;string&gt; deadset(deadends.begin(), deadends.end()); // 存储当前节点及其可转换的其他节点，以及对应的步数 queue&lt;string&gt; q; int step = 0; // 存储当前队列中可访问元素数量（每层的数量） int size = 0; unordered_set&lt;string&gt; visited; visited.insert("0000"); q.push("0000"); while (!q.empty()) &#123; size = q.size(); // 层数加1 step++; // 遍历当前层所有节点 for (int i = 0; i &lt; size; i++) &#123; string cur = q.front(); q.pop(); // 逐个遍历可转换的节点（共8个，每位加1减1） for (int j = 0; j &lt; cur.size(); j++) &#123; string temp = cur; if (temp[j] == '9') temp[j] = '0'; else temp[j] += 1; // 找到target，返回层数 if (temp == target) return step; // 没找到target，且不是死亡数字也没有访问过，则入队 if (!deadset.count(temp) &amp;&amp; !visited.count(temp)) &#123; q.push(temp); visited.insert(temp); &#125; temp = cur; if (temp[j] == '0') temp[j] = '9'; else temp[j] -= 1; if (temp == target) return step; if (!deadset.count(temp) &amp;&amp; !visited.count(temp)) &#123; q.push(temp); visited.insert(temp); &#125; &#125; &#125; &#125; return -1; &#125;&#125;; 练习：完全平方数给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 123输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路 参考网上的思路，转换为最短路径问题。 从$0$到$n$共有$n+1$个节点，如果从$i , i\in[0,n]$到$j , j\in[0,n]$相差一个完全平方数，就可以将两个节点连接起来，这样所有的点就转化成无向图，问题转化为求从$0$到$n$的最短路径。 如图所示： 无权最短路径问题，可以采用BFS求解。 也就是说，先遍历从$[1,ii],ii\leq n$，每一步将$n$缩为$n-i*i$，广度优先搜索，直至找到第一条将$n$缩为$0$的路径，即为最短路径。如下所示： 1234567891011//将num不断用完全平方数代表，直至其成为0，其中1是完全平方数所以总会有解for(int i = 1;i*i&lt;=num;i++)&#123; int temp = num - i*i; if(visit[temp] == 0) &#123; //将其中没有访问过的点标记，以及将改点所到达的路径录入 queue.add(new numpairs(temp,step+1)); visit[temp] = 1; &#125;&#125; 完整代码如下： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int numSquares(int n) &#123; if (n==0 || n==1) &#123; return n; &#125; // 从大到小初始化路径序列，如16、9、4、1 vector&lt;int&gt; square; for (int i=1; i*i&lt;=n; i++) &#123; square.insert(square.begin(), i*i); &#125; // 去掉某个平方数后剩余的n，步骤数 queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(n,0)); while(!q.empty()) &#123; int num = q.front().first; int step = q.front().second; q.pop(); for (auto it: square) &#123; if (it == num) return step+1; if (it &lt; num) &#123; q.push(make_pair(num-it, step+1)); // num-it&gt;0,入队 continue; &#125; // it&lt;num/2,重新从头遍历（从最大的开始） if (it &lt; num/2) break; &#125; &#125; &#125;&#125;; Stack: Last-in-first-out Data Structure 栈：后入先出的数据结构后入先出的数据结构 LIFO数据结构：首先处理添加到队列中的最新元素。 栈是典型的LIFO数据结构，插入删除操作称为入栈(push)出栈(pop)，新元素始终添加在堆栈的末尾，只能移除堆栈中的最后一个元素。 动态数组可用来实现堆栈结构。 栈：用法大部分语言都有内置的栈库，无需重复造轮子。 以C++内置库的使用为例： 12345678910111213141516171819202122#include &lt;iostream&gt;int main() &#123; // 1. Initialize a stack. stack&lt;int&gt; s; // 2. Push new element. s.push(5); s.push(13); s.push(8); s.push(6); // 3. Check if stack is empty. if (s.empty()) &#123; cout &lt;&lt; "Stack is empty!" &lt;&lt; endl; return 0; &#125; // 4. Pop an element. s.pop(); // 5. Get the top element. cout &lt;&lt; "The top element is: " &lt;&lt; s.top() &lt;&lt; endl; // 6. Get the size of the stack. cout &lt;&lt; "The size is: " &lt;&lt; s.size() &lt;&lt; endl;&#125; 当想要首先处理最后一个元素时，栈将是最合适的数据结构。 练习：最小栈设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) — 将元素 x 推入栈中。 pop() — 删除栈顶的元素。 top() — 获取栈顶元素。 getMin() — 检索栈中的最小元素。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解题思路 方法一，可以用两个栈，一个是题意要求的栈，另一个用来存储每次push后的当前最小值，push或pop时，同时修改两个栈的内容，存最小值的栈的top即为当前全栈最小值。 方法二，只用一个栈，再用一个额外的变量存储当前最小值。每次push时，如果要入栈的值比当前最小值小，则将当前最小值和要入栈的值同时入栈（注意先后顺序），每次pop时，要比较即将出栈的值和当前最小值是否相同，如果相同，则意味着当前最小值要更改为下一个栈顶元素（当前最小值和更新的最小值在栈内相邻）。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MinStack &#123;private: int minVal; stack&lt;int&gt; minStack;public: /** initialize your data structure here. */ MinStack() &#123; minVal = INT_MAX; &#125; void push(int x) &#123; if (x &lt;= minVal) // 需要更新最小值，并将之前的最小值先入栈 &#123; minStack.push(minVal); minVal = x; &#125; minStack.push(x); &#125; void pop() &#123; if (minStack.top() == minVal) // 需要更新最小值 &#123; minStack.pop(); minVal = minStack.top(); minStack.pop(); &#125; else minStack.pop(); &#125; int top() &#123; return minStack.top(); &#125; int getMin() &#123; return minVal; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 练习：有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 12输入: &quot;()&quot;输出: true 示例 2: 12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3: 12输入: &quot;(]&quot;输出: false 示例 4: 12输入: &quot;([)]&quot;输出: false 示例 5: 12输入: &quot;&#123;[]&#125;&quot;输出: true 解题思路 用栈结构，遍历字符串，如果是左括号就入栈，如果是右括号就看是否和栈顶元素是一对，如果是则出栈并继续，如果不是一对则返回false，如果遍历结束时栈为空则返回true，如果遍历结束时栈不为空则返回false（如”((“的情况）。 需要判断一些特殊情况，如s长度为0则直接返回true，如果s长度为奇数则直接返回false，同时top时要先确认栈非空。 代码如下： 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isValid(string s) &#123; if (s.size() == 0) return true; if (s.size() % 2 != 0) return false; stack&lt;char&gt; temp; for (auto c: s) &#123; if (c == '(' || c == '[' || c == '&#123;') temp.push(c); else if (c == ')' &amp;&amp; !temp.empty() &amp;&amp; temp.top() == '(') temp.pop(); else if (c == ']' &amp;&amp; !temp.empty() &amp;&amp; temp.top() == '[') temp.pop(); else if (c == '&#125;' &amp;&amp; !temp.empty() &amp;&amp; temp.top() == '&#123;') temp.pop(); else return false; &#125; if (temp.empty()) return true; else return false; &#125;&#125;; 练习：每日温度根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的都是 [30, 100] 范围内的整数。 解题思路 维护一个递减栈，存储元素下标。 遍历温度列表，如果栈为空则直接入栈，如果栈非空，则比较栈顶元素与当前温度，如果当前元素小于等于栈顶元素则直接入栈，如果当前元素大于栈顶元素，则表明已经找到第一次升温的位置，则直接计算下标差并修改result，之后将栈顶元素出栈，并继续比较下一个栈顶元素与当前温度值，直至当前元素小于等于栈顶元素，将当前值入栈，继续上述流程直至遍历结束。 实际做的时候，result直接初始化全0，所以遍历结束直接返回result即可。否则需要将栈内剩余元素对应result中的位置全部置0（没有找到升温的点）。 代码如下： 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; vector&lt;int&gt; result(T.size(), 0); if (T.size() &lt;= 1) &#123; return result; &#125; stack&lt;int&gt; indexStack; for (int i=0; i&lt;T.size(); i++) &#123; while (!indexStack.empty() &amp;&amp; T[i] &gt; T[indexStack.top()]) &#123; result[indexStack.top()] = i-indexStack.top(); indexStack.pop(); &#125; indexStack.push(i); &#125; return result; // result初始化全为0，所以不用再看栈中剩余元素去更新result &#125;&#125;; 练习：逆波兰表达式求值根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例 2： 123输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 示例 3： 12345678910输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 解题思路 典型用栈解决问题，计算的中间结果需要入栈。 代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; if(tokens.size() == 1) return stoi(tokens[0]); set&lt;string&gt; tag&#123;"+", "-", "*", "/"&#125;; stack&lt;int&gt; s; for(auto item: tokens) &#123; if (tag.find(item) == tag.end()) // 是数字 &#123; s.push(stoi(item)); &#125; else &#123; int temp; int a = s.top(); s.pop(); int b = s.top(); s.pop(); if (item == "+") temp = a+b; if (item == "-") temp = b-a; if (item == "*") temp = a*b; if (item == "/") temp = b/a; s.push(temp); &#125; &#125; return s.top(); &#125;&#125;; Stack and DFS 栈和深度优先搜索深度优先搜索（DFS）是用于在树/图中进行遍历/搜索的另一种算法。 在树的遍历中，可以用DFS进行前序遍历、中序遍历和后序遍历，这三种遍历的共同特点是除非到达最深的节点，否则不会回溯。 DFS和BFS的区别：BFS永远不会深入探索，除非已经遍历过当前层级的所有节点。 通常使用递归来实现DFS。 栈和DFSDFS也可以用于查找从根节点到目标节点的路径。 （BFS是可以直接找到最短路径。） 如图所示： 在上述例子中： 首先选择节点B的路径，到达E后无法深入，故回溯到A；再次选择节点C的路径，从C开始首先到达E，但E访问过，故回到C，并尝试F，最后找到了G。 DFS中找到的第一条路径不一定是最短的路径。 节点的处理和回溯过程是后进先出的处理顺序，和栈相同，故在DFS中多用栈来实现。 DFS-模板1大多可以使用BFS的情况也可以使用DFS，区别主要在遍历顺序。 BFS找到的第一条路径为最短路径，而DFS不一定。 有两种实现DFS的方法，第一种为递归。 伪代码如下： 12345678910111213/* * Return true if there is a path from cur to target. */boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) &#123; return true if cur is target; for (next : each neighbor of cur) &#123; if (next is not in visited) &#123; add next to visted; return true if DFS(next, target, visited) == true; &#125; &#125; return false;&#125; 使用递归实现DFS时，使用的是系统提供的隐式栈，也称为call stack。 在每个堆栈元素中，都有一个当前值，一个目标值，一个访问过的数组的引用，和一个对数组边界的引用，这些就是DFS函数中的参数。栈的大小是DFS的深度，所以最坏情况下，维护系统占需要$O(h)$，其中$h$是DFS的最大深度。 在计算空间复杂度时，要记得考虑系统栈。 练习：岛屿的个数给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 解题思路 之前用BFS方法做过该题，主要是先遍历当前节点相邻的所有节点，之后继续查找下一个为’1’的点，重复上述过程。 此处用DFS方法递归遍历。 首先建立visited数组来记录某个位置是否访问过，对于为’1’且未曾访问过的位置，递归进入其上下左右位置上为’1’且未访问过的点，将其visited置为true，并继续进入其相连的相邻位置，直至周围没有为’1’的点，如此可将整个连通区域中所有的数都找到，将count数加一。之后再寻找下一个为’1’且未访问过的点，重复上述过程，直至遍历完整个grid数组。 代码如下： 1234567891011121314151617181920212223242526272829303132333435// DFSclass Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int count = 0; if (grid.size() == 0 || grid[0].size() == 0) &#123; return count; &#125; // 记录访问过的节点 vector&lt;vector&lt;bool&gt;&gt; visited(grid.size(), vector&lt;bool&gt;(grid[0].size(), false)); // 遍历grid中所有节点，遇到为1且为访问过的点，则递归遍历其所有相邻点 for (int i=0; i&lt;grid.size(); i++) &#123; for (int j=0; j&lt;grid[0].size(); j++) &#123; if (grid[i][j] == '1' &amp;&amp; !visited[i][j]) &#123; helper(grid, visited, i, j); count++; &#125; &#125; &#125; return count; &#125; // 递归遍历x,y所有相邻的点 void helper(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; if (0 &lt;= x &amp;&amp; x &lt; grid.size() &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; grid[0].size() &amp;&amp; grid[x][y] == '1' &amp;&amp; !visited[x][y]) &#123; visited[x][y] = true; helper(grid, visited, x-1, y); helper(grid, visited, x+1, y); helper(grid, visited, x, y-1); helper(grid, visited, x, y+1); &#125; &#125;&#125;; 练习：克隆图给定无向连通图中一个节点的引用，返回该图的深拷贝（克隆）。图中的每个节点都包含它的值 val（Int） 和其邻居的列表（list[Node]）。 示例： 12345678输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;解释：节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 提示： 节点数介于 1 到 100 之间。 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。 必须将给定节点的拷贝作为对克隆图的引用返回。 解题思路 基本是图的遍历问题，使用DFS方法解答，要注意深度拷贝每个节点后，还要将其neighbors放到一个vector中，要注意避免重复拷贝。题意明确所有节点值不同，所以可使用map来存储已经拷贝过的节点（原节点和新的克隆节点一一对应）。 在递归函数中，首先判断节点是否为空，再看当前节点是否已经克隆过，若在map中存在则已经克隆过，直接返回其映射节点。否则就克隆当前节点，并在map中建立映射，并遍历该节点的所有neighbor节点，递归调用并实时更新map即可。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; neighbors; Node() &#123;&#125; Node(int _val, vector&lt;Node*&gt; _neighbors) &#123; val = _val; neighbors = _neighbors; &#125;&#125;;*/class Solution &#123;public: Node* cloneGraph(Node* node) &#123; // 用于存储原节点和新的克隆节点的对应，避免重复拷贝 unordered_map&lt;Node*, Node*&gt; m; return helper(node, m); &#125; Node* helper(Node* node, unordered_map&lt;Node*, Node*&gt;&amp; m) &#123; if (!node) return NULL; // 当前节点已经克隆过，则返回其对应的克隆节点 if (m.count(node)) return m[node]; // 当前节点没有克隆过： // 首先克隆当前节点，更新map Node* clone = new Node(node-&gt;val); m[node] = clone; // 克隆当前节点的所有neighbor节点，并实时更新map for (Node* neighbor : node-&gt;neighbors) &#123; clone-&gt;neighbors.push_back(helper(neighbor, m)); &#125; // 返回克隆后的节点 return clone; &#125;&#125;; 练习：目标和给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例 1: 1234567891011输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 注意: 数组的长度不会超过20，并且数组中的值全为正数。 初始的数组的和不会超过1000。 保证返回的最终结果为32位整数。 解题思路 从第一个数字开始，调用递归函数，分别计算加当前值和减当前值之后的和，到数组结束时，比较当前和和目标值是否相等。（开始看网上的方法用目标和加/减当前值做递归的目标值来计算，结果在某个测试用例时提示超过int范围，，，） 参考测试用例： 123456[1,1,1,1,1]3[2,107,109,113,127,131,137,3,2,3,5,7,11,13,17,19,23,29,47,53]2147483647[5,40,23,47,43,19,36,10,28,46,14,11,5,0,5,22,39,30,50,41]48 代码如下： 1234567891011121314151617class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; return dfs(nums, S, 0, 0); &#125; int dfs(vector&lt;int&gt;&amp; nums, int S, int index, int curSum) &#123; int res = 0; int size = nums.size(); if(index == size) return curSum==S ? 1 : 0; res += dfs(nums, S, index+1, curSum+nums[index]); res += dfs(nums, S, index+1, curSum-nums[index]); return res; &#125;&#125;; 中文版LeetCode提交上述代码时提示在上面第三个测试用例下超时，，， 使用数组记录中间值以减少重复计算。 代码如下： 123456789101112131415161718192021class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n = nums.size(); // 记录中间值，map内容 当前可得到的中间结果，得到该结果的方法数 vector&lt;unordered_map&lt;int, int&gt;&gt; dp(n + 1); // 初始dp的首值 dp[0][0] = 1; // 遍历数组 for (int i = 0; i &lt; n; ++i) &#123; // 修改加减当前值之后可得到的中间结果及其方法数 for (auto &amp;a : dp[i]) &#123; int sum = a.first, cnt = a.second; dp[i + 1][sum + nums[i]] += cnt; dp[i + 1][sum - nums[i]] += cnt; &#125; &#125; // 从最终的总方法数中，找到目标值对应的方法数 return dp[n][S]; &#125;&#125;; DFS-模板2递归虽然容易实现，但如果深度太高，容易栈溢出。这时可能希望使用BFS，或者用显式栈来实现DFS。 显式栈模板： 1234567891011121314151617181920/* * Return true if there is a path from cur to target. */boolean DFS(int root, int target) &#123; Set&lt;Node&gt; visited; Stack&lt;Node&gt; s; add root to s; while (s is not empty) &#123; Node cur = the top element in s; return true if cur is target; for (Node next : the neighbors of cur) &#123; if (next is not in visited) &#123; add next to s; add next to visited; &#125; &#125; remove cur from s; &#125; return false;&#125; 这种方法使用while和栈来模拟递归时的系统调用栈。 练习：二叉树的中序遍历给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路 中序遍历：先遍历左子树，然后访问值，再遍历右子树。 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; temp; while(root != NULL || !temp.empty()) &#123; // 递归直至最左，将所有左节点入栈 while(root != NULL) &#123; temp.push(root); root = root-&gt;left; &#125; // 栈顶节点是最左节点 // 开始出栈，且输出栈顶节点 if (!temp.empty()) &#123; root = temp.top(); result.push_back(root-&gt;val); temp.pop(); root = root-&gt;right; &#125; &#125; return result; &#125;&#125;; 小结 队列 队列是FIFO的数据结构，首先处理第一个元素； 队列两个重要操作：入队和出队； 可以用带有两个指针的动态数组来实现队列； BFS方法常使用队列结构； 栈 栈是LIFO的数据结构，首先处理最后一个元素； 栈两个重要操作：push和pop； 使用动态数组可以实现栈； DFS是栈的一个重要应用。 练习：用栈实现队列使用栈实现队列的下列操作： push(x) — 将一个元素放入队列的尾部。 pop() — 从队列首部移除元素。 peek() — 返回队列首部的元素。 empty() — 返回队列是否为空。 示例: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 — 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 解题思路 栈后进先出，队列先进先出。所以，在push的时候，借用一个额外的临时栈，首先将队列内原有元素挨个pop到临时栈（临时栈的顺序和构造的队列内顺序相反），再将新值push到临时栈，此时临时栈和要构造的队列元素顺序相反，新值在尾端。最后将临时栈再挨个pop到要构造的队列（实际也是用栈实现的）中，达到元素逆序的目的。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; stack&lt;int&gt; _stk; /** Push element x to the back of queue. */ void push(int x) &#123; stack&lt;int&gt; temp; while(!_stk.empty()) &#123; temp.push(_stk.top()); _stk.pop(); &#125; temp.push(x); while(!temp.empty()) &#123; _stk.push(temp.top()); temp.pop(); &#125; &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; int r = _stk.top(); _stk.pop(); return r; &#125; /** Get the front element. */ int peek() &#123; return _stk.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return _stk.empty(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */ 练习：用队列实现栈使用队列实现栈的下列操作： push(x) — 元素 x 入栈 pop() — 移除栈顶元素 top() — 获取栈顶元素 empty() — 返回栈是否为空 注意: 你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 解题思路 和用栈实现队列的思路类似，push过程借用一个临时队列。需要注意的是，队列先入先出，所以此处要实现栈后入先出的目的，push的新值需要先插入临时队列，以保证pop时后插入的值可以先出去。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; queue&lt;int&gt; _que; /** Push element x onto stack. */ void push(int x) &#123; queue&lt;int&gt; temp; temp.push(x); // 新值先插入到临时队列中 while(!_que.empty()) &#123; temp.push(_que.front()); _que.pop(); &#125; while(!temp.empty()) &#123; _que.push(temp.front()); temp.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int r = _que.front(); _que.pop(); return r; &#125; /** Get the top element. */ int top() &#123; return _que.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return _que.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 练习：字符串解码给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: 123s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. 解题思路 用栈，类似括号匹配，发现右括号时，开始出栈直至发现左括号，获取括号中要重复的内容，再出栈一次获取重复次数，之后将该字段重复指定次数后再入栈，直至遍历结束。将栈内容出栈，并按照指定顺序拼接成结果字符串返回即可。 注意的是，重复次数可能不是一位数字，所以在入栈时，对于连续的数字要拼接到一起再入栈。 使用的几个测试用例： 12345"3[a]2[bc]""100[leetcode]""3[a2[c]]""2[abc]3[cd]ef""2[abc]30[cd]ef" 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: string decodeString(string s) &#123; stack&lt;string&gt; stk; for (int idx = 0; idx &lt; s.size(); idx++) &#123; if (s[idx] != ']') &#123; if (isdigit(s[idx])) &#123; // 发现数字 int begin = idx; idx++; // 找到下一个不为数字的位置 while (isdigit(s[idx])) &#123; idx++; &#125; // 插入多位数字 stk.push(s.substr(begin, idx - begin)); &#125; stk.push(string(1, s[idx])); &#125; else &#123; // 获取要重复的内容 string temp = ""; while (stk.top() != "[") &#123; temp = stk.top() + temp; stk.pop(); &#125; // "[" 出栈 stk.pop(); // 获取重复次数 int num = stoi(stk.top()); stk.pop(); // 重复内容，并将结果再次入栈 string cur = ""; for (int i = 0; i &lt; num; i++) &#123; cur += temp; &#125; stk.push(cur); &#125; &#125; string result = ""; while (!stk.empty()) &#123; result = stk.top() + result; stk.pop(); &#125; return result; &#125;&#125;; 练习：图像渲染有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 示例 1: 123456789输入: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。 注意: image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 &lt;= sr &lt; image.length 和 0 &lt;= sc &lt; image[0].length。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。 解题思路 和前面岛屿的个数类似，主要找到与初始点颜色相同且相连的节点，将其着色返回即可。 采用BFS或DFS递归均可，此处使用BFS，首先初始点标记访问、修改颜色、入队，后遍历其相邻节点，将颜色相同的相邻点标记访问、修改颜色、入队。直至队列为空，说明与初始点相连接的所有点均遍历结束，则返回。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; // int row = image.size(); // int col = row &gt; 0 ? image[0].size() : 0; // if (row == 0 || col == 0) // return image; // 题设row col长度范围在[1,50]，所以省掉额外判断 int row = image.size(); int col = image[0].size(); // 记录访问过的节点 vector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col,false)); // 记录相邻且相连的节点 queue&lt;pair&lt;int,int&gt;&gt; q; // 查看上下左右的节点用 int dx[] = &#123;0, 1, 0, -1&#125;; int dy[] = &#123;1, 0, -1, 0&#125;; // 记录初始点颜色 int tag = image[sr][sc]; // 初始点入队，标记访问，修改初始点颜色 q.push(&#123;sr, sc&#125;); visited[sr][sc] = true; image[sr][sc] = newColor; // 遍历相邻且颜色相同的点 while(!q.empty()) &#123; auto head = q.front(); // 获取首元素及坐标 q.pop(); int ox = head.first; int oy = head.second; // 遍历上下左右的点 for (int i=0; i&lt;4; i++) &#123; int nx = ox + dx[i]; int ny = oy + dy[i]; // 如果该节点在矩阵范围内，且颜色和初始点相同，则修改其颜色为newcolor，并标记访问，入队 if (0 &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; image[nx][ny] == tag &amp;&amp; !visited[nx][ny]) &#123; image[nx][ny] = newColor; visited[nx][ny] = true; q.push(&#123;nx, ny&#125;); &#125; &#125; &#125; return image; &#125;&#125;; 练习：01矩阵给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。 两个相邻元素间的距离为 1 。 示例 1:输入: 1230 0 00 1 00 0 0 输出: 1230 0 00 1 00 0 0 示例 2:输入: 1230 0 00 1 01 1 1 输出: 1230 0 00 1 01 2 1 注意: 给定矩阵的元素个数不超过 10000。 给定矩阵中至少有一个元素是 0。 矩阵中的元素只在四个方向上相邻: 上、下、左、右。 解题思路 找到最近的0的距离，是最短路径问题，用BFS。 类比前面 walls and gates ，首先将原矩阵中所有值为0的点入队，值为1的点设为无限大INT_MAX（为了后续比较最小距离）。 遍历queue中节点的相邻节点，若该相邻节点的值大于当前节点值加1，则将其修改为当前值加1，且将该相邻节点入队，否则跳过（当相邻节点距离更小的时候，不需要更新），直至队列为空结束。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int row = matrix.size(); int col = row &gt; 0 ? matrix[0].size() : 0; if (row == 0 || col == 0) &#123; return matrix; &#125; // 遍历当前节点相邻的节点 queue&lt;pair&lt;int, int&gt;&gt; q; // 上下左右节点 int dx[] = &#123; 0, 1, 0, -1 &#125;; int dy[] = &#123; 1, 0, -1, 0 &#125;; // 修改原矩阵，值为0的入队，值为1的将距离设为无限大INT_MAX for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; if (matrix[i][j] == 0) q.push(&#123; i,j &#125;); else matrix[i][j] = INT_MAX; &#125; &#125; // 遍历队列内值，即所有为0的点，从相邻节点中找非零点，如果值比当前点值加一大，则修改为当前值加一，且该相邻节点入队 while (!q.empty()) &#123; auto head = q.front(); q.pop(); // 遍历周围节点 int ox = head.first; int oy = head.second; for (int k = 0; k &lt; 4; k++) &#123; int nx = ox + dx[k]; int ny = oy + dy[k]; if (0 &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; 0 &lt;= ny &amp;&amp; ny&lt;col &amp;&amp; matrix[nx][ny]&gt;matrix[ox][oy] + 1) &#123; matrix[nx][ny] = matrix[ox][oy] + 1; q.push(&#123; nx, ny &#125;); &#125; &#125; &#125; return matrix; &#125;&#125;; 练习：钥匙和房间有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。 在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。 最初，除 0 号房间外的其余所有房间都被锁住。 你可以自由地在房间之间来回走动。 如果能进入每个房间返回 true，否则返回 false。 示例 1： 12345678输入: [[1],[2],[3],[]]输出: true解释: 我们从 0 号房间开始，拿到钥匙 1。之后我们去 1 号房间，拿到钥匙 2。然后我们去 2 号房间，拿到钥匙 3。最后我们去了 3 号房间。由于我们能够进入每个房间，我们返回 true。 示例 2： 123输入：[[1,3],[3,0,1],[2],[0]]输出：false解释：我们不能进入 2 号房间。 提示： 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms[i].length &lt;= 1000 所有房间中的钥匙数量总计不超过 3000。 解题思路 用栈实现，并且维护一个长度N的数组标记房间是否能够打开。 首先将0号房间的钥匙全部入栈，之后挨个出栈，并且判断当前的钥匙对应的房间是否已经打开，如果已经打开就跳过，如果是第一次打开，就将该房间的钥匙入栈，并标记该房间。 到栈为空时，如果标记房间的数组值全为true，则返回true，否则返回false。 同样的思路，用队列也可以，队列是BFS，栈的话就是DFS。 代码如下： 12345678910111213141516171819202122232425262728class Solution &#123;public: bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) &#123; vector&lt;int&gt; visited(rooms.size(), 0); visited[0] = 1; stack&lt;int&gt; keys; // 0号房间的钥匙入栈 for (auto key : rooms[0]) &#123; keys.push(key); &#125; // 遍历栈中所有钥匙，标记可打开的房间 while (!keys.empty()) &#123; int key = keys.top(); keys.pop(); if (visited[key] == 0) &#123; // 该房间之前没有打开过 visited[key] = 1; for (auto temp : rooms[key]) &#123; keys.push(temp); &#125; &#125; &#125; // 所有钥匙遍历结束，看visited中是否有没有打开的房间 return find(visited.begin(), visited.end(), 0) == visited.end(); &#125;&#125;;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>队列</tag>
        <tag>栈</tag>
        <tag>Queue</tag>
        <tag>Stack</tag>
        <tag>广度优先搜索</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>FIFO</tag>
        <tag>LIFO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】Explore：Binary Tree 二叉树]]></title>
    <url>%2F2019%2F04%2F02%2Fleetcode_explore_binary_tree%2F</url>
    <content type="text"><![CDATA[参考自LeetCode上Explore模块的Binary Tree，作为笔记记录。 Overview 综述树可以视为包含N个节点和N-1条边的有向无环图。 二叉树是每个节点最多有两个子树的树结构，子树称为左子树和右子树。 Traverse A Tree 树的遍历主要内容： 理解和区分树的遍历方法 能够运用递归方法解决树的为前序遍历、中序遍历和后序遍历问题 能用运用迭代方法解决树的为前序遍历、中序遍历和后序遍历问题 能用运用广度优先搜索解决树的层序遍历问题 树的遍历介绍 前中后序主要是看根节点什么时候访问。 前序遍历（Pre-order Traversal）前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。 中序遍历（In-order Traversal）中序遍历首先遍历左子树，然后访问根节点，最后遍历右子树。 一般，对于二叉搜索树，可以通过中序遍历得到一个递增的有序序列。 后序遍历（Post-order Traversal）后序遍历首先遍历左子树，然后遍历右子树，最后访问根节点。 删除树中的节点的时候，删除过程将按照后序遍历的顺序进行。即，删除一个节点时，将首先删除其左节点和右节点，然后再删除节点本身。 数学表达式中，可以用中序遍历找出原始表达式，但是解析处理的时候，使用后序遍历更容易，每遇到一个操作符就从栈中弹出栈顶的两个元素进行计算，将计算结果返回栈中。 递归和迭代实现树的遍历递归：程序返回一个函数，这个函数继续返回一个函数，直至达到最初的递归终止条件，然后一步步返回，最终得到结果； 迭代：在给定条件下直接循环计算，从小到大直至返回最终结果； 前序遍历给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 递归实现：123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if(root == NULL) return result; result.push_back(root-&gt;val); vector&lt;int&gt; temp = preorderTraversal(root-&gt;left); result.insert(result.end(),temp.begin(),temp.end()); temp = preorderTraversal(root-&gt;right); result.insert(result.end(),temp.begin(),temp.end()); return result; &#125;&#125;; 迭代实现：前序遍历先访问根节点，之后访问左子树和右子树。 对于任一节点，可以看做是根节点直接访问，访问结束后，如果左子树非空，则同样规则访问左子树，到达最左后，再访问右子树。 从根节点开始遍历，同时输出根节点； 递归输出直至最左； 到达最左后，访问右节点； 因此处理过程如下： 对于任一节点P： 访问节点P，并将节点P入栈； 判断节点P的左子树是否为空，为空则取栈顶节点，并进行出栈操作，并将栈顶节点的右孩子置为当前的节点P，循环至1；若不为空，则将P的左孩子置为当前的节点P； 直至P为NULL且栈为空，则遍历结束； 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; s; vector&lt;int&gt; result; while(root != NULL || !s.empty()) &#123; // 输出当前子树的根节点，然后递归直至最左 while(root != NULL) &#123; result.push_back(root-&gt;val); s.push(root); root = root-&gt;left; &#125; // 循环结束时，栈顶节点已经是最左节点 // 开始出栈，并输出节点的右节点 if(!s.empty()) &#123; root = s.top(); s.pop(); root = root-&gt;right; &#125; &#125; return result; &#125;&#125;; 中序遍历给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 递归实现：123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if(root == NULL) return result; vector&lt;int&gt; temp = inorderTraversal(root-&gt;left); result.insert(result.end(), temp.begin(), temp.end()); result.push_back(root-&gt;val); temp = inorderTraversal(root-&gt;right); result.insert(result.end(), temp.begin(), temp.end()); return result; &#125;&#125;; 迭代实现：中序遍历先访问左子树，再访问根节点和右子树。 对于任一节点，优先访问左节点，左节点可视为又一根节点，继续访问其左子树，直至到最左节点，之后按相同规则访问右子树。 从根节点开始遍历； 递归直至最左，然后输出（中序遍历首先输出的是最左叶子节点）； 到达最左后，访问右节点。 处理过程如下： 对于任一节点P： 若左子树不空，则将P入栈并将P的左孩子置为当前节点P，再对当前节点P进行相同处理； 若左子树为空，则取栈顶元素并进行出栈操作，访问栈顶节点，并将当前节点P置为栈顶节点的右孩子； 直至P为NULL或栈为空则结束遍历。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; s; while(root != NULL || !s.empty()) &#123; // 不输出当前根节点，递归直至最左 while(root != NULL) &#123; s.push(root); root = root-&gt;left; &#125; // 栈顶节点是最左节点 // 开始出栈，且输出栈顶节点 if(!s.empty()) &#123; root = s.top(); result.push_back(root-&gt;val); s.pop(); root = root-&gt;right; &#125; &#125; return result; &#125;&#125;; 后序遍历给定一个二叉树，返回它的 后序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 递归实现：12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; if(root == NULL) &#123; return result; &#125; vector&lt;int&gt; temp = postorderTraversal(root-&gt;left); result.insert(result.end(), temp.begin(), temp.end()); temp = postorderTraversal(root-&gt;right); result.insert(result.end(), temp.begin(), temp.end()); result.push_back(root-&gt;val); return result; &#125;&#125;; 迭代实现：后序遍历是先访问左子树和右子树，最后访问根节点。 后序遍历比前序和中序要相对复杂，因为要保证左子树和右子树都已经被访问，并且左子树在右子树之前被访问，之后才能访问根节点。 所以按照之前前序和中序的思路，在流程控制上需要做一定调整。 处理过程如下： 对于任一节点P，将其入栈，并沿左子树遍历到最左节点，此时该节点在栈顶，但不能出栈访问，因为还没有访问右子树。 按照相同规则访问右子树，当访问完右子树后，这个节点又出现在栈顶，此时可以将其出栈并访问，从而保证正确的访问顺序。 由上可知，每个节点会两次出现在栈顶，只有第二次出现在栈顶的时候才可以访问并出栈，因此需要多设置一个变量来标识节点是否第一次出现在栈顶。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; s; unordered_map&lt;TreeNode*, bool&gt; visited; // 用于标记访问过的节点 while(root != NULL || !s.empty()) &#123; // 递归直至最左 while(root!=NULL) &#123; visited[root] = true; // 当前节点首次被访问 s.push(root); root = root-&gt;left; &#125; // 栈顶节点是最左节点 if(!s.empty()) &#123; root = s.top(); s.pop(); if(visited[root]) // 第一次出现在栈顶 &#123; // 再重新入栈，访问右子树 s.push(root); visited[root] = false; root = root-&gt;right; // 改变当前节点P的操作要在visited[root]修改之后 &#125; else // 第二次出现在栈顶 &#123; result.push_back(root-&gt;val); root = NULL; &#125; &#125; &#125; return result; &#125;&#125;; 层序遍历层序遍历就是逐层遍历树结构。 使用广度优先搜索遍历树时，就是按照层序遍历顺序进行的：从一个根节点开始，首先访问节点本身，之后遍历其相邻节点，其次遍历其二级邻节点、三级邻节点，以此类推。 过程如下图所示： 实现给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 使用队列来辅助实现。用队列记录当前一层的节点，从根节点开始。每次遍历完一层时，先计算队列中的元素数量size，用size控制之后要处理的节点数量（因为每次处理一个节点的时候，会将其左右子节点压入队列，所以队列中会加入下一层的节点，所以需要通过size来控制当前层要处理的节点数量）。所有节点处理结束后，队列为空，则遍历结束。 代码如下： 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; if(!root) return result; queue&lt;TreeNode*&gt; q; q.push(root); // 从根节点开始处理 while(!q.empty()) &#123; vector&lt;int&gt; temp; // 临时记录当前层的节点 auto size=q.size(); // 用size控制队列中要处理的当前层节点数量 while(size--) &#123; TreeNode* node = q.front(); // 从先入队列的节点开始处理 q.pop(); if(node-&gt;left) // 将该节点的左孩子压入队列 q.push(node-&gt;left); if(node-&gt;right) // 将该节点的右孩子压入队列 q.push(node-&gt;right); temp.push_back(node-&gt;val); // 记录当前节点值 &#125; result.push_back(temp); // 当前层处理结束 &#125; return result; &#125;&#125;; Solve Problems Recursively 运用递归解决问题主要内容： 介绍两种典型的递归方法，练习使用基础的递归方法解决二叉树相关问题。 运用递归解决树的问题递归是树的特性之一，许多树的问题可以通过递归的方式来解决。 自顶向下的解决方案自顶向下可以认为是一种前序遍历，在每个递归层级，先访问节点进行计算，然后递归调用的时候将值传递到子节点。 原理如下： return specific value for null node update the answer if needed // anwer &lt;— params left_ans = top_down(root.left, left_params) // left_params &lt;— root.val, params right_ans = top_down(root.right, right_params) // right_params &lt;— root.val, params return the answer if needed // answer &lt;— left_ans, right_ans 例如，给定二叉树，寻找其最大深度。 用递归函数maximun_depth(root, depth)自顶向下解决该问题，每向下一层深度就加1，最终比较所有叶子节点处的最大深度即可，伪代码如下： return if root is null if root is a leaf node: ​ answer = max(answer, depth) // update the answer if needed maximum_depth(root.left, depth + 1) // call the function recursively for left child maximum_depth(root.right, depth + 1) // call the function recursively for right child 如图所示： 代码如下： 1234567891011int answer; // don't forget to initialize answer before call maximum_depthvoid maximum_depth(TreeNode* root, int depth) &#123; if (!root) &#123; return; &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; answer = max(answer, depth); &#125; maximum_depth(root-&gt;left, depth + 1); maximum_depth(root-&gt;right, depth + 1);&#125; 自底向上的解决方案自底向上可以看过是后序遍历的一种，在每个递归层次上，首先对所有子节点做递归调用，然后根据返回值和根节点本身的值得到最终答案。 原理如下： return specific value for null node left_ans = bottom_up(root.left) // call function recursively for left child right_ans = bottom_up(root.right) // call function recursively for right child return answers 同样以二叉树最大深度为例。 用递归函数maximun_depth(root)自底向上的解决该问题，对于树的某个节点，比较其左节点和右节点的最大深度，再加1即可，也就是对于每个节点，都可以在解决其子节点问题之后得到答案，伪代码如下： return 0 if root is null // return 0 for null node left_depth = maximum_depth(root.left) right_depth = maximum_depth(root.right) return max(left_depth, right_depth) + 1 // return depth of the subtree rooted at root 如图所示： 代码如下： 12345678int maximum_depth(TreeNode* root) &#123; if (!root) &#123; return 0; // return 0 for null node &#125; int left_depth = maximum_depth(root-&gt;left); int right_depth = maximum_depth(root-&gt;right); return max(left_depth, right_depth) + 1; // return depth of the subtree rooted at root&#125; 总结当遇到树问题时，请先思考一下两个问题： 你能确定一些参数，从该节点自身解决出发寻找答案吗？ 你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？ 如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。 或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。 练习：二叉树最大深度给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 代码如下（自底向上递归实现）： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root==NULL) return 0; if (root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return 1; int leftDepth = maxDepth(root-&gt;left); int rightDepth = maxDepth(root-&gt;right); if (leftDepth &gt; rightDepth) &#123; return leftDepth+1; &#125; else &#123; return rightDepth+1; &#125; &#125;&#125;; 练习：对称二叉树给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \2 2 \ \ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 官方给出的两种题解思路 递归方法 如果一个树的左右子树互为镜像，则这棵树是对称的。 当两棵树满足如下条件时，互为镜像： 两个根节点有相同的值； 每棵树的左子树都和另一棵树的右子树镜像对称； 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isMirror(TreeNode* t1, TreeNode* t2) &#123; if(t1 == NULL &amp;&amp; t2 == NULL) // 两个都空 return true; if(t1 == NULL || t2 == NULL) // 一个空，一个不空 return false; // 两个都不空 return (t1-&gt;val==t2-&gt;val) &amp;&amp; isMirror(t1-&gt;left,t2-&gt;right) &amp;&amp; isMirror(t1-&gt;right, t2-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; return isMirror(root, root); &#125;&#125;; 迭代方法 用队列进行迭代，队列中每两个相邻的值应该是相等的，且其子树也互为镜像。队列由两个连续的root节点开始。每次提取两个节点进行比较，然后把两个节点的左右子节点按相反顺序插入队列。队列为空，或检测到不对称时，算法结束。 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; // 队列以两个连续的root开始 q.push(root); q.push(root); while(!q.empty()) &#123; TreeNode* t1 = q.front(); q.pop(); TreeNode* t2 = q.front(); q.pop(); if(t1==NULL &amp;&amp; t2==NULL) continue; if(t1==NULL || t2==NULL) return false; if(t1-&gt;val != t2-&gt;val) return false; // 左右子节点按相反顺序插入队列 q.push(t1-&gt;left); q.push(t2-&gt;right); q.push(t1-&gt;right); q.push(t2-&gt;left); &#125; return true; &#125;&#125;; 练习：路径综合给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 代码如下： 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root==NULL) return false; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return root-&gt;val==sum; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; 总结多练习就对了，，， 练习：从中序与后序遍历序列构造二叉树 【LeetCode】106 根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 解题思路 中序遍历结果为左中右，后序遍历结果为左右中，题目假设树中没有重复元素，则可以先用后序遍历结果的尾值确定当前根节点P，在中序遍历中找到当前根节点P（假设位置为$n$），并将其分为左右两个子树（根节点P左侧为左孩子，右侧为右孩子，两个子树为$inorder[:n] , inorder[n+1:]$）。根据这个划分位置$n$，再将后序遍历序列也分隔成两部分（两部分为$postorder[:n] , postorder[n:-1]$），之后递归构造左右子树。 代码如下： 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int instart, int inend, int poststart, int postend) &#123; if(poststart &gt; postend) return NULL; // 后序遍历的尾值作为当前根节点 TreeNode* root = new TreeNode(postorder[postend]); // 在中序遍历中找到当前根节点的位置 int idx = instart; while(inorder[idx] != postorder[postend]) idx++; // 将中序遍历和后序遍历序列分别划分为两部分，并递归构造左右子树 root-&gt;left = build(inorder, postorder, instart, idx-1, poststart, poststart+idx-1-instart); root-&gt;right = build(inorder, postorder, idx+1, inend, poststart+idx-instart, postend-1); // 完全构造结束，返回根节点 return root; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return build(inorder, postorder, 0, inorder.size()-1, 0, postorder.size()-1); &#125;&#125;; 练习：从前序与中序遍历序列构造二叉树 【LeetCode】105 根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 解题思路 前序遍历结果为中左右，中序遍历结果为左中右，可以按照前面中序和后序构造二叉树的方法进行。 首先取前序遍历结果的首值作为当前根节点P，并在中序遍历结果中找到当前根节点P的位置$n$，并以此为依据，将中序遍历序列划分为左右两个子树$inorder[:n] , inorder[n+1:]$。同时根据这个位置$n$，再将前序遍历序列也划分为两部分$preorder[1:n+1] , preorder[n+1:]$。 代码如下： 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int prestart, int preend, int instart, int inend) &#123; if(prestart &gt; preend) return NULL; // 前序遍历首值作为当前根节点 TreeNode* root = new TreeNode(preorder[prestart]); // 在中序遍历序列中找到当前根节点位置 int idx = instart; while(inorder[idx] != preorder[prestart]) idx++; // 将前序遍历和中序遍历序列分别划分为两部分，并递归构造左右子树 root-&gt;left = build(preorder, inorder, prestart+1, prestart+idx-instart, instart, idx-1); root-&gt;right = build(preorder, inorder, prestart+idx-instart+1, preend, idx+1, inend); // 完全构造结束，返回根节点 return root; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return build(preorder, inorder, 0, preorder.size()-1, 0, inorder.size()-1); &#125;&#125;; 练习：填充每个节点的下一个右侧节点指针 【LeetCode】116 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例： 12345输入：&#123;"$id":"1","left":&#123;"$id":"2","left":&#123;"$id":"3","left":null,"next":null,"right":null,"val":4&#125;,"next":null,"right":&#123;"$id":"4","left":null,"next":null,"right":null,"val":5&#125;,"val":2&#125;,"next":null,"right":&#123;"$id":"5","left":&#123;"$id":"6","left":null,"next":null,"right":null,"val":6&#125;,"next":null,"right":&#123;"$id":"7","left":null,"next":null,"right":null,"val":7&#125;,"val":3&#125;,"val":1&#125;输出：&#123;"$id":"1","left":&#123;"$id":"2","left":&#123;"$id":"3","left":null,"next":&#123;"$id":"4","left":null,"next":&#123;"$id":"5","left":null,"next":&#123;"$id":"6","left":null,"next":null,"right":null,"val":7&#125;,"right":null,"val":6&#125;,"right":null,"val":5&#125;,"right":null,"val":4&#125;,"next":&#123;"$id":"7","left":&#123;"$ref":"5"&#125;,"next":null,"right":&#123;"$ref":"6"&#125;,"val":3&#125;,"right":&#123;"$ref":"4"&#125;,"val":2&#125;,"next":null,"right":&#123;"$ref":"7"&#125;,"val":1&#125;解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 解题思路 按照题意思路直接遍历即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/*// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node* next; Node() &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123;public: Node* dfs(Node* root) &#123; if(root == NULL || root-&gt;left == NULL) return root; // 题目说明左右子节点都存在，所以不用额外判断 root-&gt;left-&gt;next = root-&gt;right; // 直接连接 if(root-&gt;next) root-&gt;right-&gt;next = root-&gt;next-&gt;left; // 用来连接示例中5和6类型的节点，即root为左孩子的情况 //else // root-&gt;right-&gt;next = NULL; // 用来连接示例中7和NULL类型的节点，即root为右孩子的情况 // 递归 root-&gt;left = dfs(root-&gt;left); root-&gt;right = dfs(root-&gt;right); return root; &#125; Node* connect(Node* root) &#123; return dfs(root); &#125;&#125;; 练习：填充每个节点的下一个右侧节点指针 II 【LeetCode】117 给定一个二叉树 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例： 12345输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;输出：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 代码如下，详见注释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node* next; Node() &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123;public: Node* connect(Node* root) &#123; if(root == NULL || (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)) return root; // 保存原始根节点 Node* oriroot = root; // start用来连接两个层，start-&gt;next为下一层的首元素 // tmp用来遍历整个树，且tmp始终比root低一层 Node* start = new Node(0); Node* tmp = start; // tmp指向start while(root) &#123; // 如果根节点有左孩子，则tmp连接根节点的左孩子，并修改tmp到同层的下一个节点，对每一层的第一个元素，这个步骤完成了start与下层第一个元素的连接 if(root-&gt;left) &#123; tmp-&gt;next = root-&gt;left; tmp = tmp-&gt;next; &#125; // 如果根节点有右孩子，则tmp连接根节点的右孩子，修改tmp到同层下一个节点 if(root-&gt;right) &#123; tmp-&gt;next = root-&gt;right; tmp = tmp-&gt;next; &#125; // root向同层下一个节点移动 root = root-&gt;next; // 如果root不存在，则该层遍历结束，修改root为下一层的第一个节点，并修改start为NULL，tmp指向start（用来连接下一层） if(!root) &#123; root = start-&gt;next; start-&gt;next = NULL; tmp = start; &#125; &#125; return oriroot; &#125;&#125;; 小结：填充每个节点的下一个右侧节点指针问题1、调试环境 对于上述两道填充右侧节点指针的题目，LeetCode上没有给出调试环境，在网上看到有相关的内容，记录如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;sstream&gt;using namespace std;struct TreeLinkNode &#123; int val; TreeLinkNode *left, *right, *next; TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;&#125;;void trimLeftTrailingSpaces(string &amp;input) &#123; input.erase(input.begin(), find_if(input.begin(), input.end(), [](int ch) &#123; return !isspace(ch); &#125;));&#125;void trimRightTrailingSpaces(string &amp;input) &#123; input.erase(find_if(input.rbegin(), input.rend(), [](int ch) &#123; return !isspace(ch); &#125;).base(), input.end());&#125;TreeLinkNode* stringToTreeNode(string input) &#123; trimLeftTrailingSpaces(input); trimRightTrailingSpaces(input); input = input.substr(1, input.length() - 2); if (!input.size()) &#123; return nullptr; &#125; string item; stringstream ss; ss.str(input); getline(ss, item, ','); TreeLinkNode* root = new TreeLinkNode(stoi(item)); queue&lt;TreeLinkNode*&gt; nodeQueue; nodeQueue.push(root); while (true) &#123; TreeLinkNode* node = nodeQueue.front(); nodeQueue.pop(); if (!getline(ss, item, ',')) &#123; break; &#125; trimLeftTrailingSpaces(item); if (item != "null") &#123; int leftNumber = stoi(item); node-&gt;left = new TreeLinkNode(leftNumber); nodeQueue.push(node-&gt;left); &#125; if (!getline(ss, item, ',')) &#123; break; &#125; trimLeftTrailingSpaces(item); if (item != "null") &#123; int rightNumber = stoi(item); node-&gt;right = new TreeLinkNode(rightNumber); nodeQueue.push(node-&gt;right); &#125; &#125; return root;&#125;int main()&#123; TreeLinkNode * root; root = stringToTreeNode("&#123;2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7&#125;");&#125; 2、通用解法可以利用之前层序遍历的思路，维护一个树节点队列queue（先进先出），记录本层剩余的节点数和下一层的节点数。 上述两个问题均可用该方法解决。 具体过程： 初始将根节点插入到队列中，每次从队列中取一个节点； 判断该节点是否有左右子节点，若有则加入到队列中，并将下一层节点数加一； 从队列中弹出该节点，将本层剩余节点数减一； 若本层还有剩余节点，说明该节点有同层的兄弟节点，则将其next指针指向队首节点； 若剩余节点数为0，则说明本层遍历结束，将剩余节点数置为下一层的节点数，并将下一层的节点数置为0； 按照上述过程遍历，直至队列为空，则可完成树中所有next指针指向同层兄弟节点的操作。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node* next; Node() &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123;public: Node* connect(Node* root) &#123; if(!root) return root; queue&lt;Node*&gt; q; int nextLevel = 0, remain = 1; q.push(root); while(!q.empty()) &#123; // 取队首节点 Node* tmpNode = q.front(); // 将左右子节点插入队列，并修改下一层节点数 if(tmpNode-&gt;left) &#123; q.push(tmpNode-&gt;left); nextLevel++; &#125; if(tmpNode-&gt;right) &#123; q.push(tmpNode-&gt;right); nextLevel++; &#125; // 弹出队首节点，当前层剩余数减一 q.pop(); remain--; // 如果本层剩余数为0，则本层遍历结束，本层剩余节点数置为下一层节点数，下一层节点数归零 // 如果本层剩余数不为0，则将next指针指向队首节点，继续上述过程 if(remain) &#123; tmpNode-&gt;next = q.front(); &#125; else &#123; remain = nextLevel; nextLevel = 0; &#125; &#125; return root; &#125;&#125;; 练习：二叉树的最近公共祖先 【LeetCode】236 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 解题思路 按前序遍历的思路，从根节点开始遍历左右子树，直到找到第一个在左右子树中找到目标节点的节点。若该子树不包含目标节点，则返回NULL。 具体过程： 先判断当前节点是否是目标节点，是则返回该节点（空节点则返回NULL）； 递归在左右子树中查找最近公共祖先节点； 若在左右子树都找到目标节点，则说明目标节点刚好分布在当前节点的左右两侧，则返回当前节点； 若左右子树只有一侧找到目标节点，则返回找到的那个节点，对应题目中一个节点是其本身的祖先的情况；（有一侧返回NULL说明目标节点都在另一侧，题目明确目标节点都存在于树中，所以另一侧初次找到其中一个目标节点的地方就是最近公共祖先，另一个节点必然在该节点的子树中） 若两侧都未找到，则返回NULL； 代码如下： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 共同祖先只可能是该节点或该节点的祖先，所以找到p或q时递归可终止 if(root == NULL || root == p || root == q) return root; // 递归查找左右子树 TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); // 两侧都不空，说明p q刚好分布在root的左右两侧 if(left &amp;&amp; right) return root; // 哪侧不空，则说明在哪侧找到p、q节点，返回即可 return left == NULL ? right : left; &#125;&#125;; 练习：二叉树的序列化与反序列化 【LeetCode】297 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例: 123456789你可以将以下二叉树： 1 / \ 2 3 / \ 4 5序列化为 &quot;[1,2,3,null,null,4,5]&quot; 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 解题思路 按先序遍历的思路，将二叉树进行序列化，空节点用“#”保存（以确保节点插入到正确的位置）。为反序列化过程读取节点值方便，节点值之间用空格隔开。反序列化时，仍然按照先序遍历的思路即可。 序列化过程： 如果当前节点为空，则str += “# “； 递归进行先序遍历，并记录节点值； str += root-&gt;val + “ “ serialize(root-&gt;left, str) serialize(root-&gt;right, str) 反序列化过程： 读取字符串中一个节点值； 如果该值是数字，则以该值构建当前根节点 root = new TreeNode(val)； 递归构建左右子树； 如果该值不是数字，则 root = NULL，返回； 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123;public: void serialize(TreeNode* root, string&amp; str) &#123; if(!root) str += "# "; else &#123; ostringstream valstr; valstr &lt;&lt; root-&gt;val; str += valstr.str() + " "; serialize(root-&gt;left, str); serialize(root-&gt;right, str); &#125; &#125; void deserialize(TreeNode* &amp;root, string&amp; str) &#123; //if(str.length() == 0) // return; int val; string tmp = str.substr(0, str.find(" ")); str = str.substr(str.find(" ")+1); if(atoi(tmp.c_str()) || tmp.compare("0")==0) &#123; val = atoi(tmp.c_str()); root = new TreeNode(val); deserialize(root-&gt;left, str); deserialize(root-&gt;right, str); &#125; else &#123; root = NULL; return; &#125; &#125; // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string result = ""; serialize(root, result); return result; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; TreeNode* result = NULL; deserialize(result, data); return result; &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec codec;// codec.deserialize(codec.serialize(root)); 实际在LeetCode解题时，题目说明代码验证方式是codec.deserialize(codec.serialize(root));，只验证最后deserialize的返回值，并没有验证serialize的值（题目说序列化方法不限，所以也没法验证这个序列化结果的正确性的感觉），所以就意味着验证过程的返回值必然和输入值一样。 参考代码如下（Java）： 123456789101112131415&gt; public class Codec &#123;&gt; &gt; // Encodes a tree to a single string.&gt; TreeNode root;&gt; public String serialize(TreeNode root) &#123;&gt; this.root = root;&gt; return null;&gt; &#125;&gt; &gt; // Decodes your encoded data to tree.&gt; public TreeNode deserialize(String data) &#123;&gt; return root;&gt; &#125;&gt; &#125;&gt;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>Binary Tree</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】779、第k个语法符号]]></title>
    <url>%2F2019%2F03%2F26%2Fleetcode_779%2F</url>
    <content type="text"><![CDATA[21、K-th Symbol in Grammar第k个语法符号 难度：中等 题目描述 英文： On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). 中文： 在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。 给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始） 示例 Example: 1234567891011121314151617Input: N = 1, K = 1Output: 0Input: N = 2, K = 1Output: 0Input: N = 2, K = 2Output: 1Input: N = 4, K = 5Output: 1Explanation:row 1: 0row 2: 01row 3: 0110row 4: 01101001 注意 N 的范围 [1, 30]. K 的范围 [1, 2^(N-1)]. 解题思路思路一递归思路。 整个结构可以看做是一棵二叉树。 12345 0 / \ 0 1 /\ /\0 1 1 0 当一个节点是0的时候，两个子节点分别为0和1，当节点是1的时候，两个子节点分别为1和0。通过把K除以2，可以知道K的位置是左节点还是右节点。如果K是偶数，那么当前节点为右子节点，父节点是$N-1$行的第$K/2$个节点，如果K为奇数的话，则当前节点为左子节点。父节点是$N-1$行的第$(K+1)/2$个节点。 当前节点依赖于父节点，所以递归向前查找父节点，直至第一行结束。 代码提交 C++，用时4ms，内存8.1M 12345678910111213class Solution &#123;public: int kthGrammar(int N, int K) &#123; if (N==0) return 0; if (K%2 == 0) &#123; return kthGrammar(N-1, K/2)==0 ? 1:0; &#125; else &#123; return kthGrammar(N-1, (K+1)/2)==0 ? 0:1; &#125; &#125;&#125;; 进行Recursion探索时完成的，其他解法后续补充。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】21、合并两个有序链表]]></title>
    <url>%2F2019%2F03%2F26%2Fleetcode_21%2F</url>
    <content type="text"><![CDATA[21、Merge Two Sorted Lists合并两个有序链表 难度：简单 题目描述 英文： Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 中文： 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路思路一递归思路，比较头结点，保留较小值，再合并后续内容。 代码提交 C++，用时8ms，内存9M 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1==NULL) return l2; if (l2==NULL) return l1; if (l1-&gt;val&lt;l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 进行Recursion探索时完成的，其他解法后续补充。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】50、Pow(x,n)]]></title>
    <url>%2F2019%2F03%2F25%2Fleetcode_50%2F</url>
    <content type="text"><![CDATA[50、Pow(x,n)Pow(x,n) 难度：中等 题目描述 英文： Implement pow(x, n), which calculates x raised to the power n(xn). 中文： 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 Example 1: 12Input: 2.00000, 10Output: 1024.00000 Example 2: 12Input: 2.10000, 3Output: 9.26100 Example 3: 123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range $[-2^{31},2^{31}-1]$ 解题思路思路一递归思路，直接用for循环让x乘以自己n次会超时。用递归的思路，对计算过程进行二分计算。每次把n缩小一半，直至n缩小为0。任何数的0次方都为1，这是终止条件。如果n是偶数，返回值算个平方返回即可，如果n是奇数，则平方之后再乘以一次x。 需要注意的是，n可能为负数，如果n是负数的话，就先用绝对值计算，再对结果取倒数。 但按上述思路简单实现后，对于负2的31次方这个测试用例，由于绝对值超过整型最大值，所以溢出了。所以换一种写法，在每次递归中都处理n的正负，然后做相应的变换。 代码提交 C++，用时8ms，内存10M 12345678910class Solution &#123;public: double myPow(double x, int n) &#123; if (n == 0) return 1; double half = myPow(x, n / 2); if (n % 2 == 0) return half * half; if (n &gt; 0) return half * half * x; return half * half / x; &#125;&#125;; 进行Recursion探索时完成的，其他解法后续补充。 思路二用迭代的方法，将i初始化为n，看i是否是2的倍数，如果是，则x乘以自己即可，如果不是，则temp要再乘以x，i逐次减半，直到为0停止循环。最后看n的正负，并做相应处理。 代码提交 C++，用时8ms，内存10M 1234567891011class Solution &#123;public: double myPow(double x, int n) &#123; double res = 1.0; for (int i = n; i != 0; i /= 2) &#123; if (i % 2 != 0) res *= x; x *= x; &#125; return n &lt; 0 ? 1 / res : res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>数学</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】104、二叉树的最大深度]]></title>
    <url>%2F2019%2F03%2F25%2Fleetcode_104%2F</url>
    <content type="text"><![CDATA[104、Maximum Depth of Binary Tree二叉树的最大深度 难度：简单 题目描述 英文： Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. 中文： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例 Example： Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. 解题思路思路一递归思路，最大深度等于左节点和右节点最大深度的较大值加1。 C++，用时16ms，内存19M 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root==NULL) return 0; if (root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return 1; int leftDepth = maxDepth(root-&gt;left); int rightDepth = maxDepth(root-&gt;right); if (leftDepth &gt; rightDepth) &#123; return leftDepth+1; &#125; else &#123; return rightDepth+1; &#125; &#125;&#125;; 进行Recursion探索时完成的，其他解法后续补充。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】509、斐波那契数]]></title>
    <url>%2F2019%2F03%2F25%2Fleetcode_509%2F</url>
    <content type="text"><![CDATA[509、Fibonacci Number斐波那契数 难度：简单 题目描述 英文： The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0and 1. That is, 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), for N &gt; 1. Given N, calculate F(N). 中文： 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 给定 N，计算 F(N)。 示例 Example 1: 123Input: 2Output: 1Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: 123Input: 3Output: 2Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: 123Input: 4Output: 3Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. 提示 0 ≤ N ≤ 30 解题思路思路一使用递归方法。 代码提交 Python，用时20ms，内存11.8M 123456789101112131415161718192021class Solution(object): def fib(self, N): """ :type N: int :rtype: int """ cache = &#123;&#125; def recur_fib(N): if N in cache: return cache[N] if N &lt; 2: result = N else: result = recur_fib(N-1) + recur_fib(N-2) # put result in cache for later reference. cache[N] = result return result return recur_fib(N) 使用decorator模式做递归方法中的缓存计算。 Python，用时20ms，内存12.1M 123456789101112131415161718192021from functools import wrapsclass Solution(object): def cache(func): caches = &#123;&#125; @wraps(func) def wrap(*args): if args not in caches: caches[args] = func(*args) return caches[args] return wrap @cache def fib(self, n): """ :type N: int :rtype: int """ if n &lt; 2: return n return self.fib(n-1) + self.fib(n-2) 进行Recursion探索时完成的，其他解法后续补充。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——decorator]]></title>
    <url>%2F2019%2F03%2F25%2Fdecorator_python%2F</url>
    <content type="text"><![CDATA[后续补充]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>decorator</tag>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】206、反转链表]]></title>
    <url>%2F2019%2F03%2F22%2Fleetcode_206%2F</url>
    <content type="text"><![CDATA[206、Reverse Linked List反转链表 难度：简单 题目描述 英文： Reverse a singly linked list. 中文： 反转一个单链表。 示例 Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路递归解决方法的视频讲解Reverse a Linked List Recursively 思路一 参考讨论区的一种做法。 时间复杂度O(N)，空间复杂度O(1) 这里给出两种方法：迭代法（循环），递归方法。 两种方法的思路都是一样的。如下所示 …&lt;-x&lt;-x&lt;-x&lt;-x&lt;-pre || cur-&gt;y-&gt;y-&gt;y-&gt;y… 将整个链表分成两个部分；前半部分链表，后半部分链表 pre为已经 反转 好的部分链表的头节点； cur为当前仍然没有反转部分链表的头节点； 我们当前需要做的事情就是将cur节点加入到前半部分的链表中，直到右边的链表全部加入到左边的链表中即可。 用递归的思想理解4很容易。 代码提交递归方法 C++，用时8ms，内存9M 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverse(ListNode* pre, ListNode* cur) &#123; if (cur-&gt;next == NULL) &#123; // 递归结束的判断 cur-&gt;next = pre; return cur; &#125; ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; return reverse(pre, cur); &#125; ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL, *cur = head; return head ? reverse(pre, cur) : head; // 如果head为空的话，我们直接返回head/NULL &#125;&#125;; 迭代方法 C++，用时8ms，内存9.1M 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL) return NULL; ListNode* pre = NULL, *cur = head, *next = head-&gt;next; while (cur-&gt;next) &#123; cur-&gt;next = pre; pre = cur; cur = next; next = next-&gt;next; &#125; cur-&gt;next = pre; return cur; &#125;&#125;; 思路二参考LeetCode上递归探索页给出的解决方案。 递归版，是从后往前来转变链表指针的方向；迭代版是从前往后来转变链表的方向。 代码提交1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 递归版 public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null)&#123; return head; &#125; ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead; &#125; // 迭代版 public ListNode reverseList1(ListNode head) &#123; if (head != null)&#123; ListNode p1 = null; ListNode next = null; ListNode p2 = head; while (p2 != null)&#123; next = p2.next; p2.next = p1; p1 = p2; p2 = next; &#125; return p1; &#125;else &#123; return head; &#125; &#125; &#125; 思路三参考网上的解法，巧妙利用Python的多元赋值，实现非常简洁。 具体的执行过程可参考下面的举例说明： 前置条件：迭代指针：p = head、结果指针：res = none 以1-&gt;2-&gt;3-&gt;4-&gt;5为例： 过程： res:None 第一层循环 res:1-&gt;2-&gt;3-&gt;4-&gt;5 res = p res:1-&gt;None res.next = res p:2-&gt;3-&gt;4-&gt;5 p = p.next 第二层循环 res:2-&gt;3-&gt;4-&gt;5 res = p res:2-&gt;1-&gt;None res.next = res p:3-&gt;4-&gt;5 p = p.next 第三层循环 res:3-&gt;4-&gt;5 res = p res:3-&gt;2-&gt;1-&gt;None res.next = res p:4-&gt;5 p = p.next 第四层循环 res:4-&gt;5 res = p res:4-&gt;3-&gt;2-&gt;1-&gt;None res.next = res p:5 p = p.next 第五层循环 res:5 res = p res:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;None res.next = res p:None p = p.next end… 代码提交 Python，用时32ms，内存12.7M 1234567891011121314151617# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ L = ListNode(float("-inf")) while head: # 把当前 L.next （如 [2,1]）内容临时保存起来，然后把head此时剩下的内容（如 [3,4,5]）赋给L （变成[3,4,5]），再把之前保存的L.next接回来（L变成[3,2,1]），最后head后移一步 L.next, head.next, head = head, L.next, head.next return L.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>链表</tag>
        <tag>多元赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】119、杨辉三角2]]></title>
    <url>%2F2019%2F03%2F22%2Fleetcode_119%2F</url>
    <content type="text"><![CDATA[119、Pascal’s Triangle II杨辉三角2 难度：简单 题目描述 英文： Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle. Note that the row index starts from 0. 中文： 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例 Example: 12Input: 3Output: [1,3,3,1] 进阶 你可以优化你的算法到 O(k) 空间复杂度吗？ 解题思路思路一 进行Recursion探索时完成的，其他解法后续补充。 递归关系 我们从定义杨辉三角的递归关系开始。 首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下： f(i,j)=f(i-1,j-1)+f(i-1,j)基本情况 在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1. 所以，我们可以定义基本情况如下： f(i,j)=1\qquad where\qquad j=1\ or\ j=i 代码没有完全对应Recursion相应位置的方法，实现过程中，采用自底向上的方法，保存前一行的中间结果。 代码上注意一下，此处的rowIndex从0开始。 代码提交 C++，用时4ms，内存8.3M 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; temp; temp.push_back(1); if (rowIndex == 0) &#123; return temp; &#125; vector&lt;int&gt; result; for (int row = 1; row &lt;= rowIndex; row++) &#123; result.clear(); for (int col = 0; col &lt;= row; col++) &#123; if (col == 0 || col == row) &#123; result.push_back(1); &#125; else &#123; result.push_back(temp[col - 1] + temp[col]); &#125; &#125; temp = result; &#125; return result; &#125;&#125;; 思路二和思路一类似，先开辟一个大小为$k$的空间，保留每次前一行的中间结果，在其基础上直接修改获取当前行的结果。 修改过程中，先填充当前行的末尾值（比前一行最末的位置+1位），然后从右往左依次修改，当前行位置为$j$的值，仅依赖于上一行位置为$j-1$和$j$的值，所以，逆序修改的过程中，改掉的值都是下一步计算不再需要的值。 代码提交 C++，用时4ms，内存8.3M 12345678910111213class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex + 1); // 长度为K，默认值为0 res[0] = 1; for (int i = 1; i &lt;= rowIndex; ++i) &#123; // 从第1行开始（从0开始数）计算每一行的参数 for (int j = i; j &gt;= 1; --j) &#123; res[j] += res[j - 1]; // 更新j位置上的数为上一行的j-1位置与j位置的数的和，最末端为 0+上一行最末端 &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】118、杨辉三角]]></title>
    <url>%2F2019%2F03%2F22%2Fleetcode_118%2F</url>
    <content type="text"><![CDATA[118、Pascal’s Triangle杨辉三角 难度：简单 题目描述 英文： Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle. 中文： 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例 Example: 123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解题思路思路一 进行Recursion探索时完成的，其他解法后续补充。 递归关系 我们从定义杨辉三角的递归关系开始。 首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下： f(i,j)=f(i-1,j-1)+f(i-1,j)基本情况 在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1. 所以，我们可以定义基本情况如下： f(i,j)=1\qquad where\qquad j=1\ or\ j=i 代码没有完全对应Recursion相应位置的方法，实现过程中，采用自底向上的方法，保存计算过的中间结果，避免了重复计算。 代码提交 C++，用时4ms，内存8.8M 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (numRows &lt;= 0) return result; vector&lt;int&gt; temp; if (numRows == 1) &#123; temp.push_back(1); result.push_back(temp); return result; &#125; temp.push_back(1); result.push_back(temp); for (int row = 1; row &lt; numRows; row++) &#123; temp.clear(); for (int col = 0; col &lt;= row; col++) &#123; if (col == 0 || col == row) &#123; temp.push_back(1); &#125; else &#123; temp.push_back(result[row - 1][col - 1] + result[row - 1][col]); &#125; &#125; result.push_back(temp); &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】24、两两交换链表中的节点]]></title>
    <url>%2F2019%2F03%2F21%2Fleetcode_24%2F</url>
    <content type="text"><![CDATA[24、Swap Nodes in Pairs两两交换链表中的节点 难度：中等 题目描述 英文： Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. 中文： 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 解题思路思路一 进行Recursion探索时完成的，其他解法后续补充。 定义函数swap(head)，其中输入参数head表示链表的头结点。函数应该返回相邻节点交换后的新链表的头结点。 按如下步骤实现这个函数： 首先，我们交换链表的前两个节点，即head和head.next； 然后，我们递归调用函数swap(head.next.next)来处理链表的剩余部分； 最后，获得步骤2返回的子链表的头结点，并将其和步骤1的新链表相连接； 代码提交 C++，用时4ms，内存9M 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode *t = head-&gt;next; head-&gt;next = swapPairs(head-&gt;next-&gt;next); t-&gt;next = head; return t; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】344、反转字符串]]></title>
    <url>%2F2019%2F03%2F21%2Fleetcode_344%2F</url>
    <content type="text"><![CDATA[344、Reverse String反转字符串 难度：简单 题目描述 英文： Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters. 中文： 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 Example 1: 12Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] Example 2: 12Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 解题思路思路一递归思路，不使用额外空间，从首尾两端开始交换字符，并依次向内部缩小，直至交换到数组中间位置时结束。 用$s[x_i,…,x_j]$表示字符数组，其中$x_i , x_j$表示数组中的字符内容，$i,j$为对应的位置，则： s[x_i,...,x_j]= \begin{cases} s[x_i,...x_j], & \text{if $i>=j$}\\ s[x_j,...x_i], & \text{if $i]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】Explore：Recursion I 递归—1]]></title>
    <url>%2F2019%2F03%2F21%2Fleetcode_explore_recursion%2F</url>
    <content type="text"><![CDATA[主要翻译自LeetCode上Explore模块的Recursion I，有直译，也有非直译的个人理解。 其中涉及的题目附有相应的解答。 Overview 综述Recursion（递归）是计算机科学中一个重要的概念，是很多算法和数据结构的基础。但是对于很多初学者都比较难把握。 在开始本节探索之前，我们强烈建议先完成二叉树和堆栈两个探索页。 在这个探索页，我们将回答以下几个问题： 什么是recursion？它是如何工作的？ 如何递归的解决一个问题？ 如何分析递归算法的时间和空间复杂度（time and space complexity）？ 如何更好的应用递归？ 完成本探索页后，你在解决递归问题和分析复杂度时会变得更加自信。 一、Principle of Recursion 递归原理在这章，我们将会： 解释递归的基本概念； 演示如何应用递归解决确切的问题； 最后提供一些练习题来练习递归； 递归原理 递归是一种将函数本身作为子程序调用来解决问题的方法。 你可能想知道一个函数怎样调用其自身。诀窍在于每次递归的调用其本身时，都将给定的问题缩小成其子问题，这样持续的递归调用，直到子问题可以不用递归就能解决的时候停止。 一个递归函数应该有以下属性，这样才不会导致无限循环： 具有简单的基本情况，即递归出口、递归结束条件，即不使用递归即可获得答案的情况； 一系列规则，称为recurrence relation递归关系，可以将问题逐步缩小直至递归出口； 注意，可能会有多个可以调用函数本身的地方。 示例从一个简单的问题开始：逆序输出字符串。 倒序输出一个字符串。 你可以很容易的迭代解决这个问题，例如从字符串的结尾开始遍历字符串。但是如何递归的解决呢？ 首先，我们定义函数printReverse(str[0...n-1])，其中str[0]表示字符串的第一个字符，然后我们通过以下两个步骤解决这个问题： printReverse(str[1...n-1])：逆序输出子串strp[1...n-1]； print(str[0])：输出字符串的首字符； 我们在第一步中定义了递归关系。 代码如下（C++）： 123456void printReverse(const char *str) &#123; if (!*str) return; printReverse(str+1); cout &lt;&lt; *str;&#125; 接下来，来处理一个和示例略有不同的练习，尽量用递归来解决。 练习：反转字符串【LeetCode】344、Reverse String 写一个反转字符串的函数，输入字符数组char[]。 不要开辟额外的控件，必须使用$O(1)​$的空间复杂度就地修改输入的数组。 假定所有的字符都是可打印的ASCII码字符。 Example 1: 12Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] Example 2: 12Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 递归代码如下（自己写的，C++）： 1234567891011121314151617181920class Solution &#123;public: void swap(vector&lt;char&gt;&amp; s, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; char temp = s[left]; s[left] = s[right]; s[right] = temp; swap(s, left+1, right-1); return; &#125; void reverseString(vector&lt;char&gt;&amp; s) &#123; if (s.size() &lt;= 1) return; swap(s, 0, s.size()-1); return; &#125;&#125;; 解答：反转字符串本章，我们给出反转字符串问题的一个简单的解决方案。 问题并不难，关键在于有一个额外的约束条件，即使用$O(1)$的额外空间进行修改。 定义函数reverseString(str[0...n-1])，其中str[0...n-1]是一个首字符为str[0]的字符数组。 下面，我们讨论如何利用递归的思想来解决这个问题。 初次尝试如果我们按照上文逆序输出字符串的思路，我们可以有以下的方法： 从输入字符串中取首字符str[0]； 对于剩下的子字符串，调用函数自身来递归解决，如reverseString(str[1...n-1])； 在步骤2返回的结果中添加首字符； 这个方法可以实现题意效果，但是不满足约束条件。因为需要额外的空间来保存步骤2的中间结果，所需空间大小和字符串长度成正比（即需要$O(n)$的空间复杂度），这一点不满足$O(1)$空间复杂度的要求。 另一种分治的方法考虑题目中的约束条件，将其放入到递归的问题中，可以理解为在两次连续的递归调用之间不使用额外的空间消耗，也就是说，我们应该把问题分解成独立的子问题。 分解成独立子问题的一个思路是将每次输入的字符串分成两部分：1、首尾字符；2、去掉首位字符后剩下的子字符串。然后可以独立的解决两部分内容。 按照上述方法，可以有以下的方法： 从输入的字符串中取首尾字符str[0]和str[n-1]； 就地交换首尾字符； 递归调用函数来反转剩余的子字符串，即reverseString(str[1...n-2])； 注意：步骤2、3可以交换，因为是两个独立的任务。但最好保持现状的顺序，这样可以使用尾递归优化调用。我们会在后面的章节详细了解尾递归。（先简单理解一下，尾递归是指函数运行的最后一步是调用其自身，尾递归由于递归在最后一步，不再需要考虑外层函数的信息，因此可以把这个函数的调用栈给优化掉，从而避免栈溢出的风险。） 代码如下（示例代码，Python3）： 12345678910111213141516class Solution: def reverseString(self, s): """ :type s: List[str] :rtype: void Do not return anything, modify s in-place instead. """ def helper(start, end, ls): if start &gt;= end: return # swap the first and last element ls[start], ls[end] = ls[end], ls[start] return helper(start+1, end-1, ls) helper(0, len(s)-1, s) 如图，用字符数组[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]举例，可以看到如何进行分解并解决的。 使用这种方法，在每次递归调用的时候只需要常数级内存空间用来交换首尾字符即可，满足题目的约束条件。 递归函数对于一个问题而言，如果可以用递归的思路来解决的话，那我们一定可以遵循如下的思路来实现。 举例来说，我们用一个待实现的函数$F(X)$来表示问题，其中$X$表示函数的输入，也就是问题的范围。 那么，在函数$F (X)$中，我们将做如下操作： 把问题分解为更小的范围，如$x_0\in X , x_1\in X , … , x_n\in X$； 递归调用函数$F(x_0),F(x_1),…,F(x_n)$来解决$X$的子问题； 最后，处理递归调用的结果，从而解决$X$对应的问题； 举例通过递归解决另一个问题来展示上述思路。 给定一个链表，交换其中每两个相邻节点，并返回头结点。 例如：给定列表1-&gt;2-&gt;3-&gt;4，应该返回交换后的列表2-&gt;1-&gt;4-&gt;3的头结点。 定义函数swap(head)，其中输入参数head表示链表的头结点。函数应该返回相邻节点交换后的新链表的头结点。 按照上述思路，我们可以按如下步骤实现这个函数： 首先，我们交换链表的前两个节点，即head和head.next； 然后，我们递归调用函数swap(head.next.next)来处理链表的剩余部分； 最后，获得步骤2返回的子链表的头结点，并将其和步骤1的新链表相连接； 作为练习，可以按照上文提供的步骤试着实现该问题的完整代码。 练习：两两交换链表中的节点详见【LeetCode】24、Swap Nodes in Pairs Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 代码如下（C++，用时4ms，内存9M）： 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode *t = head-&gt;next; head-&gt;next = swapPairs(head-&gt;next-&gt;next); t-&gt;next = head; return t; &#125;&#125;; 二、Recurrence Relation 递归关系上一章我们了解了递归的基本概念。 在实现递归函数之前，有两个重要的点需要注意：基本情况和递归关系。 在这章，我们将： 通过详细的例子来了解如何定义基本情况和递归关系； 做一些练习； 递归关系在实现递归函数之前，要注意两个重要的点： 递归关系：总问题结果和子问题结果之间的关系； 基本情况：不需要继续递归调用就能够计算结果的情况，就是递归结束情况。（有时基本情况也被叫做bottom cases，因为如果我们用自顶向下的方式对问题进行分解的话，那么基本情况通常出现在问题已经被分解到最小范围的时候，即bottom） 一旦我们有了上述两方面内容，那么我们只需要按照递归关系不断的调用函数本身，直到到达基本情况。 为了解释上述内容，我们来看一个经典问题：杨辉三角（也叫 帕斯卡三角）。 杨辉三角是由一系列数字组成的三角形。其中，每一行的最左边和最右边永远是1，剩余的其他数字，每个数是其上面两个数的和。 示例：杨辉三角下图是一个五层的杨辉三角示意图： 基于以上定义，我们的问题就是生成指定层数的杨辉三角。 递归关系 我们从定义杨辉三角的递归关系开始。 首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下： f(i,j)=f(i-1,j-1)+f(i-1,j)基本情况 在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1. 所以，我们可以定义基本情况如下： f(i,j)=1\qquad where\qquad j=1\ or\ j=i示例 可以看到，一旦定义了递归关系和基本情况之后，就可以很直观的实现递归函数了，特别是定义好数学公式以后。 如下是应用上述公式计算$f(5,3)$，即第5行第3列的值的过程。 要计算$f(5,3)$，我们按照递归关系将问题分解$f(5,3)=f(4,2)+f(4,3)$，之后递归计算$f(4,2)$和$f(4,3)$的值： 对于$f(4,2)$，我们可以继续分解，直至基本情况，如下所示： f(4,2)=f(3,1)+f(3,2)=f(3,1)+(f(2,1)+f(2,2))=1+(1+1)=3 对于$f(4,3)$，同样的，我们可以将其分解如下： f(4,3)=f(3,2)+f(3,3)=(f(2,1)+f(2,2))+f(3,3)=(1+1)+1=3 最后我们组合上述子问题的结果： f(5,3)=f(4,2)+f(4,3)=3+3=6 下一步 在上面的示例中，可以注意到在递归解决方案中有一些重复的计算，就是说，我们为了计算最后一行的值，重复的计算了很多中间结果。例如，为了计算$f(5,3)$，我们在计算$f(4,2)$和$f(4,3)$的过程中重复计算了两边$f(3,2)$的值。 我们将在下一章讨论如何避免这些重复计算。 按照本章的内容，可以做一些和杨辉三角相关的练习题。 详见【LeetCode】118、杨辉三角，【LeetCode】119、杨辉三角2，【LeetCode】206、反转链表。 练习：杨辉三角Pascal’s Triangle Given a non-negative integer numRows, generate the first numRowsof Pascal’s triangle. 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 代码如下（C++，用时4ms，内存8.8M）： 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (numRows &lt;= 0) return result; vector&lt;int&gt; temp; if (numRows == 1) &#123; temp.push_back(1); result.push_back(temp); return result; &#125; temp.push_back(1); result.push_back(temp); for (int row = 1; row &lt; numRows; row++) &#123; temp.clear(); for (int col = 0; col &lt;= row; col++) &#123; if (col == 0 || col == row) &#123; temp.push_back(1); &#125; else &#123; temp.push_back(result[row - 1][col - 1] + result[row - 1][col]); &#125; &#125; result.push_back(temp); &#125; return result; &#125;&#125;; 练习：杨辉三角2Pascal’s Triangle II Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle. Note that the row index starts from 0. Example: 12Input: 3Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O(k) extra space? 代码如下（C++，用时4ms，内存8.3M）： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; temp; temp.push_back(1); if (rowIndex == 0) &#123; return temp; &#125; vector&lt;int&gt; result; for (int row = 1; row &lt;= rowIndex; row++) &#123; result.clear(); for (int col = 0; col &lt;= row; col++) &#123; if (col == 0 || col == row) &#123; result.push_back(1); &#125; else &#123; result.push_back(temp[col - 1] + temp[col]); &#125; &#125; temp = result; &#125; return result; &#125;&#125;; 练习：反转链表Reverse Linked List Reverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? 代码如下（C++，用时8ms，内存9M）： 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverse(ListNode* pre, ListNode* cur) &#123; if (cur-&gt;next == NULL) &#123; // 递归结束的判断 cur-&gt;next = pre; return cur; &#125; ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; return reverse(pre, cur); &#125; ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL, *cur = head; return head ? reverse(pre, cur) : head; // 如果head为空的话，我们直接返回head/NULL &#125;&#125;; 解答：反转链表方法1、迭代法假设有链表$1\rightarrow 2\rightarrow 3\rightarrow \emptyset$，要将其转为$\emptyset \leftarrow 1\leftarrow 2\leftarrow 3$。 遍历链表，将当前节点的next指针指向其前一个节点。由于链表没有指向前一个节点的指针，所以需要提前保存前一个节点的信息。同时还需要一个指针，在改变next指向时用来保存当前next的节点。最后不要忘了返回新的头结点。 1234567891011public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while (curr != null) &#123; ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; &#125; return prev;&#125; 复杂度分析 时间复杂度：$O (n)$。$n$是链表长度。 空间复杂度：$O (1)$。 方法2、递归法递归方法要考虑回退工作，略难一点。假设链表的剩余部分已经反转好了，怎么反转其前半部分呢？ 对于链表$n_1\rightarrow …\rightarrow n_{k-1} \rightarrow n_k \rightarrow n_{k+1} \rightarrow … \rightarrow n_m \rightarrow \emptyset​$，假设从节点$n_{k+1}​$到节点$n_m​$已经反转好了，并且当前在节点$n_k​$处：$n_1 \rightarrow … \rightarrow n_{k-1} \rightarrow \mathbf{n_k} \rightarrow n_{k+1} \leftarrow … \leftarrow n_m​$。 我们想让$n_{k+1}$的下一个节点指向$n_k$，所以：$n_k .next.next=n_k$。 要注意的是$n_1$节点的next必须指向$\emptyset​$。如果忽略这一步的话，那就把链表变成首尾相接的圆形的了。如果测试链表长度为2的情况，可能会触发这个bug。 1234567public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); // 保留头结点，递归反转剩余部分 head.next.next = head; // 把剩余部分的头结点指向到保留的头结点上，类似上文说的 n(k+1) 的next指向到 nk ，实现反转 head.next = null; // 把保留的头结点反转，指向空，即 n(k+1) 指向 nk 后，再将 nk 指向空 return p;&#125; 复杂度分析 时间复杂度：$O (n)$。$n$是链表长度。 空间复杂度：$O(n)$。额外的空间消耗来源于递归所需的隐藏的栈空间，递归最深为$n$层。 三、Memoization 缓存计算在上一章，我们提到过递归算法中的重复计算问题。在最好的情况下，重复计算只是会增加算法的时间复杂度，但是在最差的情况，重复计算会导致无限循环。 因此，在这章，我们将： 用一个例子开始，展示重复计算是如何导致的； 展示如何用缓存计算的技术来避免重复计算； 递归中的重复计算递归是实现算法的一种强有力的方法，但是如果不好好使用的话，也会带来额外的问题，如重复计算。例如，在上一章的后半部分，我们提到过杨辉三角中的重复计算问题，一些中间结果被反复计算了多次。 在这章，我们将进一步的讨论递归中可能发生的重复计算问题，并提出一种叫做缓存计算的常用技术手段来避免这个问题。 为了用另一个例子来演示重复计算问题，我们看一个大部分都熟悉的例子：斐波那契数列。如果我们定义函数$F(n)$来表示索引为$n$的斐波那契数，那可以得到如下所示的递归关系式： F(n)=F(n-1)+F(n-2)而基本情况（递归结束条件）为： F(0)=0\ ,\ F(1)=1有了斐波那契数的定义之后，可以按如下所示实现代码： 123456789def fibonacci(n): """ :type n: int :rtype: int """ if n &lt; 2: return n else: return fibonacci(n-1) + fibonacci(n-2) 现在，如果想计算$F(4)$，就可以按照上述公式来实现： F(4)=F(3)+F(2)=(F(2)+F(1))+F(2)可以看到，按照上述过程，为了计算$F(4)$的结果，我们需要计算两遍$F(2)$。 如图所示，用一棵树展示了在计算$F(4)​$的过程中进行的所有重复计算（用颜色分类）： 缓存计算为了尽可能多的消除上述情况中的重复计算，一个方法就是将中间结果保存在缓存中，这样下次遇到的时候就可以重复使用而不需要再次计算了。 这个方法就是缓存计算方法，是经常和递归一起使用的一种技术。 Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. (Source: wikipedia) 缓存计算是通过将高消耗的函数调用结果进行保存，并且在再次遇到相同输入的时候返回缓存结果，从而提升程序运行速度的一种优化技术。 回到斐波那契函数$F(n)$，我们可以用一个哈希表来跟踪每个$F(n)$的值，用$n$做key。哈希表作为缓存使我们避免重复计算。缓存技术是一个很好的用一些额外空间来换取时间减少的例子。 为了对比，我们提供了如下的用缓存计算实现的斐波那契数。 作为练习，可以通过更一般性的方法来实现缓存计算，即不改变原来的函数而应用缓存计算。（可以引用设计模式decorator） 关于decorator设计模式可参考设计模式——decorator 1234567891011121314151617181920def fib(self, N): """ :type N: int :rtype: int """ cache = &#123;&#125; def recur_fib(N): if N in cache: return cache[N] if N &lt; 2: result = N else: result = recur_fib(N-1) + recur_fib(N-2) # put result in cache for later reference. cache[N] = result return result return recur_fib(N) 使用decorator模式代码如下（自己实现）： 123456789101112131415161718192021from functools import wrapsclass Solution(object): def cache(func): caches = &#123;&#125; @wraps(func) def wrap(*args): if args not in caches: caches[args] = func(*args) return caches[args] return wrap @cache def fib(self, n): """ :type N: int :rtype: int """ if n &lt; 2: return n return self.fib(n-1) + self.fib(n-2) 在这章中，可以通过斐波那契数和爬楼梯问题来进行练习。 详见：【LeetCode】509、斐波那契数，【LeetCode】70、爬楼梯 在下一章，我们将深入讨论在递归算法中的复杂度分析。 练习：斐波那契数The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), for N &gt; 1. Given N, calculate F(N). Example 1: 123Input: 2Output: 1Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: 123Input: 3Output: 2Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: 123Input: 4Output: 3Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Note: 0 ≤ N ≤ 30. 代码如下（Python，用时20ms，内存11.8M）： 123456789101112131415161718192021class Solution(object): def fib(self, N): """ :type N: int :rtype: int """ cache = &#123;&#125; def recur_fib(N): if N in cache: return cache[N] if N &lt; 2: result = N else: result = recur_fib(N-1) + recur_fib(N-2) # put result in cache for later reference. cache[N] = result return result return recur_fib(N) 练习：爬楼梯You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: 12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2: 123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 代码如下（Python3，用时80ms，内存13.2M）： 12345678910class Solution: def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 if n == 2: return 2 tempNum = [0,1,2] for i in range(3, n+1): tempNum.append(tempNum[i-1] + tempNum[i-2]) return tempNum[n] 解答：爬楼梯 本节代码均为原网页给出的参考代码，均为Java实现。 方法1：暴力法暴力法就是计算所有可能的走法组合，也就是每一步爬1层和每一步爬两层。在每一步我们都调用函数$climpStairs$来计算爬一层和爬两层的结果，并返回两个函数返回值的和。 climbStairs(i,n)=climbStairs(i+1,n)+climbStairs(i+2,n)其中$i$表示当前层数，$n$表示目标层数。 代码如下： 1234567891011121314public class Solution &#123; public int climbStairs(int n) &#123; climb_Stairs(0, n); &#125; public int climb_Stairs(int i, int n) &#123; if (i &gt; n) &#123; return 0; &#125; if (i == n) &#123; return 1; &#125; return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n); &#125;&#125; 复杂度分析 时间复杂度：$O(2^n)$。递归树的大小是$2^n$。 如下所示为$n=5$时的递归树： 空间复杂度：$O(n)$。递归树的最大深度为$n$。 方法2：采用缓存计算的递归法在上一种方法中重复计算了很多中间结果。可以用一个memo数组将每一步的结果进行存储，当再次调用这个函数的时候可以直接从memo数组中返回结果。 通过这种使用memo数组来调整递归树的方法，可以将递归树的大小减少到$n$。 代码如下： 12345678910111213141516171819public class Solution &#123; public int climbStairs(int n) &#123; int memo[] = new int[n + 1]; return climb_Stairs(0, n, memo); &#125; public int climb_Stairs(int i, int n, int memo[]) &#123; if (i &gt; n) &#123; return 0; &#125; if (i == n) &#123; return 1; &#125; if (memo[i] &gt; 0) &#123; return memo[i]; &#125; memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo); return memo[i]; &#125;&#125; 复杂度分析 时间复杂度：$O(n)$。递归树的大小为$n$。 空间复杂度：$O(n)$。递归树的最大深度为$n$。 方法3：动态规划可以看到，这个问题可以分解成多个子问题，并且包含最优子结构性质，也就是说，这个问题的最优解可以通过其子问题的最优解来组合得到，所以我们可以采用动态规划方法来解决这个问题。 我们可以通过以下两种方法到达第$i$层： 在第$i-1$层走一步； 在第$i-2$层走两步； 所以，到达第$i$层的总方法数等于到达第$i-1$层的方法数和到达第$i-2$层的方法数的总和。 用$dp[i]$表示到达第$i$层所需的总方法数，则： dp[i]=dp[i-1]+dp[i-2]例如： 代码如下： 1234567891011121314public class Solution &#123; public int climbStairs(int n) &#123; if (n == 1) &#123; return 1; &#125; int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125; 复杂度分析 时间复杂度：$O(n)$。单层循环到$n$。 空间复杂度：$O(n)$。使用大小为$n$的$dp$数组。 方法4：斐波那契数法在上面的方法中使用了$dp$数组，并且$dp[i]=dp[i-1]+dp[i-2]$。可以很容易的联想到，$dp[i]$正是斐波那契数的第$i$个值： Fib(n)=Fib(n-1)+Fib(n-2)那么，我们只需要找到斐波那契数列的第$n$个值即可，其中前两个值分别为1和2，即$Fib(1)=1$，$Fib(2)=2$。 代码如下： 123456789101112131415public class Solution &#123; public int climbStairs(int n) &#123; if (n == 1) &#123; return 1; &#125; int first = 1; int second = 2; for (int i = 3; i &lt;= n; i++) &#123; int third = first + second; first = second; second = third; &#125; return second; &#125;&#125; 复杂度分析 时间复杂度：$O(n)$。计算第$n$个斐波那契数需要循环到$n$。 空间复杂度：$O(1)$。使用固定的空间。 方法5：Binets Method （比奈法？）使用矩阵的方法这是一个非常有趣的使用矩阵乘法来计算第$n$个斐波那契数的方法。矩阵形式如下： \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n-1} \end{bmatrix} = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}令$Q= \begin{bmatrix}F_{n+1} &amp; F_n \\ F_n &amp; F_{n-1} \end{bmatrix}​$。按照这个方法，第$n​$个斐波那契数可以由$Q^{n-1}[0,0]​$得到。 我们来看方法的证明： 可以使用数学归纳法来证明这个方法。我们知道，这个矩阵给出了第3个斐波那契数（基本情况）的正确结果，$Q^2= \begin{bmatrix}2 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}​$。这证明了基本情况是适用于这个方法的。 假设这个方法也适用于第$n$个斐波那契数的问题，即$F_n = Q^{n-1}[0,0]$，其中$Q^{n-1}= \begin{bmatrix} F_n &amp; F_{n-1} \\ F_{n-1} &amp; F_{n-2} \end{bmatrix}$。 现在，我们需要证明在上述两个条件为真的情况下，这个方法对于计算第$n+1​$个斐波那契数也是有效的，即证明$F_{n+1}=Q^n[0,0]​$。 证明过程： Q^n= \begin{bmatrix} F_{n} & F_{n-1} \\ F_{n-1} & F_{n-2} \end{bmatrix} \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix} = \begin{bmatrix} F_n+F_{n-1} & F_n \\ F_{n-1}+F_{n-2} & F_{n-1} \end{bmatrix} = \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n-1} \end{bmatrix}所以，$F_{n+1}=Q^n[0,0]$。 至此，完成了这个方法的证明。 用这个方法解决爬楼梯问题所要做的唯一的改动就是，修改初始值为2和1（斐波那契数列的初始值是1和0）。或者，另一个方法是不修改初始值，而是使用相同的矩阵，但是用结果$result=Q^n[0,0]$来得到爬楼梯问题的第$n$层最终解。做这种调整的原因是因为爬楼梯问题使用的是斐波那契数列列的第2、3项做基本情况。 代码如下： 123456789101112131415161718192021222324252627 public class Solution &#123; public int climbStairs(int n) &#123; int[][] q = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; int[][] res = pow(q, n); return res[0][0]; &#125; public int[][] pow(int[][] a, int n) &#123; int[][] ret = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) &#123; ret = multiply(ret, a); &#125; n &gt;&gt;= 1; a = multiply(a, a); &#125; return ret; &#125; public int[][] multiply(int[][] a, int[][] b) &#123; int[][] c = new int[2][2]; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; &#125; &#125; return c; &#125;&#125; 复杂度分析 时间复杂度：$O(\log(n))$。 空间复杂度：$O(1)$。使用固定的空间。 时间复杂度证明： 假设有一个$n$次幂的矩阵$M$，假设$n$是2的幂，那么$n=2^i , i \in \mathbb{N} $，其中$\mathbb {N}$表示自然数集合（包括0）。我们可以用如下形式的树来表示： 图中内容表示：$M^n=M^{n/2}=…=\prod_1^n{M^1}​$。 所以，为了计算矩阵$M^n$，我们需要计算$M^{n/2}$并且和自己相乘。为了计算$M^{n/2}$需要计算$M^{n/4}$，等等等等。 显然，树的高度为$\log_2{n}$。 下面来估计$M^n$的计算时间。矩阵$M$在任意次幂的大小都一样，所以我们可以在$O(1)$的时间内计算任意次幂的两个矩阵相乘。这样的计算需要执行$\log_2{n}$次。所以$M^n$的计算复杂度为$O(\log_2{n})$。 如果$n$不是2的幂，那么我们可以通过其二进制表示将其分解为用2的次幂表示： n=\sum_{p\in{P}}2^p\ ,\ \text{where}\ P\subset\mathbb{N}这样我们可以通过如下公式来得到最终结果： M^n=\prod_{p\in P}M^{2^p}这就是在实现中使用的方法？由于乘法的计算次数已经限制在$O(\log_2n)​$，所以总的复杂度就是$O(\log_2n)​$。 方法6、斐波那契公式 没太仔细理解这个方法。。。 我们可以用如下公式计算得到第$n$个斐波那契数： F_n=\cfrac{1}{\sqrt{5}}\left[\left(\cfrac{1+\sqrt5}{2}\right)^n-\left(\cfrac{1-\sqrt5}{2}\right)^n\right]对于给定的问题，斐波那契数列定义为：$F_0=1,F_1=1,F_2=2,F_{n+2}=F_{n+1}+F_n$。解决这种递归公式的一种标准方法是假设$F_n$的形式为$F_n=a^n$。这样的话，显然$F_{n+1}=a^{n+1}$并且$F_{n+2}=a^{n+2}$，所以等式就变为$a^{n+2}=a^{n+1}+a^n$。如果我们将整个等式除以$a^n$，就得到$a^2=a+1$，也就是二次方程$a^2-a-1=0$。 对这个二次方程求解，可以得到： a=1/\sqrt5\left(\left( \cfrac{1\pm \sqrt5}{2} \right)\right)对于一般情况，可以得到等式： F_n=A\left( \cfrac{1+\sqrt 5}{2} \right)^n+B\left( \cfrac{1-\sqrt 5}{2} \right)^n对于$n=0$的情况，有$A+B=1$， 对于$n=1$的情况，有$A\left( \cfrac{1+\sqrt 5}{2} \right)+B\left( \cfrac{1-\sqrt 5}{2} \right)=1$， 对上述等式求解，可以得到： A=\left( \cfrac{1+\sqrt 5}{2\sqrt 5} \right)\ ,\ B=\left( \cfrac{1-\sqrt 5}{2\sqrt 5} \right)将$A$和$B$的值代入到上述的通用等式中，可以得到： F_n=\cfrac{1}{\sqrt{5}}\left[\left(\cfrac{1+\sqrt5}{2}\right)^{n+1}-\left(\cfrac{1-\sqrt5}{2}\right)^{n+1}\right]代码如下： 1234567public class Solution &#123; public int climbStairs(int n) &#123; double sqrt5=Math.sqrt(5); double fibn=Math.pow((1+sqrt5)/2,n+1)-Math.pow((1-sqrt5)/2,n+1); return (int)(fibn/sqrt5); &#125;&#125; 复杂度分析 时间复杂度：$O(\log(n))$。$pow$计算需要$\log(n)$的时间。 空间复杂度：$O(1)​$。使用固定空间。 四、Complexity Analysis 复杂度分析在这一章，我们将讨论如何计算递归算法中的时间和空间复杂度。 特别的是，本章将展示一个非常有用的叫做尾递归的技术，可以用来优化递归问题中的空间复杂度，更重要的是可以避免栈溢出的问题。 时间复杂度——递归这一部分，我们主要讨论如何计算递归问题中的时间复杂度。 给定一个递归问题，其时间复杂度$O(T)$主要是由递归调用的次数（用$R$表示）和每次递归中所需的计算时间（用$O(s)$表示）共同决定的： O(T)=R*O(s) 来看一些例子。 举例在反转字符串问题中，我们需要将一个字符串逆序输出。解决这个问题的一个递归关系可以表示如下： printReverse(str)=printReverse(str[1...n])+print(str[0])其中$str[1…n]$是输入字符串$str$的子串，$str[0]$是首字符。 可以看到，函数递归调用$n$次，$n$是输入字符串的长度。在每一次递归中，只是简单的输出首字符，所以该操作的时间复杂度是常数级，即$O(1)$。 所以，递归函数$printReverse(str)$的总时间复杂度就是$O(printReverse)=n*O(1)=O(n)$。 执行树对于递归函数，调用次数刚好和输入成线性关系的情况是很少见的。例如，在上一章讨论过的斐波那契数列问题，递归函数定义为$f(n)=f(n-1)+f(n-2)$。乍一看，斐波那契函数的调用次数并不能够很直观的得到。 在这种情况，最好是采用execution tree 执行树的方式，这种树是用来详细表示递归函数执行过程的。树上的每个节点表示递归函数的一次调用，所以总的节点数就是整个执行过程中递归调用的总次数了。 执行树用一个$n$叉树来表示，其中$n$表示递归关系中出现递归调用的次数。例如，斐波那契数列问题的执行树是一颗二叉树，下图表示了计算斐波那契数$f(4)$的执行树： 对于一个$n$层的二叉树，其节点总数是$2^n-1$。所以，$f(n)$递归调用次数的上限（虽然不是很严格）就是$2^n-1$。所以，可以得到斐波那契数列问题$f(n)$的时间复杂度是$O(2^n)$。 缓存计算在上一章，讨论过递归算法中用于优化时间复杂度的方法——缓存计算。通过将中间结果进行缓存和重复使用，缓存计算可以大幅减少递归调用的次数，也就是减少执行树的分支数。所以应该考虑到使用缓存计算的递归算法时间复杂度。 回到斐波那契数列问题，使用缓存计算的话，可以将每个斐波那契数的结果进行保存。保证对每个斐波那契数的计算只执行一次。由递归关系可以知道，对于斐波那契数$f(n)$，依赖于前$n-1$个斐波那契数，所以，$f(n)$的递归计算过程将会调用$n-1$次，来计算其所依赖的所以前序数值。 现在可以直接使用本章开始时候给出的公式来计算时间复杂度，即$O(1)*n=O(n)$。缓存计算不仅优化了算法的时间复杂度，也简化了时间复杂度的分析过程。 接下来，我们讨论如何分析递归算法的空间复杂度。 空间复杂度——递归这一部分，将讨论如何分析递归算法中的空间复杂度。 当讨论递归算法的空间复杂度时，应该考虑两部分的空间消耗：递归相关的空间和非递归相关的空间。 递归相关的空间递归相关的空间指的是由递归调用所直接产生内存消耗，即保存递归函数调用所需的栈空间。为了完成一个典型的递归调用，系统需要分配一些空间来保存三部分重要的信息： 函数的返回地址：一旦函数调用完成，程序应该知道返回到哪里，即函数调用之前的位置； 函数传递的参数； 函数的局部变量； 这个栈空间是函数调用过程中所产生的最小开销，一旦函数执行结束，空间就会被释放。 对于递归算法，函数调用会链式累积，直到到达基本情况。这意味着每个函数调用所需的空间也会累积。 对于递归算法，如果没有其他内存消耗，那么这个由递归行为本身所引起的空间消耗将会是整个算法的空间上限。 例如，在逆序输出字符串的练习中，由于只是单纯的输出字符，所以在递归调用本身之外没有额外的空间消耗。对于每一个递归调用，我们假设需要一个常数级的空间。递归调用将持续$n$次，$n$是输入字符串的长度。所以这个递归算法的空间复杂度是$O(n)$。 为了说明这一点，以递归调用$f(x_1)\rightarrow f(x_2)\rightarrow f(x_3)$为例，展示了执行步骤的顺序和堆栈布局。 为了调用$f(x_2)$，会给$f(x_1)$分配一个栈空间。同理，在$f(x_2)$中也会为了调用$f(x_3)$而分配另一个栈空间。最终在$f(x_3)$中，程序到达基本情况，因此没有在$f(x_3)$中进一步递归。 由于这些递归相关的空间消耗，有时会导致栈溢出的情况，就是分配给一个程序的栈空间超出了其最大空间限制，导致程序失败。因此，当设计递归算法时，要仔细考虑当输入规模比较大的时候是否可能导致栈溢出。 非递归相关的空间如标题所示，非递归相关的空间主要是指和递归没有直接关系的内存空间，通常包括分配给全局变量的空间（通常为堆）。 不论是否递归，在任何后续函数调用前都需要将问题的输入作为全局变量保存。同时还需要存储递归调用的中间结果。后者就是我们在前面章节讨论过缓存计算。例如，对于使用缓存计算实现的计算斐波那契数列的递归算法，我们使用一个map来记录递归调用过程中出现的所有斐波那契数。因此，在分析空间复杂度的时候，我们应该考虑到缓存计算的空间成本。 尾递归在之前的页面，讨论过递归调用过程中系统分配栈空间所产生的隐藏空间开销。但是，我们应该学会识别一种递归的特殊情况——尾递归，尾递归避免了这部分空间开销。 尾递归是指在递归函数执行的最后命令是递归调用，并且应该只有一个递归调用。 在反转字符串的问题中我们已经看到了一个尾递归的例子。这里用另一个例子展示非尾递归和尾递归的区别。注意，非尾递归的例子在最后一个递归调用之后有一个额外的计算步骤。 123456789101112131415161718192021222324def sum_non_tail_recursion(ls): """ :type ls: List[int] :rtype: int, the sum of the input list. """ if len(ls) == 0: return 0 # not a tail recursion because it does some computation after the recursive call returned. return ls[0] + sum_non_tail_recursion(ls[1:])def sum_tail_recursion(ls): """ :type ls: List[int] :rtype: int, the sum of the input list. """ def helper(ls, acc): if len(ls) == 0: return acc # this is a tail recursion because the final instruction is a recursive call. return helper(ls[1:], ls[0] + acc) return helper(ls, 0) 尾递归的好处是可以避免递归调用过程中的堆栈开销累积，因为系统在每次递归调用的时候可以重复利用一部分栈空间。 以递归调用$f(x_1)\rightarrow f(x_2)\rightarrow f(x_3)$为例，其中函数$f(x)$是使用尾递归实现的，如下展示了执行步骤的顺序和堆栈布局。 注意在尾递归中，一旦递归调用结束，我们就会理解知道返回值，所以图中跳过了递归返回的完整链路，直接返回到原始调用的地方。这意味着，我们不再需要对所有递归调用都分配栈，从而节省了空间。 例如，在步骤1中，为了调用$f(x_2)$而在$f(x_1)$中分配了栈空间。在步骤2中，$f(x_2)$会递归调用$f(x_3)$，但是系统可以直接重复使用之前为第二次递归调用分配的空间，而不是分配新的空间。最终，在函数$f(x_3)$中，我们到达了基本情况，函数可以直接返回到原始调用的地方，而不需要逐步返回到上一个调用的函数。 尾递归函数可以当做非尾递归函数执行，也就是调用成堆的栈，而不影响结果。通常，编译器会识别尾递归并优化执行过程。但是，并不是所有语言都支持这种优化。例如，C、C++支持尾递归优化，而Java和Python不支持尾递归优化。 练习：二叉树的最大深度详见【LeetCode】104、二叉树的最大深度 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. 代码如下： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root==NULL) return 0; if (root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return 1; int leftDepth = maxDepth(root-&gt;left); int rightDepth = maxDepth(root-&gt;right); if (leftDepth &gt; rightDepth) &#123; return leftDepth+1; &#125; else &#123; return rightDepth+1; &#125; &#125;&#125;; 解答：二叉树的最大深度要花钱才能解锁，没有看:joy:。 练习：Pow(x, n)详见【LeetCode】50、Pow(x,n) Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: 12Input: 2.00000, 10Output: 1024.00000 Example 2: 12Input: 2.10000, 3Output: 9.26100 Example 3: 123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range $[-2^{31},2^{31}-1]​$ 代码如下： 12345678910class Solution &#123;public: double myPow(double x, int n) &#123; if (n == 0) return 1; double half = myPow(x, n / 2); if (n % 2 == 0) return half * half; if (n &gt; 0) return half * half * x; return half * half / x; &#125;&#125;; 解答：Pow(x, n)要花钱才能解锁，没有看:joy:。 五、Conclusion 总结在之前的章节，我们了解了递归的概念的原则。 作为提醒，以下是解决递归问题的共用工作流程： 定义递归函数； 总结递归关系和基本情况； 如果有重复计算问题的话，使用缓存计算来消除； 如果可能，使用尾递归来优化空间复杂度； 在本章，将对递归算法做一些总结，并且提供一些在利用递归解决问题的过程中可能用到的tips。 总结——递归-1现在，我们了解到递归确实是一个可以用来解决很多问题的有效方法。但是，由于时间和空间的限制，并不是所有问题都能用递归解决。递归可能会有一些负面效果，如栈溢出问题。 在这章，将分享一些可以更好的利用递归来解决实际问题的tips： 疑惑的时候，把递归关系写下来。 有时，乍一看，问题能够用递归算法解决并不明显。但是，由于递归算法和我们所熟悉的数学非常接近，所以利用数学公式推导出一些关系式总是有帮助的。通常，可以帮助澄清问题概念并揭示隐藏的递归关系。在本章后面，可以通过一个例子（Unique Binary Search Trees II）来了解在数学公式的辅助下利用递归方法解决问题。 如果可能，使用缓存计算。 在起草递归算法的时候，可以从最简单的策略开始。有时，在递归过程中会存在重复计算，如斐波那契数问题。在这种情况下，应该尝试使用缓存计算技术，将中间结果缓存以后后续重复使用。缓存计算利用空间上的一些折中来换取时间复杂度的大幅提升。 当出现栈溢出问题时，尾递归可能会有帮助。 使用递归算法通常有几种不同的实现。尾递归是其中一个特定的实现形式。和缓存计算不同，尾递归可以通过消除递归算法带来的堆栈开销来优化算法的空间复杂度。更重要的是，使用尾递归可以避免递归算法常出现的栈溢出问题。尾递归的另一个优点是比非尾递归更容易阅读和理解。因为和非尾递归不同，尾递归中不存在递归后调用的问题（即递归操作是函数的最后操作）。所以，只要可能，应该尽量使用尾递归。 后续现在，利用目前为止所了解到的递归知识，可以在LeetCode上解决更多问题。在本章中，还提供了几个练习。 练习：合并两个有序链表详见【LeetCode】21、合并两个有序链表 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 代码如下： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1==NULL) return l2; if (l2==NULL) return l1; if (l1-&gt;val&lt;l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 解答：合并两个有序链表要花钱才能解锁，没有看:joy:。 练习：第k个语法符号详见【LeetCode】779、第k个语法符号 On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). 123456789101112131415161718Examples:Input: N = 1, K = 1Output: 0Input: N = 2, K = 1Output: 0Input: N = 2, K = 2Output: 1Input: N = 4, K = 5Output: 1Explanation:row 1: 0row 2: 01row 3: 0110row 4: 01101001 Note: N will be an integer in the range [1, 30]. K will be an integer in the range [1, 2^(N-1)]. 代码如下： 12345678910111213class Solution &#123;public: int kthGrammar(int N, int K) &#123; if (N==0) return 0; if (K%2 == 0) &#123; return kthGrammar(N-1, K/2)==0 ? 1:0; &#125; else &#123; return kthGrammar(N-1, (K+1)/2)==0 ? 0:1; &#125; &#125;&#125;; 解答：第k个语法符号要花钱才能解锁，没有看:joy:。 练习：不同的二叉搜索树IIGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&apos;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 等复习了二叉树再后续补充，，， 解答：不同的二叉搜索树II要花钱才能解锁，没有看:joy:。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中list的一些小技巧]]></title>
    <url>%2F2019%2F03%2F20%2Fpython_list_tips%2F</url>
    <content type="text"><![CDATA[列表展开 12345678910111213141516171819202122232425262728import itertools################ case 1a = [[1, 2], [3, 4], [5, 6]]print list(itertools.chain.from_iterable(a))%timeit -n 10000 list(itertools.chain.from_iterable(a))print sum(a, [])%timeit -n 10000 sum(a, [])print [x for l in a for x in l]%timeit -n 10000 [x for l in a for x in l]# result:# [1, 2, 3, 4, 5, 6]# 10000 loops, best of 3: 801 ns per loop# [1, 2, 3, 4, 5, 6]# 10000 loops, best of 3: 359 ns per loop# [1, 2, 3, 4, 5, 6]# 10000 loops, best of 3: 371 ns per loop################ case 2b = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]][x for l1 in b for l2 in l1 for x in l2]# [1, 2, 3, 4, 5, 6, 7, 8]################ case 3a = [1, 2, [3, 4], [[5, 6], [7, 8]]]flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]flatten(a)# [1, 2, 3, 4, 5, 6, 7, 8] 相邻元素压缩&amp;依次相连12345678910111213# python3a = [1, 2, 3, 4, 5, 6]list(zip(*([iter(a)] * 2)))# [(1, 2), (3, 4), (5, 6)]list(zip(*([iter(a)] * 3)))# [(1, 2, 3), (4, 5, 6)]temp = ['a', 'b', 'c', 'd', 'e','f']list(zip(temp[:-1],temp[1:]))# [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')]list(zip(temp[:-2],temp[1:-1],temp[2:]))# [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中zip的一些内容]]></title>
    <url>%2F2019%2F03%2F19%2Fpython_zip%2F</url>
    <content type="text"><![CDATA[1、zip基本说明zip函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，返回由这些元组组成的列表。在Python3.x中为了减少内存，返回的是一个对象，可以用list()转换来输出列表。 如果各个迭代器的元素个数不一样，则返回列表长度与最短的对象相同，利用*号操作符，可以将元组解压为列表。 语法1zip([iterable, ...]) 参数： iterable：一个或多个迭代器； 返回值： 返回一个对象； 示例1234567891011121314151617a = [1,2,3]b = [4,5,6]c = [4,5,6,7,8]zipped = zip(a,b) # 返回一个对象zipped# &lt;zip object at 0x103abc288&gt;list(zipped) # list() 转换为列表# [(1, 4), (2, 5), (3, 6)]list(zip(a,c)) # 元素个数与最短的列表一致# [(1, 4), (2, 5), (3, 6)]a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式，*是Python函数可变参数的一种表示形式，加*的表示传入一个元组对象进行解包list(a1)# [1, 2, 3]list(a2)# [4, 5, 6] 2、一些使用相邻元素压缩器12345a = [1, 2, 3, 4, 5, 6]list(zip(*([iter(a)] * 2)))# [(1, 2), (3, 4), (5, 6)]list(zip(*([iter(a)] * 3)))# [(1, 2, 3), (4, 5, 6)] 首先理解迭代器，iter()可以将一个序列生成为一个迭代器，迭代器的特点是可以用for in语句迭代。原理是迭代器对象有一个next方法，可以每次移动迭代的指针，一旦迭代完，没有下一个元素的时候，会触发一个StopIteration异常。迭代器的特点是，迭代了一次以后，指针就移动了，不会自动回溯。例如，可以用for in迭代列表无数次，但只能迭代一次迭代器，如下： 123456789101112131415&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; x = iter(a)&gt;&gt;&gt; for i in x:... print(i)... 123456&gt;&gt;&gt; for i in x:... print(i) # 因为x已经被迭代过了，迭代的指针不会回溯，所以没有值了... &gt;&gt;&gt; 而在上述相邻元素压缩器的使用过程中，可以发现： 12345a = [1, 2, 3, 4, 5, 6][iter(a)] * 3# [&lt;listiterator at 0x7fa6c00ec1d0&gt;,# &lt;listiterator at 0x7fa6c00ec1d0&gt;,# &lt;listiterator at 0x7fa6c00ec1d0&gt;] 三个迭代器实际上是同一个迭代器。 再来理解zip，如前文所述，zip将两个序列对应打包，如： 1234&gt;&gt;&gt; a1 = [1, 3, 5]&gt;&gt;&gt; a2 = [2, 4, 6]&gt;&gt;&gt; list(zip(a1, a2))[(1, 2), (3, 4), (5, 6)] 而*则表示传入一个对象进行解包，如： 12345&gt;&gt;&gt; t = (a1, a2)&gt;&gt;&gt; list(zip(t)) # 不加*号，zip 只有一个参数 t[([1, 3, 5],), ([2, 4, 6],)]&gt;&gt;&gt; list(zip(*t)) # 加*号的作用就是将元祖t，解包成a1,a2为zip的两个函数参数[(1, 2), (3, 4), (5, 6)] 最后理解为什么使用迭代器，如下： 12345678&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; x = iter(a)&gt;&gt;&gt; t = [a, a]&gt;&gt;&gt; list(zip(*t)) # case 1，不使用迭代器[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)] &gt;&gt;&gt; tx = [x, x] &gt;&gt;&gt; list(zip(*tx)) # case 2，使用迭代器[(1, 2), (3, 4), (5, 6)] 在case 1中，zip传入的两个参数a，等于打包了两个列表，并在zip(*)中进行解包，等价于： 1zip([1, 2, 3, 4, 5, 6],[1, 2, 3, 4, 5, 6]) 在case 2中，x是迭代器对象，迭代过程会调用next方法，迭代过一次后会自动移动且不会回溯。也就是说zip执行过程中先调用第一个参数x的next方法得到参数1，再调用第二个参数x的next方法，上文我们已知这两个迭代器其实是同一个迭代器对象，所以第二次调用x的next方法时，迭代器指针已经移动，所以得到参数2，整个过程类似如下： 123456x.next -&gt; 1x.next -&gt; 2zip(x.next(), x.next()) ---&gt; zip(1, 2)x.next -&gt; 3x.next -&gt; 4zip(x.next(), x.next()) ---&gt; zip(3, 4) 等价于： 1zip([1, 3, 5], [2, 4, 6]) 基于此，就可以理解使用zip做相邻元素压缩器的完整执行过程了。 列表元素依次相连 注意与相邻元素压缩器的效果区别。 12345temp = ['a', 'b', 'c', 'd', 'e','f']print(temp)# ['a', 'b', 'c', 'd', 'e', 'f']list(zip(temp[:-1],temp[1:]))# [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')] 这个用法比较好理解，temp[:-1]去除列表最后一个元素，temp[1:]去除列表第一个元素，则上述过程等价于： 1zip(['a', 'b', 'c', 'd', 'e'], ['b', 'c', 'd', 'e', 'f']) 基于该用法可衍生出多个元素依次相连的用法，如： 12list(zip(temp[:-2],temp[1:-1],temp[2:]))# [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')] 也可以用这种方法实现列表相邻元素压缩器的效果，如： 123a = [1, 2, 3, 4, 5, 6]list(zip(a[::3], a[1::3], a[2::3]))# [(1, 2, 3), (4, 5, 6)] 取列表相同位置元素12345678nums = ['flower','flow','flight']for i in zip(*nums): print(i)# ('f', 'f', 'f')# ('l', 'l', 'l')# ('o', 'o', 'i')# ('w', 'w', 'g') 反转字典123m = &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125;dict(zip(m.values(), m.keys()))# &#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>zip</tag>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】5、最长回文子串]]></title>
    <url>%2F2019%2F03%2F19%2Fleetcode_5%2F</url>
    <content type="text"><![CDATA[5、Longest Palindromic Substring最长回文子串 难度：中等 题目描述 英文： Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 中文： 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 解题思路思路一动态规划方法，维护一个二维数组$tags$，其中$tags[i][j]$表示字符串区间$[i,j]$是否为回文串，当$i=j$时，字符串只有一个字符，肯定是回文串，当$j=i+1$时，字符串为相邻的两个字符，需要判断$s[i]$是否等于$s[j]$，如果$i$和$j$不相邻，即$j-i\ge2$时，除了判断$s[i]$和$s[j]$是否相等，还要判断$tags[i+1][j-1]$是否为真，则有如下递推式： tags[i][j]= \begin{cases} 1, & \text{if $i==j$}\\ s[i]==s[j],&\text{if $j=i+1$}\\ s[i]==s[j]\ \&\&\ tags[i+1][j-1],& \text{if $j>i+1$} \end{cases}代码提交 Python3，用时6708ms，内存21.9M 时间复杂度：$O(n^2)$ 123456789101112131415161718192021222324class Solution: def longestPalindrome(self, s): length = len(s) if length &lt;= 1: return s # 初始化二维数组 tags # 不可以用 tags = [[False]*length]*length 的方式，深浅拷贝 tags = [[False for col in range(length)] for row in range(length)] left = 0 right = 0 templen = 0 for j in range(length): # if i==j tags[j][j] = True # j &gt; i for i in range(j): tags[i][j] = (s[i] == s[j] and (j-i &lt; 2 or tags[i+1][j-1])) # 更新当前记录的最长回文子串信息 if tags[i][j] and templen &lt; j-i+1: left = i right = j templen = j-i+1 return s[left:right+1] 思路二参考链接 弱鸡的讲说，这个思路是一致的，但是代码没太看明白。。。 根据回文的特性，一个大回文按比例缩小后的字符串也必定是回文，比如ABCCBA，那BCCB肯定也是回文。所以我们可以根据动态规划的两个特点：（1）把大问题拆解为小问题（2）重复利用之前的计算结果这道题。如何划分小问题，我们可以先把所有长度最短为1的子字符串计算出来，根据起始位置从左向右，这些必定是回文。然后计算所有长度为2的子字符串，再根据起始位置从左向右。到长度为3的时候，我们就可以利用上次的计算结果：如果中心对称的短字符串不是回文，那长字符串也不是，如果短字符串是回文，那就要看长字符串两头是否一样。这样，一直到长度最大的子字符串，我们就把整个字符串集穷举完了。 代码提交 Python3，用时160ms，内存13M 12345678910111213141516171819202122232425class Solution: def longestPalindrome(self, s): # 使用动态规划，用空间换时间，把问题拆分 # 获取字符串s的长度 str_length = len(s) # 记录最大字符串长度 max_length = 0 # 记录位置 start = 0 # 循环遍历字符串的每一个字符 for i in range(str_length): # 如果当前循环次数-当前最大长度大于等于1 并 字符串[当前循环次数-当前最大长度-1:当前循环次数+1] == 取反后字符串 if i - max_length &gt;= 1 and s[i-max_length-1: i+1] == s[i-max_length-1: i+1][::-1]: # 记录当前开始位置 start = i - max_length - 1 # 取字符串最小长度为2，所以+=2，s[i-max_length-1: i+1] max_length += 2 continue # 如果当前循环次数-当前最大长度大于等于0 并 字符串[当前循环次数-当前最大长度:当前循环次数+1] == 取反后字符串 if i - max_length &gt;= 0 and s[i-max_length: i+1] == s[i-max_length: i+1][::-1]: start = i - max_length # 取字符串最小长度为1，所以+=1，s[i-max_length: i+1] max_length += 1 # 返回最长回文子串 return s[start: start + max_length] 思路三解决最长回文子串的一个时间复杂度为$O (n)$的算法——Manacher算法。 还没有仔细看，应该是针对该问题的一个比较巧妙的算法。 可参考：最长回文子串——Manacher 算法，LeetCode]最长回文子串（Longest Palindromic Substring）。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】213、打家劫舍II]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode_213%2F</url>
    <content type="text"><![CDATA[213、House Robber II打家劫舍II 难度：中等 题目描述 英文： You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 中文： 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 Example 1: 12345678Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 Example 2: 123456789Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 解题思路思路一相比“打家劫舍I”多了首尾不能相连的限制，可以通过对1~n-1和2~n两个序列分别按“打家劫舍I”的思路计算一遍，最后取最大值返回即可。 顺序遍历整个数组，当遍历到第i个值时，有两种情况： 之前遍历过程中的curSum始终大于0，假设当前子序列为a,a+1,a+2,...,b-2,b-1,b，此时考虑所有可能： 以当前子序列开头为开头，以中间任一处结尾的序列，如a,a+1,a+2,...b-2：这种情况一致在遍历过程中保存更新； 以当前子序列结尾为结尾，以中间任一处开头的序列，如a+2,...,b-2,b-1,b：这种情况一定小于当前的完整子序列的和，因为前面缺失的部分的和一定是大于0的（讨论的前提就是遍历过程加和始终大于0）； 以中间元素为开头和结尾的序列，如a+2,...,b-2：这种情况，首先按照前一条讨论，补全前面缺失的部分，之后就变成了第一条讨论的情况； 也就是说，i前面的所有可能序列情况都已经考虑到了； curSum出现小于0的情况，此时由于已遍历过的连续子序列加和&lt;0，则遍历过的这个连续子序列不能完整的被包含到新形成的序列中了；而是否要全部放弃，还是保留末尾的部分元素？参考之前的讨论，以当前子序列结尾为结尾，以中间任一处开头的序列的加和是小于完整子序列的，也就是说是&lt;0的，因为此时遍历过的连续子序列需要全部放弃，即curSum置0，并重新开始累加。 其中，每次curSum&lt;0时的下一位置即为和最大的子序列的开始，每次curSum&gt;maxSum时的位置即为和最大的子序列的结尾。 代码提交 Python3，用时56ms，内存13.2M 123456789101112131415161718class Solution: def rob1(self, nums): if not nums: return 0 if len(nums) == 1: return nums[0] temp = [nums[0], max(nums[0], nums[1])] for i in range(2, len(nums)): temp.extend([max(temp[i-1], temp[i-2]+nums[i])]) return temp[-1] def rob(self, nums): if not nums: return 0 if len(nums) == 1: return nums[0] return max(self.rob1(nums[1:]), self.rob1(nums[:-1]))]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】198、打家劫舍]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode_198%2F</url>
    <content type="text"><![CDATA[198、House Robber打家劫舍 难度：简单 题目描述 英文： You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 中文： 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 Example 1: 12345678910Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 Example 2: 12345678910Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路思路一动态规划，根据题意，不能窃取相邻的房屋，那么第$n$天的最高金额，要么等于第$n-1$天的最高金额，要么等于$n-2$天的最高金额加上第$n$天可获得的金额。 用$f (n)$表示第$n$天的最高金额，$p_n$表示第$n$天可获得的金额，则$f (n) = \max (f(n-1) , f(n-2)+p_n)$，其中，$f(1) = p_1 , f(2)=\max (p_1, p_2)​$。 Ps. 开始简单的以为，就是奇数位求和，偶数位求和，然后取最大值，后来发现不对，只要求有间隔，但间隔不一定为1，如测试用例[2,1,1,2]，则间隔为2，取首尾两个元素时为最大值。 代码提交 Python3，用时64ms，内存13.1M 时间复杂度：$O (n) ​$ 1234567891011class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] temp = [nums[0], max(nums[0], nums[1])] for i in range(2, len(nums)): temp.append(max(temp[i-1], temp[i-2]+nums[i])) return temp[-1] 在Python中，list添加元素的方法，expend效率要高于append，调整后，用时52ms，如下： 1234567891011class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] temp = [nums[0], max(nums[0], nums[1])] for i in range(2, len(nums)): temp.extend([max(temp[i-1], temp[i-2]+nums[i])]) return temp[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】121、买卖股票的最佳时机]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode_121%2F</url>
    <content type="text"><![CDATA[121、Best Time to Buy and Sell Stock买卖股票的最佳时机 难度：简单 题目描述 英文： Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. 中文： 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 Example 1: 123456789Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 Example 2: 1234567Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路思路一动态规划问题，第$i$天的最高利润，要么等于前$i-1$天的最高利润，要么等于第$i$天的卖出价减去前$i-1$天的最低买入价。 用$f (i)$表示第$i$天的最高利润，$p_i$表示第$i$天的价格，则$f (i) = \max ( f(i-1) , p_i - \min (p_1,p_2,…,p_{i-1}) )$。 要注意卖出价高于买入价的限制。 代码提交 Python3，用时6040ms，内存14.2M 1234567891011class Solution: def maxProfit(self, prices: List[int]) -&gt; int: length = len(prices) if length &lt;= 1: return 0 temp = [prices[1]-prices[0]] for i in range(1, length): temp.append(max(temp[i-1], prices[i]-min(prices[:i]), 0)) return temp[-1] 每次都会判断前$i-1$天的最低价，可以将最低价进行保存。 Python3，用时104ms，内存14M 1234567891011121314class Solution: def maxProfit(self, prices: List[int]) -&gt; int: length = len(prices) if length &lt;= 1: return 0 temp = [prices[1]-prices[0]] tempMin = prices[0] for i in range(1, length): if prices[i] &lt; tempMin: tempMin = prices[i] temp.append(max(temp[i-1], prices[i]-tempMin)) return temp[-1] 思路二遍历数组，寻找最低价之后的最高收益。 判断第$i$天的价格，是否是当前最低价，不是最低价则判断是否可获得当前最大收益（获得当前最大收益的节点不一定是当前最高价的节点，当前最高价可能出现在最低价之前，所以无法更新最低价的时候，判断收益而不是试图更新最高价）。 代码提交 Python3，用时80ms，内存13.8M 12345678910111213141516class Solution: import sys def maxProfit(self, prices: List[int]) -&gt; int: length = len(prices) if length &lt;= 1: return 0 tempMin = sys.maxsize tempMax = 0 for i in prices: if i &lt; tempMin: tempMin = i elif i-tempMin &gt; tempMax: tempMax = i-tempMin return tempMax]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】70、爬楼梯]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode_70%2F</url>
    <content type="text"><![CDATA[70、Climbing Stairs爬楼梯 难度：简单 题目描述 英文： You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 中文： 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 Example 1: 12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2: 123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 解题思路思路一动态规划问题，直接递归，用$f (n)$表示到达第$n$阶时的方法数，共有两种爬楼方式（一次一阶，一次两阶），那么到达第$n$阶可以通过“到达第$n-1$阶后再走一次一阶”和“到达第$n-2$阶后再走一次两阶”两种方式，那么只需要考虑到达$n-1$阶和$n-2$阶各有多少种方法即可，即$f(n) = f(n-1) + f(n-2)$，终止条件为$f(1) = 1 , f(2)=2$。 代码提交 Python3，超时 时间复杂度：T(n) = O(1.618 ^ n)（1.618就是黄金分割，(1+5–√)/2(1+5)/2）。 空间复杂度取决于递归的深度，显然是O(n)。 1234567class Solution: def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 if n == 2: return 2 return self.climbStairs(n-1) + self.climbStairs(n-2) 直接递归的方法重复计算太多，直接超时，将计算过的结果进行缓存，使用递归的方式，如下： Python3，用时80ms，内存13.2M 时间复杂度是O(n) 空间复杂度是O(1) 12345678910class Solution: def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 if n == 2: return 2 tempNum = [0,1,2] for i in range(3, n+1): tempNum.append(tempNum[i-1] + tempNum[i-2]) return tempNum[n] 思路二递归表达式及终止条件值符合斐波那契数列。其实跟上面的方法差不多。 代码提交 Python3，用时52ms，内存13.1M 时间复杂性：$O (n)​$ 1234567class Solution: def climbStairs(self, n: int) -&gt; int: a = 0 b = 1 for i in range(n+1): a, b = a + b, a return a]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】53、最大子序和]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_53%2F</url>
    <content type="text"><![CDATA[53、Maximum Subarray最大子序和 难度：简单 题目描述 英文： Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. 中文： 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. 进阶 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路思路一遍历数组，用curSum维护当前位置累加的和，当curSum&lt;0时，将其置为0，重新开始累加，每次都更新全局最大值。 顺序遍历整个数组，当遍历到第i个值时，有两种情况： 之前遍历过程中的curSum始终大于0，假设当前子序列为a,a+1,a+2,...,b-2,b-1,b，此时考虑所有可能： 以当前子序列开头为开头，以中间任一处结尾的序列，如a,a+1,a+2,...b-2：这种情况一致在遍历过程中保存更新； 以当前子序列结尾为结尾，以中间任一处开头的序列，如a+2,...,b-2,b-1,b：这种情况一定小于当前的完整子序列的和，因为前面缺失的部分的和一定是大于0的（讨论的前提就是遍历过程加和始终大于0）； 以中间元素为开头和结尾的序列，如a+2,...,b-2：这种情况，首先按照前一条讨论，补全前面缺失的部分，之后就变成了第一条讨论的情况； 也就是说，i前面的所有可能序列情况都已经考虑到了； curSum出现小于0的情况，此时由于已遍历过的连续子序列加和&lt;0，则遍历过的这个连续子序列不能完整的被包含到新形成的序列中了；而是否要全部放弃，还是保留末尾的部分元素？参考之前的讨论，以当前子序列结尾为结尾，以中间任一处开头的序列的加和是小于完整子序列的，也就是说是&lt;0的，因为此时遍历过的连续子序列需要全部放弃，即curSum置0，并重新开始累加。 其中，每次curSum&lt;0时的下一位置即为和最大的子序列的开始，每次curSum&gt;maxSum时的位置即为和最大的子序列的结尾。 代码提交 Python3，用时96ms，内存13.6M 时间复杂度：$O (n) $ 123456789101112131415class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] maxSum = nums[0] curSum = 0 for i in range(len(nums)): curSum += nums[i] maxSum = max(maxSum, curSum) if curSum &lt; 0: curSum = 0 return maxSum 思路二动态规划，用tempSum保存以第i个元素结尾的最大连续子序列的和，假设对于元素i，其前面的所有元素结尾的序列和都已经得到，则以第i个元素结尾的子序列的和要么是以第i-1个元素结尾的和最大的子序列加上当前元素，要么就是当前元素本身，即tempSum[i] = max(tempSum[i-1]+nums[i], nums[i])。（实际等价于看以i-1个元素结尾的和最大的子序列的和是否小于0，等价于思路一了）当i=0时，最大子序列和即为tempSum[0] = nums[0]。 代码提交 Python3，用时104ms，内存14.2M 时间复杂度：$O (n) ​$ 123456789101112class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] tempSum = [] tempSum.append(nums[0]) for i in range(1, len(nums)): tempSum.append(max(tempSum[i-1]+nums[i], nums[i])) return max(tempSum) 可以直接用nums来保存子序列最大和，能节约一点内存，如下： 12345678910class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] for i in range(1, len(nums)): nums[i] = max(nums[i-1]+nums[i], nums[i]) return max(nums) 思路三提示说可以尝试用分治法，那么就将整个数组不断切分成子数组，最后选最大值返回。 用二分法切分数组，最大子序和要么在左半部分，要么在右半部分，要么横跨左右两部分（既包含左侧的最后一个元素，也包含右侧的第一个元素），返回这三种情况的最大值即可。 横跨左右两部分的情况，可以从中间位置逐次向左右两侧遍历，并更新最大值。 代码提交 Python3，用时272ms，内存13.7M 时间复杂度：$O(n\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] left = 0 right = len(nums)-1 maxSum = self.divide(nums, left, right) return maxSum def divide(self, nums, left, right): # 切分到只有一个元素时，返回 if left == right: return nums[left] # 确立中心点 center = (left + right)//2 # 子序列完全在左侧的最大和 leftMax = self.divide(nums, left, center) # 子序列完全在右侧的最大和 rightMax = self.divide(nums, center+1, right) # 子序列横跨左右两侧的最大和 # 从中间点逐次向左边界靠近 leftSum = 0 leftBorderSum = 0 for i in range(center-1, left-1, -1): leftSum += nums[i] leftBorderSum = max(leftSum, leftBorderSum) # 从中间点逐次向右边界靠近 rightSum = 0 rightBorderSum = 0 for i in range(center+1, right+1): rightSum += nums[i] rightBorderSum = max(rightSum, rightBorderSum) centerMax = leftBorderSum + nums[center] + rightBorderSum return max(leftMax, centerMax, rightMax)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】136、只出现一次的数字]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_136%2F</url>
    <content type="text"><![CDATA[136、Single Number只出现一次的数字 难度：简单 题目描述 英文： Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 中文： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 Example 1: 12Input: [2,2,1]Output: 1 Example 2: 12Input: [4,1,2,1,2]Output: 4 解题思路思路一只有一个元素只出现一次，其余元素都出现两次，所以可以先对原数组去重并求和，再用两倍的和减去原数组的和，得到的结果就是只出现一次的元素值。 只适合只有一个元素次数不同的情况，且使用了额外空间。 代码提交 Python2，用时44ms，内存12.6M 1234567class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ return 2 * sum(set(nums)) - sum(nums) 思路二利用位运算的异或操作，任何数字异或其自身都等于零，任何数字异或零还等于其本身。 题目只有一个元素出现一次，其余元素都出现两次，出现两次的元素异或结果都为零，剩余一个出现一次的元素，与零异或后结果还是其本身，也就是说对所有元素进行异或操作后，结果即为只出现一次的那一个元素值。 代码提交 Python2，用时44ms，内存12.2M 看提交情况，用时最短的代码也是这个思路，约24ms，所以用时可能也和其他一些系统随机因素有关系吧。 12345678910class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ temp = 0 for i in nums: temp ^= i return temp]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】414、第三大的数]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_414%2F</url>
    <content type="text"><![CDATA[414、Third Maximum Number第三大的数 难度：简单 题目描述 英文： Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). 中文： 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例Example 1: 12345Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1. Example 2: 12345Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead. Example 3: 123456Input: [2, 2, 3, 1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 解题思路利用三个变量分别记录数组第1、2、3大的数字，遍历一遍数组即可更新前三大的数，时间复杂度O(n)。 引申出的top-k问题，以及解决top-k问题的BFPRT算法，后续再详细记录。 代码提交 Python2，用时28ms，内存11.1M 123456789101112131415class Solution(object): def thirdMax(self, nums): """ :type nums: List[int] :rtype: int """ first = second = third = None for temp in nums: if temp &gt; first: first, second, third = temp, first, second elif first &gt; temp &gt; second: second, third = temp, second elif second &gt; temp &gt; third: third = temp return third if third is not None else first TipsNone]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python各种排序]]></title>
    <url>%2F2019%2F03%2F13%2Fpython_lambda_sorted%2F</url>
    <content type="text"><![CDATA[0、基础 主要用到list.sort()、sorted()、lambda进行各种排序操作。 其中：list.sort()是Python列表的一个内置排序方法，只供list结构使用，list.sort()方法排序时直接修改原列表，返回None。而sorted()函数接受一切迭代器，返回新列表。 相比list.sort()，sorted()使用范围更广，但是如果不需要保留原列表的情况下对列表排序，可以选择list.sort()方法，不需要复制原有列表，消耗内存小，效率也较高。 list.sort()list.sort()函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。 语法1list.sort(cmp=None, key=None, reverse=False) 参数 cmp：可选参数，如果指定了该参数则使用该参数的方法进行排序，Python3取消了该参数； key：用来进行比较的元素，取自可迭代对象中，指定可迭代对象中的一个元素来进行排序； reverse：排序规则，True降序，False升序（默认）； 返回值 该方法直接修改原列表，返回None； 示例12345678910111213# 列表排序test = ['Google', 'Runoob', 'Taobao', 'Facebook']test.sort()print(test)# result:# ['Facebook', 'Google', 'Runoob', 'Taobao']# 列表降序排序vowels = ['e', 'a', 'u', 'o', 'i']vowels.sort(reverse=True)print (vowels)# result:# ['u', 'o', 'i', 'e', 'a'] sorted()sorted()函数对所有可迭代对象进行排序操作。 语法1sorted(iterable, key=None, reverse=False) 参数 iterable：可迭代对象； key：用来进行比较的元素，取自可迭代对象中，指定可迭代对象中的一个元素来进行排序； reverse：排序规则，True降序，False升序（默认）； 返回值 返回排序好的列表； 示例12345678910# 排序sorted([5, 2, 3, 1, 4])# result：# [1, 2, 3, 4, 5]# 降序排序example_list = [5, 0, 6, 1, 2, 7, 3, 4]sorted(example_list, reverse=True)# result：# [7, 6, 5, 4, 3, 2, 1, 0] lambdaPython使用lambda创建匿名函数，即不使用def这样的标准语句来定义函数，允许快速定义单行函数，类似于C语言的宏，可以用在任何需要函数的地方。 lambda的主体是一个表达式，而不是一个代码块，仅能在其中封装有限的逻辑； lambda函数拥有自己的命名空间，不能访问参数列表之外或全局命名空间里的参数； lambda并不会带来程序效率的提高，只是使代码更简洁？ 语法1lambda [arg1 [,arg2,.....argn]]:expression 上述用法等价于： 12def &lt;lambda&gt;(arg1 [,arg2,......argn]): return expression 示例123456789sum = lambda arg1, arg2: arg1 + arg2 # 调用sum函数print ("sum(10,20) = ", sum( 10, 20 ))print ("sum(20,30) = ", sum( 20, 30 ))# result:# sum(10,20) = 30# sum(20,30) = 50 1、各种排序 参考链接 1.1、list排序12345678910111213lis = ['a', 'b', 'c']print(sorted(lis))# ['a', 'b', 'c']print(sorted(lis, reverse=True))# ['c', 'b', 'a']lis.sort()print(lis)# ['a', 'b', 'c']lis.sort(reverse=True)print(lis)# ['c', 'b', 'a'] 1.2、dict按key排序12345dic = &#123;'c': 1, 'b': 2, 'a': 3&#125;print(sorted(dic))# ['a', 'b', 'c']print(sorted(dic, reverse=True))# ['c', 'b', 'a'] 1.3、dict按value排序12345dic = &#123;'c': 1, 'b': 2, 'a': 3&#125;print(sorted(dic, key=lambda k: dic[k]))# ['c', 'b', 'a']print(sorted(dic, key=lambda k: dic[k], reverse=True))# ['a', 'b', 'c'] 1.4、list内嵌套list排序123456789lis = [[4, 2, 9], [1, 5, 6], [7, 8, 3]]print(sorted(lis, key=lambda k: k[0]))# [[1, 5, 6], [4, 2, 9], [7, 8, 3]]print(sorted(lis, key=lambda k: k[1]))# [[4, 2, 9], [1, 5, 6], [7, 8, 3]]print(sorted(lis, key=lambda k: k[2]))# [[7, 8, 3], [1, 5, 6], [4, 2, 9]]print(sorted(lis, key=lambda k: k[0], reverse=True))# [[7, 8, 3], [4, 2, 9], [1, 5, 6]] 1.5、dict内嵌套dict排序12345678910111213dic = &#123; 'a': &#123;'x': 3, 'y': 2, 'z': 1&#125;, 'b': &#123;'x': 2, 'y': 1, 'z': 3&#125;, 'c': &#123;'x': 1, 'y': 3, 'z': 2&#125;,&#125;print(sorted(dic, key=lambda k: dic[k]['x']))# ['c', 'b', 'a']print(sorted(dic, key=lambda k: dic[k]['y']))# ['b', 'a', 'c']print(sorted(dic, key=lambda k: dic[k]['z']))# ['a', 'c', 'b']print(sorted(dic, key=lambda k: dic[k]['x'], reverse=True))# ['a', 'b', 'c'] 1.6、list内嵌套dict排序12345678910111213lis = [ &#123;'x': 3, 'y': 2, 'z': 1&#125;, &#123;'x': 2, 'y': 1, 'z': 3&#125;, &#123;'x': 1, 'y': 3, 'z': 2&#125;,]print(sorted(lis, key=lambda k: k['x']))# [&#123;'z': 2, 'x': 1, 'y': 3&#125;, &#123;'z': 3, 'x': 2, 'y': 1&#125;, &#123;'z': 1, 'x': 3, 'y': 2&#125;]print(sorted(lis, key=lambda k: k['y']))# [&#123;'z': 3, 'x': 2, 'y': 1&#125;, &#123;'z': 1, 'x': 3, 'y': 2&#125;, &#123;'z': 2, 'x': 1, 'y': 3&#125;]print(sorted(lis, key=lambda k: k['z']))# [&#123;'z': 1, 'x': 3, 'y': 2&#125;, &#123;'z': 2, 'x': 1, 'y': 3&#125;, &#123;'z': 3, 'x': 2, 'y': 1&#125;]print(sorted(lis, key=lambda k: k['x'], reverse=True))# [&#123;'z': 1, 'x': 3, 'y': 2&#125;, &#123;'z': 3, 'x': 2, 'y': 1&#125;, &#123;'z': 2, 'x': 1, 'y': 3&#125;] 1.7、dict内嵌套list排序12345678910111213dic = &#123; 'a': [1, 2, 3], 'b': [2, 1, 3], 'c': [3, 1, 2],&#125;print(sorted(dic, key=lambda k: dic[k][0]))# ['a', 'b', 'c']print(sorted(dic, key=lambda k: dic[k][1]))# ['b', 'c', 'a']print(sorted(dic, key=lambda k: dic[k][2]))# ['c', 'b', 'a']print(sorted(dic, key=lambda k: dic[k][0], reverse=True))# ['c', 'b', 'a'] 1.8、按照多个参数排序使用operator模块的itemgetter()实现。 1234567891011from operator import itemgetterstudent_tuples = [('john', 'A', 15),('jane', 'B', 12),('dave', 'B', 10)]print (sorted(student_tuples, key = itemgetter(2))) # 根据年龄排序print (sorted(student_tuples, key = itemgetter(1, 2))) # 根据成绩和年龄排序print (sorted(student_tuples, key = itemgetter(1, 2), reverse=True)) # 反转排序结果# result:# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]# [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]# [('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)] 2、其他list排序可视情况采用sorted()或list.sort()，其他各种排序主要是sorted()和lambda的结合操作； dict的排序只取其key，所以需要对value操作时需要在lambda中先转换为对应的value才可以； 排序是稳定的，即如果多个元素有相同的key，则排序前后其先后顺序不变；]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>lambda</tag>
        <tag>排序</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】937、重新排列日志文件]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_937%2F</url>
    <content type="text"><![CDATA[937、Reorder Log Files重新排列日志文件 难度：简单 题目描述 英文： You have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs. It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order. Return the final order of the logs. 中文： 你有一个日志数组 logs。每条日志都是以空格分隔的字串。 对于每条日志，其第一个字为字母数字标识符。然后，要么： 标识符后面的每个字将仅由小写字母组成，或； 标识符后面的每个字将仅由数字组成。 我们将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。 将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按字母顺序排序，忽略标识符，标识符仅用于表示关系。数字日志应该按原来的顺序排列。 返回日志的最终顺序。 提示 0 &lt;= logs.length &lt;= 100 3 &lt;= logs[i].length &lt;= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier. 示例Example 1: 12Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;] 解题思路思路一先区分数字日志和字母日志，然后字母日志按内容排序，最后合并两部分内容输出。 代码提交 Python2，用时48ms，内存11.1M 1234567891011121314151617class Solution(object): def reorderLogFiles(self, logs): """ :type logs: List[str] :rtype: List[str] """ letterList = [] numberList = [] for log in logs: logList = log.split(" ") if logList[1].isdigit(): numberList.append(log) else: letterList.append((logList[0], " ".join(logList[1:]))) letterList.sort(key=lambda x:x[1]) resultList = [" ".join(a) for a in letterList] return resultList+numberList 后来看了一下用时短的代码，方法都很简单，但是代码很简洁高效。 用0、1标记字母、数字日志，之后一次排序返回。 Python2，用时36ms，内存11.1M 1234567891011class Solution(object): def reorderLogFiles(self, logs): """ :type logs: List[str] :rtype: List[str] """ def f(log): id, rest = log.split(' ', 1) return (0, rest) if rest[0].isalpha() else (1,) return sorted(logs, key = f)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】936、戳印序列]]></title>
    <url>%2F2019%2F03%2F12%2Fleetcode_936%2F</url>
    <content type="text"><![CDATA[936、Stamping The Sequence戳印序列 难度：困难 题目描述 英文： You want to form a target string of lowercase letters. At the beginning, your sequence is target.length &#39;?&#39; marks. You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp. You can make up to 10 * target.length turns. For example, if the initial sequence is “?????”, and your stamp is &quot;abc&quot;, then you may make “abc??”, “?abc?”, “??abc” in the first turn. (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn. If the sequence is not possible to stamp, return an empty array. For example, if the sequence is “ababc”, and the stamp is &quot;abc&quot;, then we could return the answer [0, 2], corresponding to the moves “?????” -&gt; “abc??” -&gt; “ababc”. Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves. Any answers specifying more than this number of moves will not be accepted. 中文： 你想要用小写字母组成一个目标字符串 target。 开始的时候，序列由 target.length 个 &#39;?&#39; 记号组成。而你有一个小写字母印章 stamp。 在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 10 * target.length 个回合。 举个例子，如果初始序列为 “?????”，而你的印章 stamp 是 &quot;abc&quot;，那么在第一回合，你可以得到 “abc??”、”?abc?”、”??abc”。（请注意，印章必须完全包含在序列的边界内才能盖下去。） 如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。 例如，如果序列是 “ababc”，印章是 &quot;abc&quot;，那么我们就可以返回与操作 “?????” -&gt; “abc??” -&gt; “ababc” 相对应的答案 [0, 2]； 另外，如果可以印出序列，那么需要保证可以在 10 * target.length 个回合内完成。任何超过此数字的答案将不被接受。 提示 1 &lt;= stamp.length &lt;= target.length &lt;= 1000 stamp 和 target 只包含小写字母。 示例Example 1: 123Input: stamp = &quot;abc&quot;, target = &quot;ababc&quot;Output: [0,2]([1,0,2] would also be accepted as an answer, as well as some other answers.) Example 2: 12Input: stamp = &quot;abca&quot;, target = &quot;aabcaca&quot;Output: [3,0,1] 解题思路思路一题目是从?????到ababc的问题，替换时要考虑会覆盖到已经替换好的部分。可以逆向替换，从ababc到?????，?可以看做通配符，遍历target，逐位和stamp比较，如果可以匹配到，则记录当时的index，并修改覆盖后的字符，循环上述过程，直到得到了?????序列或无法继续匹配下去。 例如，stamp=&#39;abca&#39;，target=&#39;aabcaca&#39;，则整个替换过程为aabcaca =&gt; a????ca =&gt; ?????ca =&gt; ???????，替换位置索引序列为1-&gt;0-&gt;3，所以题目所求的序列即为[3,0,1]。 代码提交 Python2，用时6480ms，内存10.9M 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object): def movesToStamp(self, stamp, target): """ :type stamp: str :type target: str :rtype: List[int] """ # 如果target首尾字符和stamp不同，则肯定无法覆盖，直接返回[] if target[0] != stamp[0] or target[-1] != stamp[-1]: return [] slen, tlen = len(stamp), len(target) temptarget = target res = [] # 检查是否可以stamp一次，返回索引 def checkstamp(temptarget): # 遍历target，并记录可以覆盖的位置索引index for index in range(tlen): hasletter, stampj, tempi = False, 0, index # 遍历stamp，并对比target[index:index+len(stamp)]是否可以覆盖 while stampj &lt; slen and tempi &lt; tlen and (temptarget[tempi] == "?" or temptarget[tempi] == stamp[stampj]): # 待覆盖内容包含非“?”内容，不匹配完全由“?”组成的内容 if temptarget[tempi] == stamp[stampj]: hasletter = True stampj += 1 tempi += 1 # 修改覆盖后的target if hasletter and stampj == slen: temptarget = temptarget[:index] + "?"*slen + temptarget[index+slen:] return index, temptarget return -1, temptarget # 到完全覆盖时停止 while temptarget != "?"*tlen: temp, temptarget = checkstamp(temptarget) if temp == -1: return [] res.append(temp) # 返回逆序序列 return res[::-1] 思路二参考链接 上述方法一的checkstamp过程有很多重复计算，事实上不需要每次都从头开始遍历，可以进行一些优化。 只进行一次字符串匹配的循环，在时间进行了优化，相应的内存消耗增加。记录每一个位置 i 对应长度为lenS的字符串上有哪些部分是能对应的，哪些些是不对应的。再将完全对应的字符串的位置全部压入队列。 在队列中的每一个位置都是已匹配位置，在change中声明当前位置已匹配，之后考虑当前位置改动后可能会产生影响的所有位置 i 对应的长度为lenS的字符串。 代码提交 Python2，用时436ms，内存14.4M 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import collectionsclass Solution(object): def movesToStamp(self, stamp, target): """ :type stamp: str :type target: str :rtype: List[int] """ M, N = len(stamp), len(target) queue = collections.deque() done = [False] * N ans = [] A = [] for i in range(N - M + 1): # For each window [i, i+M), # A[i] will contain info on what needs to change # before we can reverse stamp at i. made, todo = set(), set() for j, c in enumerate(stamp): a = target[i+j] if a == c: made.add(i+j) else: todo.add(i+j) A.append((made, todo)) # If we can reverse stamp at i immediately, # enqueue letters from this window. if not todo: ans.append(i) for j in range(i, i + len(stamp)): if not done[j]: queue.append(j) done[j] = True # For each enqueued letter, while queue: i = queue.popleft() # For each window that is potentially affected, # j: start of window for j in range(max(0, i-M+1), min(N-M, i)+1): if i in A[j][1]: # This window is affected A[j][1].discard(i) # Remove it from todo list of this window if not A[j][1]: # Todo list of this window is empty ans.append(j) for m in A[j][0]: # For each letter to potentially enqueue, if not done[m]: queue.append(m) done[m] = True return ans[::-1] if all(done) else []]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异或操作&位运算]]></title>
    <url>%2F2019%2F03%2F07%2Fweiyunsuan%2F</url>
    <content type="text"><![CDATA[做题时用到了按位异或的操作，有点蒙蒙的，大概查了查位运算的一些东西，略作总结，主要以Python为例。 参考链接 位运算简介位运算是把数字用二进制表示之后，对每一位上0或1的运算。 所有的运算（包括位运算）在计算机内部都是通过补码的形式进行运算的。 补码是计算机表示数据的一般方式，其规则为：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上1(相当于将原码数值位取反然后在最低位加1)。 例如： 数字 6 在8位计算机中的补码为：0000 0110 （即为其原码） 数字 -6 在8位计算机中的补码为：1111 1010 主要的位运算总共有6种：与、或、异或、取反、左移、右移，如下表所示： 表中示例： a=60，二进制表示 0011 1100 b=13，二进制表示 0000 1101 运算符 描述 示例 &amp; 按位与：参与运算的两个值，如果两个对应位都为1，则该位的结果为1，否则为0； (a&amp;b)结果为12，二进制 0000 1100 \ 按位或：只要对应的两个二进制位中有一个为1时，该位的结果就为1； (a\ b)结果为61，二进制 0011 1101 ^ 按位异或：当两个对应的二进制位不同时，该位的结果为1； (a^b)结果为49，二进制 0011 0001 ~ 按位取反：对数据的每个二进制位取反，即把1变成0，把0变成1； (~a)结果为 -61，二进制 1100 0011（有符号二进制数的补码形式） \&lt;\&lt; 按位左移：数据的每个二进制位均左移若干位，\&lt;\&lt;右边的数字指定移动位数，高位丢弃，低位补0； (a\&lt;\&lt;2)结果为240，二进制 1111 0000 >> 按位右移：数据的每个二进制位均右移若干位，>>右边的数字指定移动位数，具体见下文； (a>>2)结果为15，二进制 0000 1111 左移运算符：m\&lt;\&lt;n 表示把 m 左移 n 位，最左边的 n 位被丢弃，同时在最右边补上 n 个0，如下： 1200001010 &lt;&lt; 2 = 0010100010001010 &lt;&lt; 3 = 01010000 右移运算符：m>>n 表示把 m 右移 n 位，最右边的 n 位被丢弃，但最左边的处理方式有所不同：如果符号位为0，则右移后高位补0，如果符号位为1，则高位补1，也就是说，如果数字是正数，则右移后在最左边补 n 个0，如果数字为负数，则右移后在最左边补 n 个1。如下： 1200001010 &gt;&gt; 2 = 0000001010001010 &gt;&gt; 3 = 11110001 如下为Python中所有位运算操作符示意： 123456789101112131415161718192021222324a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0c = a &amp; b; # 12 = 0000 1100print "a &amp; b 的值为：", cc = a | b; # 61 = 0011 1101 print "a | b 的值为：", cc = a ^ b; # 49 = 0011 0001print "a ^ b 的值为：", cc = ~a; # -61 = 1100 0011print " ~a 的值为：", cc = a &lt;&lt; 2; # 240 = 1111 0000print " a&lt;&lt;2 的值为：", cc = a &gt;&gt; 2; # 15 = 0000 1111print " a&gt;&gt;2 的值为：", c# result:# a &amp; b 的值为： 12# a | b 的值为： 61# a ^ b 的值为： 49# ~a 的值为： -61# a&lt;&lt;2 的值为： 240# a&gt;&gt;2 的值为： 15 移位运算运算规则 左移运算符：m\&lt;\&lt;n 表示把 m 左移 n 位，最左边的 n 位被丢弃，同时在最右边补上 n 个0，如下： 1200001010 &lt;&lt; 2 = 0010100010001010 &lt;&lt; 3 = 01010000 右移运算符：m>>n 表示把 m 右移 n 位，最右边的 n 位被丢弃，但最左边的处理方式有所不同：如果符号位为0，则右移后高位补0，如果符号位为1，则高位补1，也就是说，如果数字是正数，则右移后在最左边补 n 个0，如果数字为负数，则右移后在最左边补 n 个1。如下： 1200001010 &gt;&gt; 2 = 0000001010001010 &gt;&gt; 3 = 11110001 特殊应用 移位运算是最有效的计算乘/除法的运算之一，把整数左/右移一位，和把整数乘以/除以 2 在数学上是等价的。 1234567891011a = 2print a &lt;&lt; 1 # 左移一位等效于a = a * 2;# result: 4print a &lt;&lt; 2 # a左移两位等效于a = a * 2的2次方（4）；# result: 8a = 16print a &gt;&gt; 1 # 右移一位等效于a = a / 2；# result: 8print a &gt;&gt; 2 # 右移两位等效于a = a / (2**2)；# result: 4 按位与运算规则0&amp;0=0，0&amp;1=0，1&amp;0=0，1&amp;1=1。 即：两位同时为“1”，结果才为“1”，否则为0，有0则0。 特殊应用 清零指定位： mask中指定位置0，其它位为1，a = a &amp; mask。 取一个数的指定二进制位： mask中指定位置1，其它位为0，a = a &amp; mask。 判断一个数二进制表示中1的个数： 一个整数减去1，再和原数做与运算，会把该整数二进制表示中最右边一个1变为0。 如： 实现一个函数，输入一个正数，输出该数二进制表示中1的个数： 12345678num = 0n=5 # 二进制：101while(n): n &amp;= (n-1) num += 1print str(num)# result: 2 判断一个正数是不是2的整数次方： 如果是2的整数次方，则其二进制表示中有且只有一位是1。 1234a=4print a&amp;(a-1) == 0# result: True 按位或运算规则0|0=0；0|1=1；1|0=1；1|1=1。 即 ：参加运算的两个对象只要有一个为1，其值为1，有1则1。 特殊应用 对数据的指定位置为1： mask指定位置1，其它位为0，a = a | mask。 如：将 a = 1010 0000 低四位置1，则 a | 0000 1111 即可。 按位异或运算规则0^0=0；0^1=1；1^0=1；1^1=0。 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0，同0异1。 异或特点： 0异或任何数均为原数 1异或任何数，结果为对该数取反 任何数异或自己，结果为0 特殊应用 使特定位翻转： mask的特定位置1，其它位为0，a = a ^ mask。 如，对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算：10100001^00000110 = 10100111。 不使用临时变量，交换两个数的值： 如，交换两个整数a=10100001，b=00000110的值： 123a = a^b # a=10100111b = b^a # b=10100001a = a^b # a=00000110 与0异或，保留原值： a ^ 0仍为a。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>异或</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[%time,%timeit魔法命令]]></title>
    <url>%2F2019%2F03%2F04%2Fjupyter_timeit%2F</url>
    <content type="text"><![CDATA[在Jupyter-notebook中有几个用于计时的魔法命令%time、%%time、%timeit、%%timeit，可以非常简单的获取部分代码的运行耗时。 所有以%开头的方法，都是所谓的魔法命令（Magic function），也就是IPython内置的一些方法。魔法方法要区分%和%%，以%开头的叫做line magic，是专门针对一行的命令，以%%开头的叫做cell magic，是针对多行（一个cell）的命令。 以%%开头的魔法命令，必须放在一个cell的第一行，并且统计该cell中剩余的所有代码。分别来看： %time 给出当前行的代码运行一次所花费的时间； 123456a,b = 1,2%time a,b = b,a# output:# CPU times: user 2 µs, sys: 1 µs, total: 3 µs# Wall time: 5.01 µs 其中： user：表示执行用户代码（内核外）消耗的CPU时间； sys：表示进程在内核中消耗的CPU时间； 所以，CPU总耗时看total即可，也就是uset和sys之和。 Wall time是最终总耗时，包括IO、排队的耗时，也就是感知到的总耗时。 Wall time $&lt;$ CPU 表明进程是计算密集型（CPU bound），利用多核处理器的并行执行优势； Wall time $\approx$ CPU 表明进程是计算密集型，未并行执行； Wall time $&gt;​$ CPU 表明进程是I/O密集型（I/O bound），多核并行执行优势并不明显； %%time 给出当前cell的代码运行一次所花费的时间； 1234567%%timea,b = 1,2a,b = b,a# output:# CPU times: user 2 µs, sys: 1e+03 ns, total: 3 µs# Wall time: 5.96 µs %timeit -n 1000 给出当前行的代码运行n次所花费的时间（取最快三次的平均用时）； 1234%timeit -n 10000 c = pow(2,20)# output:# 10000 loops, best of 3: 198 ns per loop %%timeit -n 1000 给出当前cell的代码运行n次所花费的时间（取最快三次的平均用时）； 12345678%%timeit -n 10000a,b = 1,2c=aa=bb=c# output:# 10000 loops, best of 3: 68.5 ns per loop]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs224n-2017笔记：第一讲 Introduction to NLP and Deep Learning]]></title>
    <url>%2F2019%2F03%2F04%2Fcs224n_2017-1%2F</url>
    <content type="text"><![CDATA[斯坦福cs224n-2017 winter笔记 课程链接 难度：简单 主要内容 什么是NLP自然语言处理（NLP）是一门计算机科学、人工智能和语言学的交叉学科。 NLP的目的是处理或者“理解”自然语言，从而完成一些有意义的任务，如订票、购物、QA等等。 完全理解和表达语言的意思是非常困难的，perfect language understanding is AI-complete。 NLP涉及的层次 输入主要有两个来源：语音和文本。所以第一级是语音识别和OCR或分词，接下来是形态学，再下面是句法分析和语义分析，最后是discourse processing，需要根据上文语境理解下文。 这门课主要集中在画圈的三个部分，中间的两个最为重要。 NLP应用一个小子集：拼写检查、关键词检索、文本挖掘、文本分类、机器翻译、复杂对话系统等。 在工业界的应用，包括搜索、广告投放、自动/辅助翻译、情感/舆情分析、语音识别、聊天机器人等等。 人类语言的特殊之处人类语言是离散的、明确的符号系统，但又允许出现各种变种（如颜文字、随意的拼写错误等）。 语言符号有多种形式，但不同的形式中意义保持不变。 虽然人类语言是明确的符号系统，但是大脑编码似乎是连续的激活值上的模式，符号传输到大脑的过程是通过连续的声光信号。另外，巨大的词表会导致数据稀疏（sparsity），不利于机器学习，所以我们希望去探索一种连续编码的模式。 什么是DL深度学习（DL）是机器学习的一个子集。 传统的机器学习方法，大多是人类对专业问题理解很透彻，然后人工设计输入特征，比如地名和机构名识别的特征模板（Finkel et al., 2010）。之后将特征交给某个机器学习算法，比如线性分类器等，算法为这些特征找到合适的权重，将误差优化到最小。 在这个过程中，是人类一直在学习，而机器只是进行了数值优化的工作。 而深度学习是表示学习的一部分，试图自动的学习原始输入的多层特征表示。 DL的历史 为啥研究DL语音识别中的DL突破性研究参考 Context-Dependent Pre-Trained Deep Neural Networks for Large-Vocabulary Speech Recognition 计算机视觉中的DL突破性研究参考 ImageNet Classification with Deep Convolutional Neural Networks 为什么NLP很难人类语言充满歧义，人类语言的解读依赖于现实世界、常识以及上下文等。 Deep NLP = Deep Learning + NLP用深度学习的方法解决NLP问题，提高了很多方面的效果： 层次：语音、词汇、语法、语义 工具：词性标注、命名实体识别、句法分析 应用：机器翻译、情感分析、对话系统、问答系统 NLP表示层级：形态级别传统方法在形态级别的表示是词素： 深度学习中把词素用向量表示，多个词素向量构成相同维度、语义更丰富的词向量： NLP工具：句法分析 神经网络能够准确的进行句法分析，判断句子结构，参考 A Fast and Accurate Dependency Parser using Neural Networks NLP表示层级：语义级别传统方法是手写的大量规则函数，称为Lambda calculus，没有语言的相似性或模糊性的概念： 深度学习中，每个词、短语和逻辑表达都是向量，神经网络进行向量合并： NLP应用：情感分析传统方法是通过大量的人工搜集情感极性词典，在词袋模型上做分类器。 深度学习使用RNN解决这个问题（同样可用于形态学、语法、逻辑语义问题）： 上图并不是RNN的工作流程，仅是为了方便理解。 NLP应用：QA系统传统方法是通过总结大量的特征工程，编写大量逻辑规则，如正则表达式之类： 深度学习方法仍然采用和前面提到的类似的深度学习框架，将事实存储在向量中： NLP应用：对话系统一个成功的案例是Gmail的自动回复系统。 这是神经语言模型（Neural Language Models）的一次成功应用，神经语言模型是基于RNN的： NLP应用：机器翻译传统方法在很多层级上都做过尝试，传统的MT系统是非常庞大复杂的，并且有试图寻找一种通用的中介语来作为源语和目标语之间的桥梁。 而深度学习方法，即神经机器翻译（Neural Machine Translation，NMT），将源语映射为向量，然后由向量构造目标语（参考Sutskever et al. 2014，Bahdanau et al. 2014，Luong and Manning 2016）： 总结：所有层级表示都是向量深度学习的根本强项在于，将所有的语言形式用向量表达，通过一些变形操作又可以将向量变成矩阵或更高阶的阵列（即张量tensor），所以向量是一种具有强大表达能力的灵活的数据结构。 附词向量，一般想正经做点儿东西的话，怎么也得300维、1000维或者更多维这样的级别。 试图将词向量按照高维空间表示的含义映射到二维空间上的常用方法：PCA（主成分分析），t-SNE（一种非线性降维），但低维投影还是会遗漏大量信息。]]></content>
      <categories>
        <category>深度学习</category>
        <category>cs224n-2017</category>
      </categories>
      <tags>
        <tag>cs224n</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】599、两个列表的最小索引总和]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode_599%2F</url>
    <content type="text"><![CDATA[599、Minimum Index Sum of Two Lists 两个列表的最小索引总和 难度：简单 题目描述 英文： Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. 中文： 假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。 示例Example 1: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]Output: [&quot;Shogun&quot;]Explanation: The only restaurant they both like is &quot;Shogun&quot;. Example 2: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]Output: [&quot;Shogun&quot;]Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1). 提示 The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists. 代码提交 Python2，用时128ms，内存11.1M 12345678910111213141516171819202122class Solution(object): def findRestaurant(self, list1, list2): """ :type list1: List[str] :type list2: List[str] :rtype: List[str] """ dict1 = &#123;&#125; for index, name in enumerate(list1): dict1[name] = index templist = [] tempsum = 3000 for index, name in enumerate(list2): if name in dict1: cursum = index+dict1[name] if cursum &lt; tempsum: templist = [name] tempsum = cursum elif cursum == tempsum: templist.append(name) return templist TipsPython查找dict的key时，应使用if key in dict，而不是if key in dict.keys()。 前者是在dict中查找，dict对象的存储结构是hash表，最优情况下查询复杂度为O(1)； 后者等于是在list中查找，list对象的存储结构是线性表，查询复杂度为O(n)。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[若干Python性能优化小tips]]></title>
    <url>%2F2019%2F03%2F04%2Ffasterpython%2F</url>
    <content type="text"><![CDATA[若干简单易实现的Python性能优化小tips。 部分参考：https://segmentfault.com/a/1190000000666603 一些tips在刷题过程确实得到验证，尚有一些未验证但在实际简单测试中效率有提升。 优化算法时间复杂度 不论什么语言，算法的时间复杂度对程序的执行效率都有决定性影响，在Python中可以通过选择合适的数据结构来优化时间复杂度，如list和set查找指定元素的时间复杂度分别为O(n)和O(1)。同时，可以根据具体情况，采用分治、贪心、动态规划等算法思想。（不过优化算法有些有时候也不是很容易实现，，，） 在算法的常见时间复杂度上排序如下： O(1)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HMM和Viterbi算法]]></title>
    <url>%2F2019%2F03%2F01%2FHMM_IM%2F</url>
    <content type="text"><![CDATA[背景试图实现一个基于隐马尔科夫模型的拼音输入法，根据用户输入的拼音序列转换为对应的汉字，完成中文的输入。 输入法基本需求 通常一个拼音会对应多个汉字，如何确定在当前状态下，输入的拼音对应哪个汉字； 拼音序列通常可以对应多种可能的汉字组合，如何确定哪一种组合是相对最好的一种组合，如对于拼音序列yi chang，有异常、一场、宜昌等多种汉字组合，如何进行选择； HMM简介模型定义HMM（Hidden Markov Models，隐马尔科夫模型）是一种基本的统计模型，可以应用在语音识别、自然语言处理、模式识别等很多领域。 HMM的一个前提是马尔科夫假设，即假设模型的当前状态仅依赖于前面的几个状态。马尔科夫假设极大的简化了问题，但也可能丢失一些重要信息。一个马尔科夫过程是指状态间的转移仅依赖于前n个状态的过程，该过程即为n阶马尔科夫模型，其中n是影响下一个状态选择的前n个状态。（通常所说的HMM，指一阶HMM） HMM是在一个标准的马尔科夫过程中引入一组隐藏状态，以及观察状态与隐藏状态之间的一些概率关系，描述了一个含有隐藏状态的马尔科夫过程。 使用HMM模型时，通常问题有以下两个主要特征： 问题是基于序列的，如时间序列、状态序列； 问题中有两类数据，一类数据序列是可以观测到的，即观察序列，另一类数据序列是不能观测到的，即隐藏状态序列，简称状态序列； 例如在打算要做拼音输入法任务中，可以将拼音看做是隐藏状态，而拼音转化的文字结果作为一系列的观察状态，可以看到，引入隐藏状态的同时，观察序列与隐藏过程也具有一定的概率关系。 可以参考上图，其中$Z_i​$为隐藏状态序列，$X_i​$为隐藏状态生成的观察状态序列。隐藏状态序列$Z_i​$满足马尔科夫过程的要求，且观察状态序列$X_i​$与$Z_i​$之间存在概率关系，即模型中的$X_i​$与$X_i+1​$是存在关联的。 模型参数首先定义一些基本符号： $Q=\lbrace q_1,q_2,…,q_N \rbrace$，Q是所有可能的隐藏状态集合，其中N为可能的隐藏状态数，对应所有可能的汉字的状态数量； $V=\lbrace v_1,v_2,…,v_M \rbrace$，V是所有可能的观察状态集合，其中M为可能的观察状态数，对应所有可能的拼音的状态数量； $I=\lbrace i_1,i_2,…,i_T \rbrace​$，I 是长度为T的隐藏状态序列，对应用户输入的拼音序列所对应的汉字序列； $O=\lbrace o_1,o_2,…o_T \rbrace​$，O 是对应的观察序列，对应用户输入的拼音序列； HMM除上述状态集合外，还包括三组概率集合，用一个三元组$\lambda​$来刻画HMM，可写作$\lambda = (A,B,\pi)​$。 A 是隐藏状态转移概率分布，通常用矩阵表示，称为状态转移矩阵： A=[a_{ij}]_{N\times N} \quad where\quad a_{ij}=P(i_{t+1}=q_j|i_t=q_i)即，$a_{ij}​$ 是在时刻 t 处于状态 $q_i​$ 的条件下，在时刻 $t+1​$ 转移到状态 $q_j​$ 的概率，对应汉字到汉字之间的转移概率； B 是观察状态发射概率分布，通常用矩阵表示，称为混淆矩阵或发射矩阵： B=[b_{ik}]_{N\times M} \quad where\quad b_{ik}=P(o_t=v_k|i_t=q_i)即，$b_{ik}​$ 是在时刻 t 下的隐藏状态 $q_i​$ 到观察状态 $v_k​$ 的发射概率，对应汉字到拼音之间的发射概率； π 是初始状态概率，用向量表示： \pi = (\pi_i)_N \quad where \quad \pi=P(i_1=q_i)即，$\pi_i​$ 是在时刻 t=1 时处于隐藏状态 $q_i​$ 的概率； 可以看到，HMM（一阶）有两个基本假设： 齐次假设： P(i_t|i_{t-1},o_{t-1},i_{t-2},o_{t-2},...,i_1,o_1)=P(i_t|i_{t-1})即，任意时刻的隐藏状态只依赖于它前一个时刻的隐藏状态； 观测独立性假设： P(o_t|i_{T-1},o_{T-1},i_{T-2},o_{T-2},...i_1,o_1)=P(o_t|i_t)即，任意时刻的观察状态只依赖于当前时刻的隐藏状态； 用HMM解决的三类基本问题一旦一个系统可以作为HMM被描述，则可以用来解决三个基本问题 1。其中前两个是模式识别的问题：给定HMM求一个观察序列的概率（评估），搜索最有可能生成一个观察序列的隐藏状态序列（解码）。第三个问题是给定观察序列生成一个HMM（学习）。 评估（概率计算问题）：前向算法——动态规划 给定模型$\lambda = (A,B,\pi)​$和观察序列$O=\lbrace o_1,o_2,…o_T \rbrace​$，计算在模型 $ \lambda ​$ 参数已知的情况下，计算观察序列 $O​$ 出现的概率 $P(O|\lambda)​$； 学习（模型学习问题）：前向-后向算法（也叫Baum-Welch算法）——EM 已知观察序列$O=\lbrace o_1,o_2,…o_T \rbrace​$，学习使得观察序列概率 $P(O|\lambda)​$最大的模型$\lambda = (A,B,\pi)​$参数； 即根据观察序列用极大似然估计的方法估计参数生成隐马尔科夫模型； 解码（预测问题）：Viterbi算法——动态规划 已知模型$\lambda = (A,B,\pi)$和观察序列$O=\lbrace o_1,o_2,…o_T \rbrace$，求给定观察序列的情况下条件概率$P(I|O,\lambda)$最大的（隐藏）状态序列$I=\lbrace i_1,i_2,…,i_T \rbrace$； 即给定观察序列，搜索最有可能的对应的隐藏状态序列； Viterbi算法基于以上可知，拼音输入法的问题，属于解码问题，即已知模型和观察序列，求最有可能的对应的隐藏状态序列。 理论上，可以通过枚举所有的状态转移序列来求解解码问题，但效率非常低，暴力枚举的思路是枚举所有的长度T的状态序列，计算该状态序列与观察序列的联合概率。在状态种类为$N$的情况下，共有$N^T$种排列组合，每种组合计算联合概率的计算量为$T$，则总的计算复杂度为$O(TN^T)$ ，可见该方法并不可取。 因此常用维特比（Viterbi）算法来解决。 Viterbi算法是一个通用的求序列最短路径的动态规划算法。 如上图所示，Viterbi算法简单来说就是：从开始状态之后每走一步，就记录下到达该时刻每个状态时，对应该状态所有路径中的概率最大值，并且以这个最大值为基准继续向后前进。显然，如果这个最大值都不能使该状态成为最大似然估计路径上的节点的话，那么该节点的其他更小的概率值（包括对应的路径）就更不可能了。 Viterbi算法通过一种有效的方法来分析HMM模型的观察序列，并捕获最可能的隐藏序列，利用递归的方法减少计算量，并且对于观察序列的整个上下文都进行了很好的考虑，对包含噪音的序列也能进行良好的分析。 Viterbi算法详细过程 该部分内容主要参考52nlp上关于HMM的详细讲解，整理一遍便于自己详细理解。 如上文所说，通过暴力枚举的方法来找到最可能的序列的代价是非常昂贵的，因此Viterbi算法考虑用递归的方式来寻找最有可能的隐藏状态序列。所以，我们首先定义局部概率 $\delta​$ ，表示到达网格中的某个中间状态时的概率值，之后来详细了解如何在$t=1​$和$t=n (n&gt;1)​$时如何计算其局部概率值。 定义局部概率和局部最佳路径 观察上图的网格，显示的是汉字对于观察序列（拼音序列）的一阶转移情况。对于网格中的每一个中间及终止状态，都有一个可以到达该状态的最可能路径。比如，在$t=3​$时刻的三个状态中，每一个都有一条到达该状态的最可能路径，可能如下图所示： 这些路径即为局部最佳路径，而每条局部最佳路径的概率值即为局部概率$\delta​$，用$ \delta(i,t)​$表示在 $t​$ 时刻到达状态 $i​$ 的所有路径概率中最大的概率值，局部最佳路径即对应该最大概率值的隐藏状态序列。基于此可知，在 $t=T​$ 时刻，每个状态都有一个局部概率及相应的局部最佳路径，因此，可以通过选择该时刻局部概率值最大的状态（及其对应的最佳路径）来确定全局最佳路径，即全局最佳隐藏状态序列。 计算$t=1$时刻的局部概率局部概率指到达该状态时的最佳路径的概率值，当$t=1​$时，该路径是不存在的，因此，用$t=1​$时刻所处状态的初始概率值及相应观察状态的转移概率值来计算$t=1​$时的局部概率，即： \delta _1(i)=\pi (i)b_{io_1}计算$t&gt;1$时刻的局部概率考虑如图所示的网格： 计算 $t$ 时刻到达状态 $X$ 的最佳路径，显然，这条最佳路径一定会通过 $t-1$ 时刻的状态 $A$、$B$、$C$ 之中的某一个。也就是说，到达状态 $X$ 的最佳路径一定是路径(状态序列），...，A，X、（状态序列），...，B，X、（状态序列），...，C，X三条之中的一条。 我们知道在一阶马尔科夫假设下，状态 $X$ 在一个状态序列之后发生的概率只取决于之前的一个状态，也就是说，路径末端是 $AX$ 的最佳路径将是到达 $A$ 的最佳路径再紧跟 $X$ ，那么这条路径的概率即为：$P(到达状态A的最佳路径)\times P(X|A)\times P(观察状态|X)$。 由此可知，到达状态 $X$ 的最佳路径概率计算方式为： P(X\ at\ time\ t)=\max_{i=A,B,C}P(i\ at\ time\ (t-1))\times P(X|i)\times P(obs\ at\ time\ t|X)其中，$P(i at time (t-1))​$是$t-1​$时刻的局部概率$\delta​$，$P(X|i)​$是状态转移概率（隐藏状态到观察状态的发射概率），$P(obs at time t|X)​$是观察概率。 对上述公式进行泛化可知，在 $t​$ 时刻，观察状态是 $k_t​$ ，到达隐藏状态 $i​$ 最佳局部路径概率为： \delta _t(i)=\max \limits_j(\delta _{t-1}(j)\times a_{ji}\times b_{io_t})我们假设前一个状态的局部概率已知，同时利用状态转移概率和对应的观察概率，就可以从中选择当前状态的最大概率了（局部概率 $\delta$ ）。 使用反向指针记录最佳路径 考虑上图的网格，经过前面的过程我们已经得到了每个状态的局部概率，但我们最终的目标是希望得到网格中的最佳隐藏序列，也就是说，最终的目标是需要得到网格中的局部最佳路径。 回顾之前我们得到局部概率的过程，$t$ 时刻的局部概率是通过 $t-1$ 时刻的局部概率得到的，也就是说，在计算得到 $t$ 时刻的局部概率 $\delta _t(i)$ 之后，我们就可以知道这个局部概率 $\delta _t(i)$ 是由 $t-1$ 时刻的哪一个状态而得到的。因此，在这个过程中，我们通过给每一个状态赋予一个反向指针 $\psi$ 来记录，这个指针指向导致当前状态最优概率的前一时刻的某个状态。 反向指针在形式上的公式如下： \psi _t(i)=argmax_j(\delta _{t-1}(j)a_{ji})这个反向指针的表达式是通过转移概率（某时刻的隐藏状态，演变到下一时刻某个隐藏状态的概率）以及前一时刻的局部概率计算得到的，没有使用到观察概率（隐藏状态到观察状态的发射概率）。 经过上述过程，已经可以通过递归的方式得到网格中每个状态的最佳局部概率，以及相应的局部最佳路径。 在使用Viterbi算法的过程中，我们对于网格中的每一个状态都计算一个局部概率，同时包含一个反向指针来指向最可能到达该状态的路径。当完成整个计算过程之后，我们首先在终止状态找到最可能的状态，之后通过反向指针回溯到初始时刻，从而回溯路径对应的状态序列就是我们最终得到的最佳的隐藏状态序列了。 Viterbi算法形式化表达及计算流程上文对Viterbi算法的流程做了详细的梳理，现在来总结一下Viterbi算法的形式化定义及完整流程： 输入：HMM模型 $\lambda =(A,B,\pi)$ ，观察序列 $O=(o_1,o_2,…o_T)$ ； 输出：最有可能的隐藏状态序列 $I^*=\lbrace i_1^*,i_2^*,…i_T^*\rbrace$ ； 算法流程： 初始化局部状态（$t=1$）： \delta _1(i)=\pi _ib_{io_1}\ ,\ i=1,2,...N \psi _1(i)=0\ ,\ i=1,2,...N其中， $N​$ 表示隐藏状态的长度，在拼音转汉字的过程中对应汉字的长度。 这一步通过观察状态的初始概率，和对应的观察状态到隐藏状态的发射概率，得到初始时刻的局部概率。 递推，通过动态规划递推时刻 $t=2,3,…T$ 时刻的局部状态（$t&gt;1$）： \delta _t(i)=\max_{1\leq j\leq N}[\delta _{t-1}(j)a_{ji}]b_{io_t}\ ,\ i=1,2,...N \psi _t(i)=\arg\max _{1\leq j\leq N}[\delta _{t-1}(j)a_{ji}]\ ,\ i=1,2,...N其中，$i$ 表示当前时刻隐藏序列的各个状态，$j$ 表示前一时刻隐藏序列的各个状态。 当前状态节点的选取，是通过考虑所有的转移概率，包括当前的发射概率，以及前一时刻的局部概率，综合计算，最后记录最大值，同时也记录了最大概率对应的前一时刻的状态节点。 终止： P^*=\max _{1\leq i\leq N}\delta _T(i) i_T^*=\arg \max _{1\leq i\leq N}[\delta _T(i)]计算终止时刻 T 时刻最大的概率值$\delta _T(i)$，即为最佳隐藏状态序列出现的概率，计算终止时刻 T 时刻最大的$\psi _t(i)$，即为最佳的隐藏状态。 回溯最优路径，对$t=T-1,T-2,…,1$： i_t^*=\psi _{t+1}(i_{t+1}^*)按照此过程回溯整个网格，回溯完成时，就得到了生成给定观察序列的最可能的隐藏状态序列 $I^*=(i_1^*,i_2^*,…i_T^*)$。 Viterbi算法代码实现C++版 主要参考umdhmm代码实现。 HMM模型结构定义如下： 12345678910typedef struct &#123; int N; /* number of hidden states; Q=&#123;1,2,...,N&#125; */ int M; /* number of observation symbols; V=&#123;1,2,...,M&#125;*/ double **A; /* A[1..N][1..N]. a[i][j] is the transition prob of going from state i at time t to state j at time t+1 */ double **B; /* B[1..N][1..M]. b[j][k] is the probability of of observing symbol k in state j */ double *pi; /* pi[1..N] pi[i] is the initial state distribution. */&#125; HMM; Viterbi算法主流程实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void Viterbi(HMM *phmm, int T, int *O, double **delta, int **psi, int *q, double *pprob)&#123; int i, j; /* state indices */ int t; /* time index */ int maxvalind; double maxval, val; /* 1. Initialization */ for (i = 1; i &lt;= phmm-&gt;N; i++) &#123; delta[1][i] = phmm-&gt;pi[i] * (phmm-&gt;B[i][O[1]]); psi[1][i] = 0; &#125; /* 2. Recursion */ for (t = 2; t &lt;= T; t++) &#123; for (j = 1; j &lt;= phmm-&gt;N; j++) &#123; maxval = 0.0; maxvalind = 1; for (i = 1; i &lt;= phmm-&gt;N; i++) &#123; val = delta[t-1][i]*(phmm-&gt;A[i][j]); if (val &gt; maxval) &#123; maxval = val; maxvalind = i; &#125; &#125; delta[t][j] = maxval*(phmm-&gt;B[j][O[t]]); psi[t][j] = maxvalind; &#125; &#125; /* 3. Termination */ *pprob = 0.0; q[T] = 1; for (i = 1; i &lt;= phmm-&gt;N; i++) &#123; if (delta[T][i] &gt; *pprob) &#123; *pprob = delta[T][i]; q[T] = i; &#125; &#125; /* 4. Path (state sequence) backtracking */ for (t = T - 1; t &gt;= 1; t--) q[t] = psi[t+1][q[t+1]];&#125; 基于HMM实现拼音输入法主流程在拼音输入法的主要过程中，HMM模型可以通过以下过程得到： 对训练数据的所有内容按照单字分词，并统计每个词出现的频率，以此作为初始概率 $\pi​$ ; 将训练数据的所有汉字都转换成对应的拼音，统计每个拼音对应的汉字以及各自出现的频率，以此作为发射概率 $B​$ ; 统计训练数据中每个汉字后面出现的汉字的频率，以此作为隐藏状态的转移概率 $A$ ; 经过上述过程，即可得到一个隐马尔科夫模型 $\lambda(\pi,A,B)$ 。 在此基础上，使用Viterbi算法，对用户输入的拼音序列进行解码，即可得到最终的汉字序列。 在实际应用过程中，对于一些转移概率为0的情况，可以默认设置一个较小的转移概率来避免计算结果为0的情况；同时，对于未登录词，也可以通过设置较小的初始概率来解决概率为0的问题。 1. http://www.52nlp.cn/hmm-learn-best-practices-four-hidden-markov-models &#8617;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>HMM</tag>
        <tag>隐马</tag>
        <tag>Viterbi</tag>
        <tag>拼音输入法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Real Hello World]]></title>
    <url>%2F2019%2F02%2F27%2FmyHello%2F</url>
    <content type="text"><![CDATA[This is my real hello world from hexo. **Lesley Shi**]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
