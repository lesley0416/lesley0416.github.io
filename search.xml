<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【LeetCode】21、合并两个有序链表]]></title>
    <url>%2F2019%2F03%2F26%2Fleetcode_21%2F</url>
    <content type="text"><![CDATA[21、Merge Two Sorted Lists合并两个有序链表 难度：简单 题目描述 英文： Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 中文： 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路思路一递归思路，比较头结点，保留较小值，再合并后续内容。 代码提交 C++，用时8ms，内存9M 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1==NULL) return l2; if (l2==NULL) return l1; if (l1-&gt;val&lt;l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 进行Recursion探索时完成的，其他解法后续补充。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】779、第k个语法符号]]></title>
    <url>%2F2019%2F03%2F26%2Fleetcode_779%2F</url>
    <content type="text"><![CDATA[21、K-th Symbol in Grammar第k个语法符号 难度：中等 题目描述 英文： On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). 中文： 在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。 给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始） 示例 Example: 1234567891011121314151617Input: N = 1, K = 1Output: 0Input: N = 2, K = 1Output: 0Input: N = 2, K = 2Output: 1Input: N = 4, K = 5Output: 1Explanation:row 1: 0row 2: 01row 3: 0110row 4: 01101001 注意 N 的范围 [1, 30]. K 的范围 [1, 2^(N-1)]. 解题思路思路一递归思路。 整个结构可以看做是一棵二叉树。 12345 0 / \ 0 1 /\ /\0 1 1 0 当一个节点是0的时候，两个子节点分别为0和1，当节点是1的时候，两个子节点分别为1和0。通过把K除以2，可以知道K的位置是左节点还是右节点。如果K是偶数，那么当前节点为右子节点，父节点是$N-1$行的第$K/2$个节点，如果K为奇数的话，则当前节点为左子节点。父节点是$N-1$行的第$(K+1)/2$个节点。 当前节点依赖于父节点，所以递归向前查找父节点，直至第一行结束。 代码提交 C++，用时4ms，内存8.1M 12345678910111213class Solution &#123;public: int kthGrammar(int N, int K) &#123; if (N==0) return 0; if (K%2 == 0) &#123; return kthGrammar(N-1, K/2)==0 ? 1:0; &#125; else &#123; return kthGrammar(N-1, (K+1)/2)==0 ? 0:1; &#125; &#125;&#125;; 进行Recursion探索时完成的，其他解法后续补充。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】50、Pow(x,n)]]></title>
    <url>%2F2019%2F03%2F25%2Fleetcode_50%2F</url>
    <content type="text"><![CDATA[50、Pow(x,n)Pow(x,n) 难度：中等 题目描述 英文： Implement pow(x, n), which calculates x raised to the power n(xn). 中文： 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 Example 1: 12Input: 2.00000, 10Output: 1024.00000 Example 2: 12Input: 2.10000, 3Output: 9.26100 Example 3: 123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range $[-2^{31},2^{31}-1]$ 解题思路思路一递归思路，直接用for循环让x乘以自己n次会超时。用递归的思路，对计算过程进行二分计算。每次把n缩小一半，直至n缩小为0。任何数的0次方都为1，这是终止条件。如果n是偶数，返回值算个平方返回即可，如果n是奇数，则平方之后再乘以一次x。 需要注意的是，n可能为负数，如果n是负数的话，就先用绝对值计算，再对结果取倒数。 但按上述思路简单实现后，对于负2的31次方这个测试用例，由于绝对值超过整型最大值，所以溢出了。所以换一种写法，在每次递归中都处理n的正负，然后做相应的变换。 代码提交 C++，用时8ms，内存10M 12345678910class Solution &#123;public: double myPow(double x, int n) &#123; if (n == 0) return 1; double half = myPow(x, n / 2); if (n % 2 == 0) return half * half; if (n &gt; 0) return half * half * x; return half * half / x; &#125;&#125;; 进行Recursion探索时完成的，其他解法后续补充。 思路二用迭代的方法，将i初始化为n，看i是否是2的倍数，如果是，则x乘以自己即可，如果不是，则temp要再乘以x，i逐次减半，直到为0停止循环。最后看n的正负，并做相应处理。 代码提交 C++，用时8ms，内存10M 1234567891011class Solution &#123;public: double myPow(double x, int n) &#123; double res = 1.0; for (int i = n; i != 0; i /= 2) &#123; if (i % 2 != 0) res *= x; x *= x; &#125; return n &lt; 0 ? 1 / res : res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>数学</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】104、二叉树的最大深度]]></title>
    <url>%2F2019%2F03%2F25%2Fleetcode_104%2F</url>
    <content type="text"><![CDATA[104、Maximum Depth of Binary Tree二叉树的最大深度 难度：简单 题目描述 英文： Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. 中文： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例 Example： Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. 解题思路思路一递归思路，最大深度等于左节点和右节点最大深度的较大值加1。 C++，用时16ms，内存19M 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root==NULL) return 0; if (root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return 1; int leftDepth = maxDepth(root-&gt;left); int rightDepth = maxDepth(root-&gt;right); if (leftDepth &gt; rightDepth) &#123; return leftDepth+1; &#125; else &#123; return rightDepth+1; &#125; &#125;&#125;; 进行Recursion探索时完成的，其他解法后续补充。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】509、斐波那契数]]></title>
    <url>%2F2019%2F03%2F25%2Fleetcode_509%2F</url>
    <content type="text"><![CDATA[509、Fibonacci Number斐波那契数 难度：简单 题目描述 英文： The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0and 1. That is, 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), for N &gt; 1. Given N, calculate F(N). 中文： 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 给定 N，计算 F(N)。 示例 Example 1: 123Input: 2Output: 1Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: 123Input: 3Output: 2Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: 123Input: 4Output: 3Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. 提示 0 ≤ N ≤ 30 解题思路思路一使用递归方法。 代码提交 Python，用时20ms，内存11.8M 123456789101112131415161718192021class Solution(object): def fib(self, N): """ :type N: int :rtype: int """ cache = &#123;&#125; def recur_fib(N): if N in cache: return cache[N] if N &lt; 2: result = N else: result = recur_fib(N-1) + recur_fib(N-2) # put result in cache for later reference. cache[N] = result return result return recur_fib(N) 使用decorator模式做递归方法中的缓存计算。 Python，用时20ms，内存12.1M 123456789101112131415161718192021from functools import wrapsclass Solution(object): def cache(func): caches = &#123;&#125; @wraps(func) def wrap(*args): if args not in caches: caches[args] = func(*args) return caches[args] return wrap @cache def fib(self, n): """ :type N: int :rtype: int """ if n &lt; 2: return n return self.fib(n-1) + self.fib(n-2) 进行Recursion探索时完成的，其他解法后续补充。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>数组</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——decorator]]></title>
    <url>%2F2019%2F03%2F25%2Fdecorator_python%2F</url>
    <content type="text"><![CDATA[后续补充]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>decorator</tag>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】206、反转链表]]></title>
    <url>%2F2019%2F03%2F22%2Fleetcode_206%2F</url>
    <content type="text"><![CDATA[206、Reverse Linked List反转链表 难度：简单 题目描述 英文： Reverse a singly linked list. 中文： 反转一个单链表。 示例 Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路递归解决方法的视频讲解Reverse a Linked List Recursively 思路一 参考讨论区的一种做法。 时间复杂度O(N)，空间复杂度O(1) 这里给出两种方法：迭代法（循环），递归方法。 两种方法的思路都是一样的。如下所示 …&lt;-x&lt;-x&lt;-x&lt;-x&lt;-pre || cur-&gt;y-&gt;y-&gt;y-&gt;y… 将整个链表分成两个部分；前半部分链表，后半部分链表 pre为已经 反转 好的部分链表的头节点； cur为当前仍然没有反转部分链表的头节点； 我们当前需要做的事情就是将cur节点加入到前半部分的链表中，直到右边的链表全部加入到左边的链表中即可。 用递归的思想理解4很容易。 代码提交递归方法 C++，用时8ms，内存9M 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverse(ListNode* pre, ListNode* cur) &#123; if (cur-&gt;next == NULL) &#123; // 递归结束的判断 cur-&gt;next = pre; return cur; &#125; ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; return reverse(pre, cur); &#125; ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL, *cur = head; return head ? reverse(pre, cur) : head; // 如果head为空的话，我们直接返回head/NULL &#125;&#125;; 迭代方法 C++，用时8ms，内存9.1M 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == NULL) return NULL; ListNode* pre = NULL, *cur = head, *next = head-&gt;next; while (cur-&gt;next) &#123; cur-&gt;next = pre; pre = cur; cur = next; next = next-&gt;next; &#125; cur-&gt;next = pre; return cur; &#125;&#125;; 思路二参考LeetCode上递归探索页给出的解决方案。 递归版，是从后往前来转变链表指针的方向；迭代版是从前往后来转变链表的方向。 代码提交1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; // 递归版 public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null)&#123; return head; &#125; ListNode newHead = reverseList(head.next); head.next.next = head; head.next = null; return newHead; &#125; // 迭代版 public ListNode reverseList1(ListNode head) &#123; if (head != null)&#123; ListNode p1 = null; ListNode next = null; ListNode p2 = head; while (p2 != null)&#123; next = p2.next; p2.next = p1; p1 = p2; p2 = next; &#125; return p1; &#125;else &#123; return head; &#125; &#125; &#125; 思路三参考网上的解法，巧妙利用Python的多元赋值，实现非常简洁。 具体的执行过程可参考下面的举例说明： 前置条件：迭代指针：p = head、结果指针：res = none 以1-&gt;2-&gt;3-&gt;4-&gt;5为例： 过程： res:None 第一层循环 res:1-&gt;2-&gt;3-&gt;4-&gt;5 res = p res:1-&gt;None res.next = res p:2-&gt;3-&gt;4-&gt;5 p = p.next 第二层循环 res:2-&gt;3-&gt;4-&gt;5 res = p res:2-&gt;1-&gt;None res.next = res p:3-&gt;4-&gt;5 p = p.next 第三层循环 res:3-&gt;4-&gt;5 res = p res:3-&gt;2-&gt;1-&gt;None res.next = res p:4-&gt;5 p = p.next 第四层循环 res:4-&gt;5 res = p res:4-&gt;3-&gt;2-&gt;1-&gt;None res.next = res p:5 p = p.next 第五层循环 res:5 res = p res:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;None res.next = res p:None p = p.next end… 代码提交 Python，用时32ms，内存12.7M 1234567891011121314151617# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ L = ListNode(float("-inf")) while head: # 把当前 L.next （如 [2,1]）内容临时保存起来，然后把head此时剩下的内容（如 [3,4,5]）赋给L （变成[3,4,5]），再把之前保存的L.next接回来（L变成[3,2,1]），最后head后移一步 L.next, head.next, head = head, L.next, head.next return L.next]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>链表</tag>
        <tag>多元赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】119、杨辉三角2]]></title>
    <url>%2F2019%2F03%2F22%2Fleetcode_119%2F</url>
    <content type="text"><![CDATA[119、Pascal’s Triangle II杨辉三角2 难度：简单 题目描述 英文： Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle. Note that the row index starts from 0. 中文： 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例 Example: 12Input: 3Output: [1,3,3,1] 进阶 你可以优化你的算法到 O(k) 空间复杂度吗？ 解题思路思路一 进行Recursion探索时完成的，其他解法后续补充。 递归关系 我们从定义杨辉三角的递归关系开始。 首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下： f(i,j)=f(i-1,j-1)+f(i-1,j)基本情况 在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1. 所以，我们可以定义基本情况如下： f(i,j)=1\qquad where\qquad j=1\ or\ j=i 代码没有完全对应Recursion相应位置的方法，实现过程中，采用自底向上的方法，保存前一行的中间结果。 代码上注意一下，此处的rowIndex从0开始。 代码提交 C++，用时4ms，内存8.3M 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; temp; temp.push_back(1); if (rowIndex == 0) &#123; return temp; &#125; vector&lt;int&gt; result; for (int row = 1; row &lt;= rowIndex; row++) &#123; result.clear(); for (int col = 0; col &lt;= row; col++) &#123; if (col == 0 || col == row) &#123; result.push_back(1); &#125; else &#123; result.push_back(temp[col - 1] + temp[col]); &#125; &#125; temp = result; &#125; return result; &#125;&#125;; 思路二和思路一类似，先开辟一个大小为$k$的空间，保留每次前一行的中间结果，在其基础上直接修改获取当前行的结果。 修改过程中，先填充当前行的末尾值（比前一行最末的位置+1位），然后从右往左依次修改，当前行位置为$j$的值，仅依赖于上一行位置为$j-1$和$j$的值，所以，逆序修改的过程中，改掉的值都是下一步计算不再需要的值。 代码提交 C++，用时4ms，内存8.3M 12345678910111213class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex + 1); // 长度为K，默认值为0 res[0] = 1; for (int i = 1; i &lt;= rowIndex; ++i) &#123; // 从第1行开始（从0开始数）计算每一行的参数 for (int j = i; j &gt;= 1; --j) &#123; res[j] += res[j - 1]; // 更新j位置上的数为上一行的j-1位置与j位置的数的和，最末端为 0+上一行最末端 &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】118、杨辉三角]]></title>
    <url>%2F2019%2F03%2F22%2Fleetcode_118%2F</url>
    <content type="text"><![CDATA[118、Pascal’s Triangle杨辉三角 难度：简单 题目描述 英文： Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle. 中文： 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例 Example: 123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解题思路思路一 进行Recursion探索时完成的，其他解法后续补充。 递归关系 我们从定义杨辉三角的递归关系开始。 首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下： f(i,j)=f(i-1,j-1)+f(i-1,j)基本情况 在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1. 所以，我们可以定义基本情况如下： f(i,j)=1\qquad where\qquad j=1\ or\ j=i 代码没有完全对应Recursion相应位置的方法，实现过程中，采用自底向上的方法，保存计算过的中间结果，避免了重复计算。 代码提交 C++，用时4ms，内存8.8M 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (numRows &lt;= 0) return result; vector&lt;int&gt; temp; if (numRows == 1) &#123; temp.push_back(1); result.push_back(temp); return result; &#125; temp.push_back(1); result.push_back(temp); for (int row = 1; row &lt; numRows; row++) &#123; temp.clear(); for (int col = 0; col &lt;= row; col++) &#123; if (col == 0 || col == row) &#123; temp.push_back(1); &#125; else &#123; temp.push_back(result[row - 1][col - 1] + result[row - 1][col]); &#125; &#125; result.push_back(temp); &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】24、两两交换链表中的节点]]></title>
    <url>%2F2019%2F03%2F21%2Fleetcode_24%2F</url>
    <content type="text"><![CDATA[24、Swap Nodes in Pairs两两交换链表中的节点 难度：中等 题目描述 英文： Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. 中文： 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 解题思路思路一 进行Recursion探索时完成的，其他解法后续补充。 定义函数swap(head)，其中输入参数head表示链表的头结点。函数应该返回相邻节点交换后的新链表的头结点。 按如下步骤实现这个函数： 首先，我们交换链表的前两个节点，即head和head.next； 然后，我们递归调用函数swap(head.next.next)来处理链表的剩余部分； 最后，获得步骤2返回的子链表的头结点，并将其和步骤1的新链表相连接； 代码提交 C++，用时4ms，内存9M 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode *t = head-&gt;next; head-&gt;next = swapPairs(head-&gt;next-&gt;next); t-&gt;next = head; return t; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】344、反转字符串]]></title>
    <url>%2F2019%2F03%2F21%2Fleetcode_344%2F</url>
    <content type="text"><![CDATA[344、Reverse String反转字符串 难度：简单 题目描述 英文： Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters. 中文： 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 Example 1: 12Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] Example 2: 12Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 解题思路思路一递归思路，不使用额外空间，从首尾两端开始交换字符，并依次向内部缩小，直至交换到数组中间位置时结束。 用$s[x_i,…,x_j]$表示字符数组，其中$x_i , x_j$表示数组中的字符内容，$i,j$为对应的位置，则： s[x_i,...,x_j]= \begin{cases} s[x_i,...x_j], & \text{if $i>=j$}\\ s[x_j,...x_i], & \text{if $i]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】Explore：Recursion I 递归—1]]></title>
    <url>%2F2019%2F03%2F21%2Fleetcode_explore_recursion%2F</url>
    <content type="text"><![CDATA[主要翻译自LeetCode上Explore模块的Recursion I，有直译，也有非直译的个人理解。 其中涉及的题目附有相应的解答。 Overview 综述Recursion（递归）是计算机科学中一个重要的概念，是很多算法和数据结构的基础。但是对于很多初学者都比较难把握。 在开始本节探索之前，我们强烈建议先完成二叉树和堆栈两个探索页。 在这个探索页，我们将回答以下几个问题： 什么是recursion？它是如何工作的？ 如何递归的解决一个问题？ 如何分析递归算法的时间和空间复杂度（time and space complexity）？ 如何更好的应用递归？ 完成本探索页后，你在解决递归问题和分析复杂度时会变得更加自信。 一、Principle of Recursion 递归原理在这章，我们将会： 解释递归的基本概念； 演示如何应用递归解决确切的问题； 最后提供一些练习题来练习递归； 递归原理 递归是一种将函数本身作为子程序调用来解决问题的方法。 你可能想知道一个函数怎样调用其自身。诀窍在于每次递归的调用其本身时，都将给定的问题缩小成其子问题，这样持续的递归调用，直到子问题可以不用递归就能解决的时候停止。 一个递归函数应该有以下属性，这样才不会导致无限循环： 具有简单的基本情况，即递归出口、递归结束条件，即不使用递归即可获得答案的情况； 一系列规则，称为recurrence relation递归关系，可以将问题逐步缩小直至递归出口； 注意，可能会有多个可以调用函数本身的地方。 示例从一个简单的问题开始：逆序输出字符串。 倒序输出一个字符串。 你可以很容易的迭代解决这个问题，例如从字符串的结尾开始遍历字符串。但是如何递归的解决呢？ 首先，我们定义函数printReverse(str[0...n-1])，其中str[0]表示字符串的第一个字符，然后我们通过以下两个步骤解决这个问题： printReverse(str[1...n-1])：逆序输出子串strp[1...n-1]； print(str[0])：输出字符串的首字符； 我们在第一步中定义了递归关系。 代码如下（C++）： 123456void printReverse(const char *str) &#123; if (!*str) return; printReverse(str+1); cout &lt;&lt; *str;&#125; 接下来，来处理一个和示例略有不同的练习，尽量用递归来解决。 练习：反转字符串【LeetCode】344、Reverse String 写一个反转字符串的函数，输入字符数组char[]。 不要开辟额外的控件，必须使用$O(1)​$的空间复杂度就地修改输入的数组。 假定所有的字符都是可打印的ASCII码字符。 Example 1: 12Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] Example 2: 12Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 递归代码如下（自己写的，C++）： 1234567891011121314151617181920class Solution &#123;public: void swap(vector&lt;char&gt;&amp; s, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; char temp = s[left]; s[left] = s[right]; s[right] = temp; swap(s, left+1, right-1); return; &#125; void reverseString(vector&lt;char&gt;&amp; s) &#123; if (s.size() &lt;= 1) return; swap(s, 0, s.size()-1); return; &#125;&#125;; 解答：反转字符串本章，我们给出反转字符串问题的一个简单的解决方案。 问题并不难，关键在于有一个额外的约束条件，即使用$O(1)$的额外空间进行修改。 定义函数reverseString(str[0...n-1])，其中str[0...n-1]是一个首字符为str[0]的字符数组。 下面，我们讨论如何利用递归的思想来解决这个问题。 初次尝试如果我们按照上文逆序输出字符串的思路，我们可以有以下的方法： 从输入字符串中取首字符str[0]； 对于剩下的子字符串，调用函数自身来递归解决，如reverseString(str[1...n-1])； 在步骤2返回的结果中添加首字符； 这个方法可以实现题意效果，但是不满足约束条件。因为需要额外的空间来保存步骤2的中间结果，所需空间大小和字符串长度成正比（即需要$O(n)$的空间复杂度），这一点不满足$O(1)$空间复杂度的要求。 另一种分治的方法考虑题目中的约束条件，将其放入到递归的问题中，可以理解为在两次连续的递归调用之间不使用额外的空间消耗，也就是说，我们应该把问题分解成独立的子问题。 分解成独立子问题的一个思路是将每次输入的字符串分成两部分：1、首尾字符；2、去掉首位字符后剩下的子字符串。然后可以独立的解决两部分内容。 按照上述方法，可以有以下的方法： 从输入的字符串中取首尾字符str[0]和str[n-1]； 就地交换首尾字符； 递归调用函数来反转剩余的子字符串，即reverseString(str[1...n-2])； 注意：步骤2、3可以交换，因为是两个独立的任务。但最好保持现状的顺序，这样可以使用尾递归优化调用。我们会在后面的章节详细了解尾递归。（先简单理解一下，尾递归是指函数运行的最后一步是调用其自身，尾递归由于递归在最后一步，不再需要考虑外层函数的信息，因此可以把这个函数的调用栈给优化掉，从而避免栈溢出的风险。） 代码如下（示例代码，Python3）： 12345678910111213141516class Solution: def reverseString(self, s): """ :type s: List[str] :rtype: void Do not return anything, modify s in-place instead. """ def helper(start, end, ls): if start &gt;= end: return # swap the first and last element ls[start], ls[end] = ls[end], ls[start] return helper(start+1, end-1, ls) helper(0, len(s)-1, s) 如图，用字符数组[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]举例，可以看到如何进行分解并解决的。 使用这种方法，在每次递归调用的时候只需要常数级内存空间用来交换首尾字符即可，满足题目的约束条件。 递归函数对于一个问题而言，如果可以用递归的思路来解决的话，那我们一定可以遵循如下的思路来实现。 举例来说，我们用一个待实现的函数$F(X)$来表示问题，其中$X$表示函数的输入，也就是问题的范围。 那么，在函数$F (X)$中，我们将做如下操作： 把问题分解为更小的范围，如$x_0\in X , x_1\in X , … , x_n\in X$； 递归调用函数$F(x_0),F(x_1),…,F(x_n)$来解决$X$的子问题； 最后，处理递归调用的结果，从而解决$X$对应的问题； 举例通过递归解决另一个问题来展示上述思路。 给定一个链表，交换其中每两个相邻节点，并返回头结点。 例如：给定列表1-&gt;2-&gt;3-&gt;4，应该返回交换后的列表2-&gt;1-&gt;4-&gt;3的头结点。 定义函数swap(head)，其中输入参数head表示链表的头结点。函数应该返回相邻节点交换后的新链表的头结点。 按照上述思路，我们可以按如下步骤实现这个函数： 首先，我们交换链表的前两个节点，即head和head.next； 然后，我们递归调用函数swap(head.next.next)来处理链表的剩余部分； 最后，获得步骤2返回的子链表的头结点，并将其和步骤1的新链表相连接； 作为练习，可以按照上文提供的步骤试着实现该问题的完整代码。 练习：两两交换链表中的节点详见【LeetCode】24、Swap Nodes in Pairs Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 代码如下（C++，用时4ms，内存9M）： 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode *t = head-&gt;next; head-&gt;next = swapPairs(head-&gt;next-&gt;next); t-&gt;next = head; return t; &#125;&#125;; 二、Recurrence Relation 递归关系上一章我们了解了递归的基本概念。 在实现递归函数之前，有两个重要的点需要注意：基本情况和递归关系。 在这章，我们将： 通过详细的例子来了解如何定义基本情况和递归关系； 做一些练习； 递归关系在实现递归函数之前，要注意两个重要的点： 递归关系：总问题结果和子问题结果之间的关系； 基本情况：不需要继续递归调用就能够计算结果的情况，就是递归结束情况。（有时基本情况也被叫做bottom cases，因为如果我们用自顶向下的方式对问题进行分解的话，那么基本情况通常出现在问题已经被分解到最小范围的时候，即bottom） 一旦我们有了上述两方面内容，那么我们只需要按照递归关系不断的调用函数本身，直到到达基本情况。 为了解释上述内容，我们来看一个经典问题：杨辉三角（也叫 帕斯卡三角）。 杨辉三角是由一系列数字组成的三角形。其中，每一行的最左边和最右边永远是1，剩余的其他数字，每个数是其上面两个数的和。 示例：杨辉三角下图是一个五层的杨辉三角示意图： 基于以上定义，我们的问题就是生成指定层数的杨辉三角。 递归关系 我们从定义杨辉三角的递归关系开始。 首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下： f(i,j)=f(i-1,j-1)+f(i-1,j)基本情况 在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1. 所以，我们可以定义基本情况如下： f(i,j)=1\qquad where\qquad j=1\ or\ j=i示例 可以看到，一旦定义了递归关系和基本情况之后，就可以很直观的实现递归函数了，特别是定义好数学公式以后。 如下是应用上述公式计算$f(5,3)$，即第5行第3列的值的过程。 要计算$f(5,3)$，我们按照递归关系将问题分解$f(5,3)=f(4,2)+f(4,3)$，之后递归计算$f(4,2)$和$f(4,3)$的值： 对于$f(4,2)$，我们可以继续分解，直至基本情况，如下所示： f(4,2)=f(3,1)+f(3,2)=f(3,1)+(f(2,1)+f(2,2))=1+(1+1)=3 对于$f(4,3)$，同样的，我们可以将其分解如下： f(4,3)=f(3,2)+f(3,3)=(f(2,1)+f(2,2))+f(3,3)=(1+1)+1=3 最后我们组合上述子问题的结果： f(5,3)=f(4,2)+f(4,3)=3+3=6 下一步 在上面的示例中，可以注意到在递归解决方案中有一些重复的计算，就是说，我们为了计算最后一行的值，重复的计算了很多中间结果。例如，为了计算$f(5,3)$，我们在计算$f(4,2)$和$f(4,3)$的过程中重复计算了两边$f(3,2)$的值。 我们将在下一章讨论如何避免这些重复计算。 按照本章的内容，可以做一些和杨辉三角相关的练习题。 详见【LeetCode】118、杨辉三角，【LeetCode】119、杨辉三角2，【LeetCode】206、反转链表。 练习：杨辉三角Pascal’s Triangle Given a non-negative integer numRows, generate the first numRowsof Pascal’s triangle. 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 代码如下（C++，用时4ms，内存8.8M）： 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (numRows &lt;= 0) return result; vector&lt;int&gt; temp; if (numRows == 1) &#123; temp.push_back(1); result.push_back(temp); return result; &#125; temp.push_back(1); result.push_back(temp); for (int row = 1; row &lt; numRows; row++) &#123; temp.clear(); for (int col = 0; col &lt;= row; col++) &#123; if (col == 0 || col == row) &#123; temp.push_back(1); &#125; else &#123; temp.push_back(result[row - 1][col - 1] + result[row - 1][col]); &#125; &#125; result.push_back(temp); &#125; return result; &#125;&#125;; 练习：杨辉三角2Pascal’s Triangle II Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle. Note that the row index starts from 0. Example: 12Input: 3Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O(k) extra space? 代码如下（C++，用时4ms，内存8.3M）： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; temp; temp.push_back(1); if (rowIndex == 0) &#123; return temp; &#125; vector&lt;int&gt; result; for (int row = 1; row &lt;= rowIndex; row++) &#123; result.clear(); for (int col = 0; col &lt;= row; col++) &#123; if (col == 0 || col == row) &#123; result.push_back(1); &#125; else &#123; result.push_back(temp[col - 1] + temp[col]); &#125; &#125; temp = result; &#125; return result; &#125;&#125;; 练习：反转链表Reverse Linked List Reverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? 代码如下（C++，用时8ms，内存9M）： 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverse(ListNode* pre, ListNode* cur) &#123; if (cur-&gt;next == NULL) &#123; // 递归结束的判断 cur-&gt;next = pre; return cur; &#125; ListNode* next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; return reverse(pre, cur); &#125; ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL, *cur = head; return head ? reverse(pre, cur) : head; // 如果head为空的话，我们直接返回head/NULL &#125;&#125;; 解答：反转链表方法1、迭代法假设有链表$1\rightarrow 2\rightarrow 3\rightarrow \emptyset$，要将其转为$\emptyset \leftarrow 1\leftarrow 2\leftarrow 3$。 遍历链表，将当前节点的next指针指向其前一个节点。由于链表没有指向前一个节点的指针，所以需要提前保存前一个节点的信息。同时还需要一个指针，在改变next指向时用来保存当前next的节点。最后不要忘了返回新的头结点。 1234567891011public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while (curr != null) &#123; ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; &#125; return prev;&#125; 复杂度分析 时间复杂度：$O (n)$。$n$是链表长度。 空间复杂度：$O (1)$。 方法2、递归法递归方法要考虑回退工作，略难一点。假设链表的剩余部分已经反转好了，怎么反转其前半部分呢？ 对于链表$n_1\rightarrow …\rightarrow n_{k-1} \rightarrow n_k \rightarrow n_{k+1} \rightarrow … \rightarrow n_m \rightarrow \emptyset​$，假设从节点$n_{k+1}​$到节点$n_m​$已经反转好了，并且当前在节点$n_k​$处：$n_1 \rightarrow … \rightarrow n_{k-1} \rightarrow \mathbf{n_k} \rightarrow n_{k+1} \leftarrow … \leftarrow n_m​$。 我们想让$n_{k+1}$的下一个节点指向$n_k$，所以：$n_k .next.next=n_k$。 要注意的是$n_1$节点的next必须指向$\emptyset​$。如果忽略这一步的话，那就把链表变成首尾相接的圆形的了。如果测试链表长度为2的情况，可能会触发这个bug。 1234567public ListNode reverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); // 保留头结点，递归反转剩余部分 head.next.next = head; // 把剩余部分的头结点指向到保留的头结点上，类似上文说的 n(k+1) 的next指向到 nk ，实现反转 head.next = null; // 把保留的头结点反转，指向空，即 n(k+1) 指向 nk 后，再将 nk 指向空 return p;&#125; 复杂度分析 时间复杂度：$O (n)$。$n$是链表长度。 空间复杂度：$O(n)$。额外的空间消耗来源于递归所需的隐藏的栈空间，递归最深为$n$层。 三、Memoization 缓存计算在上一章，我们提到过递归算法中的重复计算问题。在最好的情况下，重复计算只是会增加算法的时间复杂度，但是在最差的情况，重复计算会导致无限循环。 因此，在这章，我们将： 用一个例子开始，展示重复计算是如何导致的； 展示如何用缓存计算的技术来避免重复计算； 递归中的重复计算递归是实现算法的一种强有力的方法，但是如果不好好使用的话，也会带来额外的问题，如重复计算。例如，在上一章的后半部分，我们提到过杨辉三角中的重复计算问题，一些中间结果被反复计算了多次。 在这章，我们将进一步的讨论递归中可能发生的重复计算问题，并提出一种叫做缓存计算的常用技术手段来避免这个问题。 为了用另一个例子来演示重复计算问题，我们看一个大部分都熟悉的例子：斐波那契数列。如果我们定义函数$F(n)$来表示索引为$n$的斐波那契数，那可以得到如下所示的递归关系式： F(n)=F(n-1)+F(n-2)而基本情况（递归结束条件）为： F(0)=0\ ,\ F(1)=1有了斐波那契数的定义之后，可以按如下所示实现代码： 123456789def fibonacci(n): """ :type n: int :rtype: int """ if n &lt; 2: return n else: return fibonacci(n-1) + fibonacci(n-2) 现在，如果想计算$F(4)$，就可以按照上述公式来实现： F(4)=F(3)+F(2)=(F(2)+F(1))+F(2)可以看到，按照上述过程，为了计算$F(4)$的结果，我们需要计算两遍$F(2)$。 如图所示，用一棵树展示了在计算$F(4)​$的过程中进行的所有重复计算（用颜色分类）： 缓存计算为了尽可能多的消除上述情况中的重复计算，一个方法就是将中间结果保存在缓存中，这样下次遇到的时候就可以重复使用而不需要再次计算了。 这个方法就是缓存计算方法，是经常和递归一起使用的一种技术。 Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. (Source: wikipedia) 缓存计算是通过将高消耗的函数调用结果进行保存，并且在再次遇到相同输入的时候返回缓存结果，从而提升程序运行速度的一种优化技术。 回到斐波那契函数$F(n)$，我们可以用一个哈希表来跟踪每个$F(n)$的值，用$n$做key。哈希表作为缓存使我们避免重复计算。缓存技术是一个很好的用一些额外空间来换取时间减少的例子。 为了对比，我们提供了如下的用缓存计算实现的斐波那契数。 作为练习，可以通过更一般性的方法来实现缓存计算，即不改变原来的函数而应用缓存计算。（可以引用设计模式decorator） 关于decorator设计模式可参考设计模式——decorator 1234567891011121314151617181920def fib(self, N): """ :type N: int :rtype: int """ cache = &#123;&#125; def recur_fib(N): if N in cache: return cache[N] if N &lt; 2: result = N else: result = recur_fib(N-1) + recur_fib(N-2) # put result in cache for later reference. cache[N] = result return result return recur_fib(N) 使用decorator模式代码如下（自己实现）： 123456789101112131415161718192021from functools import wrapsclass Solution(object): def cache(func): caches = &#123;&#125; @wraps(func) def wrap(*args): if args not in caches: caches[args] = func(*args) return caches[args] return wrap @cache def fib(self, n): """ :type N: int :rtype: int """ if n &lt; 2: return n return self.fib(n-1) + self.fib(n-2) 在这章中，可以通过斐波那契数和爬楼梯问题来进行练习。 详见：【LeetCode】509、斐波那契数，【LeetCode】70、爬楼梯 在下一章，我们将深入讨论在递归算法中的复杂度分析。 练习：斐波那契数The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), for N &gt; 1. Given N, calculate F(N). Example 1: 123Input: 2Output: 1Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: 123Input: 3Output: 2Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: 123Input: 4Output: 3Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Note: 0 ≤ N ≤ 30. 代码如下（Python，用时20ms，内存11.8M）： 123456789101112131415161718192021class Solution(object): def fib(self, N): """ :type N: int :rtype: int """ cache = &#123;&#125; def recur_fib(N): if N in cache: return cache[N] if N &lt; 2: result = N else: result = recur_fib(N-1) + recur_fib(N-2) # put result in cache for later reference. cache[N] = result return result return recur_fib(N) 练习：爬楼梯You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: 12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2: 123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 代码如下（Python3，用时80ms，内存13.2M）： 12345678910class Solution: def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 if n == 2: return 2 tempNum = [0,1,2] for i in range(3, n+1): tempNum.append(tempNum[i-1] + tempNum[i-2]) return tempNum[n] 解答：爬楼梯 本节代码均为原网页给出的参考代码，均为Java实现。 方法1：暴力法暴力法就是计算所有可能的走法组合，也就是每一步爬1层和每一步爬两层。在每一步我们都调用函数$climpStairs$来计算爬一层和爬两层的结果，并返回两个函数返回值的和。 climbStairs(i,n)=climbStairs(i+1,n)+climbStairs(i+2,n)其中$i$表示当前层数，$n$表示目标层数。 代码如下： 1234567891011121314public class Solution &#123; public int climbStairs(int n) &#123; climb_Stairs(0, n); &#125; public int climb_Stairs(int i, int n) &#123; if (i &gt; n) &#123; return 0; &#125; if (i == n) &#123; return 1; &#125; return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n); &#125;&#125; 复杂度分析 时间复杂度：$O(2^n)$。递归树的大小是$2^n$。 如下所示为$n=5$时的递归树： 空间复杂度：$O(n)$。递归树的最大深度为$n$。 方法2：采用缓存计算的递归法在上一种方法中重复计算了很多中间结果。可以用一个memo数组将每一步的结果进行存储，当再次调用这个函数的时候可以直接从memo数组中返回结果。 通过这种使用memo数组来调整递归树的方法，可以将递归树的大小减少到$n$。 代码如下： 12345678910111213141516171819public class Solution &#123; public int climbStairs(int n) &#123; int memo[] = new int[n + 1]; return climb_Stairs(0, n, memo); &#125; public int climb_Stairs(int i, int n, int memo[]) &#123; if (i &gt; n) &#123; return 0; &#125; if (i == n) &#123; return 1; &#125; if (memo[i] &gt; 0) &#123; return memo[i]; &#125; memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo); return memo[i]; &#125;&#125; 复杂度分析 时间复杂度：$O(n)$。递归树的大小为$n$。 空间复杂度：$O(n)$。递归树的最大深度为$n$。 方法3：动态规划可以看到，这个问题可以分解成多个子问题，并且包含最优子结构性质，也就是说，这个问题的最优解可以通过其子问题的最优解来组合得到，所以我们可以采用动态规划方法来解决这个问题。 我们可以通过以下两种方法到达第$i$层： 在第$i-1$层走一步； 在第$i-2$层走两步； 所以，到达第$i$层的总方法数等于到达第$i-1$层的方法数和到达第$i-2$层的方法数的总和。 用$dp[i]$表示到达第$i$层所需的总方法数，则： dp[i]=dp[i-1]+dp[i-2]例如： 代码如下： 1234567891011121314public class Solution &#123; public int climbStairs(int n) &#123; if (n == 1) &#123; return 1; &#125; int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125; 复杂度分析 时间复杂度：$O(n)$。单层循环到$n$。 空间复杂度：$O(n)$。使用大小为$n$的$dp$数组。 方法4：斐波那契数法在上面的方法中使用了$dp$数组，并且$dp[i]=dp[i-1]+dp[i-2]$。可以很容易的联想到，$dp[i]$正是斐波那契数的第$i$个值： Fib(n)=Fib(n-1)+Fib(n-2)那么，我们只需要找到斐波那契数列的第$n$个值即可，其中前两个值分别为1和2，即$Fib(1)=1$，$Fib(2)=2$。 代码如下： 123456789101112131415public class Solution &#123; public int climbStairs(int n) &#123; if (n == 1) &#123; return 1; &#125; int first = 1; int second = 2; for (int i = 3; i &lt;= n; i++) &#123; int third = first + second; first = second; second = third; &#125; return second; &#125;&#125; 复杂度分析 时间复杂度：$O(n)$。计算第$n$个斐波那契数需要循环到$n$。 空间复杂度：$O(1)$。使用固定的空间。 方法5：Binets Method （比奈法？）使用矩阵的方法这是一个非常有趣的使用矩阵乘法来计算第$n$个斐波那契数的方法。矩阵形式如下： \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n-1} \end{bmatrix} = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}令$Q= \begin{bmatrix}F_{n+1} &amp; F_n \\ F_n &amp; F_{n-1} \end{bmatrix}​$。按照这个方法，第$n​$个斐波那契数可以由$Q^{n-1}[0,0]​$得到。 我们来看方法的证明： 可以使用数学归纳法来证明这个方法。我们知道，这个矩阵给出了第3个斐波那契数（基本情况）的正确结果，$Q^2= \begin{bmatrix}2 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}​$。这证明了基本情况是适用于这个方法的。 假设这个方法也适用于第$n$个斐波那契数的问题，即$F_n = Q^{n-1}[0,0]$，其中$Q^{n-1}= \begin{bmatrix} F_n &amp; F_{n-1} \\ F_{n-1} &amp; F_{n-2} \end{bmatrix}$。 现在，我们需要证明在上述两个条件为真的情况下，这个方法对于计算第$n+1​$个斐波那契数也是有效的，即证明$F_{n+1}=Q^n[0,0]​$。 证明过程： Q^n= \begin{bmatrix} F_{n} & F_{n-1} \\ F_{n-1} & F_{n-2} \end{bmatrix} \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix} = \begin{bmatrix} F_n+F_{n-1} & F_n \\ F_{n-1}+F_{n-2} & F_{n-1} \end{bmatrix} = \begin{bmatrix} F_{n+1} & F_n \\ F_n & F_{n-1} \end{bmatrix}所以，$F_{n+1}=Q^n[0,0]$。 至此，完成了这个方法的证明。 用这个方法解决爬楼梯问题所要做的唯一的改动就是，修改初始值为2和1（斐波那契数列的初始值是1和0）。或者，另一个方法是不修改初始值，而是使用相同的矩阵，但是用结果$result=Q^n[0,0]$来得到爬楼梯问题的第$n$层最终解。做这种调整的原因是因为爬楼梯问题使用的是斐波那契数列列的第2、3项做基本情况。 代码如下： 123456789101112131415161718192021222324252627 public class Solution &#123; public int climbStairs(int n) &#123; int[][] q = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; int[][] res = pow(q, n); return res[0][0]; &#125; public int[][] pow(int[][] a, int n) &#123; int[][] ret = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;&#125;; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) &#123; ret = multiply(ret, a); &#125; n &gt;&gt;= 1; a = multiply(a, a); &#125; return ret; &#125; public int[][] multiply(int[][] a, int[][] b) &#123; int[][] c = new int[2][2]; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; &#125; &#125; return c; &#125;&#125; 复杂度分析 时间复杂度：$O(\log(n))$。 空间复杂度：$O(1)$。使用固定的空间。 时间复杂度证明： 假设有一个$n$次幂的矩阵$M$，假设$n$是2的幂，那么$n=2^i , i \in \mathbb{N} $，其中$\mathbb {N}$表示自然数集合（包括0）。我们可以用如下形式的树来表示： 图中内容表示：$M^n=M^{n/2}=…=\prod_1^n{M^1}​$。 所以，为了计算矩阵$M^n$，我们需要计算$M^{n/2}$并且和自己相乘。为了计算$M^{n/2}$需要计算$M^{n/4}$，等等等等。 显然，树的高度为$\log_2{n}$。 下面来估计$M^n$的计算时间。矩阵$M$在任意次幂的大小都一样，所以我们可以在$O(1)$的时间内计算任意次幂的两个矩阵相乘。这样的计算需要执行$\log_2{n}$次。所以$M^n$的计算复杂度为$O(\log_2{n})$。 如果$n$不是2的幂，那么我们可以通过其二进制表示将其分解为用2的次幂表示： n=\sum_{p\in{P}}2^p\ ,\ \text{where}\ P\subset\mathbb{N}这样我们可以通过如下公式来得到最终结果： M^n=\prod_{p\in P}M^{2^p}这就是在实现中使用的方法？由于乘法的计算次数已经限制在$O(\log_2n)​$，所以总的复杂度就是$O(\log_2n)​$。 方法6、斐波那契公式 没太仔细理解这个方法。。。 我们可以用如下公式计算得到第$n$个斐波那契数： F_n=\cfrac{1}{\sqrt{5}}\left[\left(\cfrac{1+\sqrt5}{2}\right)^n-\left(\cfrac{1-\sqrt5}{2}\right)^n\right]对于给定的问题，斐波那契数列定义为：$F_0=1,F_1=1,F_2=2,F_{n+2}=F_{n+1}+F_n$。解决这种递归公式的一种标准方法是假设$F_n$的形式为$F_n=a^n$。这样的话，显然$F_{n+1}=a^{n+1}$并且$F_{n+2}=a^{n+2}$，所以等式就变为$a^{n+2}=a^{n+1}+a^n$。如果我们将整个等式除以$a^n$，就得到$a^2=a+1$，也就是二次方程$a^2-a-1=0$。 对这个二次方程求解，可以得到： a=1/\sqrt5\left(\left( \cfrac{1\pm \sqrt5}{2} \right)\right)对于一般情况，可以得到等式： F_n=A\left( \cfrac{1+\sqrt 5}{2} \right)^n+B\left( \cfrac{1-\sqrt 5}{2} \right)^n对于$n=0$的情况，有$A+B=1$， 对于$n=1$的情况，有$A\left( \cfrac{1+\sqrt 5}{2} \right)+B\left( \cfrac{1-\sqrt 5}{2} \right)=1$， 对上述等式求解，可以得到： A=\left( \cfrac{1+\sqrt 5}{2\sqrt 5} \right)\ ,\ B=\left( \cfrac{1-\sqrt 5}{2\sqrt 5} \right)将$A$和$B$的值代入到上述的通用等式中，可以得到： F_n=\cfrac{1}{\sqrt{5}}\left[\left(\cfrac{1+\sqrt5}{2}\right)^{n+1}-\left(\cfrac{1-\sqrt5}{2}\right)^{n+1}\right]代码如下： 1234567public class Solution &#123; public int climbStairs(int n) &#123; double sqrt5=Math.sqrt(5); double fibn=Math.pow((1+sqrt5)/2,n+1)-Math.pow((1-sqrt5)/2,n+1); return (int)(fibn/sqrt5); &#125;&#125; 复杂度分析 时间复杂度：$O(\log(n))$。$pow$计算需要$\log(n)$的时间。 空间复杂度：$O(1)​$。使用固定空间。 四、Complexity Analysis 复杂度分析在这一章，我们将讨论如何计算递归算法中的时间和空间复杂度。 特别的是，本章将展示一个非常有用的叫做尾递归的技术，可以用来优化递归问题中的空间复杂度，更重要的是可以避免栈溢出的问题。 时间复杂度——递归这一部分，我们主要讨论如何计算递归问题中的时间复杂度。 给定一个递归问题，其时间复杂度$O(T)$主要是由递归调用的次数（用$R$表示）和每次递归中所需的计算时间（用$O(s)$表示）共同决定的： O(T)=R*O(s) 来看一些例子。 举例在反转字符串问题中，我们需要将一个字符串逆序输出。解决这个问题的一个递归关系可以表示如下： printReverse(str)=printReverse(str[1...n])+print(str[0])其中$str[1…n]$是输入字符串$str$的子串，$str[0]$是首字符。 可以看到，函数递归调用$n$次，$n$是输入字符串的长度。在每一次递归中，只是简单的输出首字符，所以该操作的时间复杂度是常数级，即$O(1)$。 所以，递归函数$printReverse(str)$的总时间复杂度就是$O(printReverse)=n*O(1)=O(n)$。 执行树对于递归函数，调用次数刚好和输入成线性关系的情况是很少见的。例如，在上一章讨论过的斐波那契数列问题，递归函数定义为$f(n)=f(n-1)+f(n-2)$。乍一看，斐波那契函数的调用次数并不能够很直观的得到。 在这种情况，最好是采用execution tree 执行树的方式，这种树是用来详细表示递归函数执行过程的。树上的每个节点表示递归函数的一次调用，所以总的节点数就是整个执行过程中递归调用的总次数了。 执行树用一个$n$叉树来表示，其中$n$表示递归关系中出现递归调用的次数。例如，斐波那契数列问题的执行树是一颗二叉树，下图表示了计算斐波那契数$f(4)$的执行树： 对于一个$n$层的二叉树，其节点总数是$2^n-1$。所以，$f(n)$递归调用次数的上限（虽然不是很严格）就是$2^n-1$。所以，可以得到斐波那契数列问题$f(n)$的时间复杂度是$O(2^n)$。 缓存计算在上一章，讨论过递归算法中用于优化时间复杂度的方法——缓存计算。通过将中间结果进行缓存和重复使用，缓存计算可以大幅减少递归调用的次数，也就是减少执行树的分支数。所以应该考虑到使用缓存计算的递归算法时间复杂度。 回到斐波那契数列问题，使用缓存计算的话，可以将每个斐波那契数的结果进行保存。保证对每个斐波那契数的计算只执行一次。由递归关系可以知道，对于斐波那契数$f(n)$，依赖于前$n-1$个斐波那契数，所以，$f(n)$的递归计算过程将会调用$n-1$次，来计算其所依赖的所以前序数值。 现在可以直接使用本章开始时候给出的公式来计算时间复杂度，即$O(1)*n=O(n)$。缓存计算不仅优化了算法的时间复杂度，也简化了时间复杂度的分析过程。 接下来，我们讨论如何分析递归算法的空间复杂度。 空间复杂度——递归这一部分，将讨论如何分析递归算法中的空间复杂度。 当讨论递归算法的空间复杂度时，应该考虑两部分的空间消耗：递归相关的空间和非递归相关的空间。 递归相关的空间递归相关的空间指的是由递归调用所直接产生内存消耗，即保存递归函数调用所需的栈空间。为了完成一个典型的递归调用，系统需要分配一些空间来保存三部分重要的信息： 函数的返回地址：一旦函数调用完成，程序应该知道返回到哪里，即函数调用之前的位置； 函数传递的参数； 函数的局部变量； 这个栈空间是函数调用过程中所产生的最小开销，一旦函数执行结束，空间就会被释放。 对于递归算法，函数调用会链式累积，直到到达基本情况。这意味着每个函数调用所需的空间也会累积。 对于递归算法，如果没有其他内存消耗，那么这个由递归行为本身所引起的空间消耗将会是整个算法的空间上限。 例如，在逆序输出字符串的练习中，由于只是单纯的输出字符，所以在递归调用本身之外没有额外的空间消耗。对于每一个递归调用，我们假设需要一个常数级的空间。递归调用将持续$n$次，$n$是输入字符串的长度。所以这个递归算法的空间复杂度是$O(n)$。 为了说明这一点，以递归调用$f(x_1)\rightarrow f(x_2)\rightarrow f(x_3)$为例，展示了执行步骤的顺序和堆栈布局。 为了调用$f(x_2)$，会给$f(x_1)$分配一个栈空间。同理，在$f(x_2)$中也会为了调用$f(x_3)$而分配另一个栈空间。最终在$f(x_3)$中，程序到达基本情况，因此没有在$f(x_3)$中进一步递归。 由于这些递归相关的空间消耗，有时会导致栈溢出的情况，就是分配给一个程序的栈空间超出了其最大空间限制，导致程序失败。因此，当设计递归算法时，要仔细考虑当输入规模比较大的时候是否可能导致栈溢出。 非递归相关的空间如标题所示，非递归相关的空间主要是指和递归没有直接关系的内存空间，通常包括分配给全局变量的空间（通常为堆）。 不论是否递归，在任何后续函数调用前都需要将问题的输入作为全局变量保存。同时还需要存储递归调用的中间结果。后者就是我们在前面章节讨论过缓存计算。例如，对于使用缓存计算实现的计算斐波那契数列的递归算法，我们使用一个map来记录递归调用过程中出现的所有斐波那契数。因此，在分析空间复杂度的时候，我们应该考虑到缓存计算的空间成本。 尾递归在之前的页面，讨论过递归调用过程中系统分配栈空间所产生的隐藏空间开销。但是，我们应该学会识别一种递归的特殊情况——尾递归，尾递归避免了这部分空间开销。 尾递归是指在递归函数执行的最后命令是递归调用，并且应该只有一个递归调用。 在反转字符串的问题中我们已经看到了一个尾递归的例子。这里用另一个例子展示非尾递归和尾递归的区别。注意，非尾递归的例子在最后一个递归调用之后有一个额外的计算步骤。 123456789101112131415161718192021222324def sum_non_tail_recursion(ls): """ :type ls: List[int] :rtype: int, the sum of the input list. """ if len(ls) == 0: return 0 # not a tail recursion because it does some computation after the recursive call returned. return ls[0] + sum_non_tail_recursion(ls[1:])def sum_tail_recursion(ls): """ :type ls: List[int] :rtype: int, the sum of the input list. """ def helper(ls, acc): if len(ls) == 0: return acc # this is a tail recursion because the final instruction is a recursive call. return helper(ls[1:], ls[0] + acc) return helper(ls, 0) 尾递归的好处是可以避免递归调用过程中的堆栈开销累积，因为系统在每次递归调用的时候可以重复利用一部分栈空间。 以递归调用$f(x_1)\rightarrow f(x_2)\rightarrow f(x_3)$为例，其中函数$f(x)$是使用尾递归实现的，如下展示了执行步骤的顺序和堆栈布局。 注意在尾递归中，一旦递归调用结束，我们就会理解知道返回值，所以图中跳过了递归返回的完整链路，直接返回到原始调用的地方。这意味着，我们不再需要对所有递归调用都分配栈，从而节省了空间。 例如，在步骤1中，为了调用$f(x_2)$而在$f(x_1)$中分配了栈空间。在步骤2中，$f(x_2)$会递归调用$f(x_3)$，但是系统可以直接重复使用之前为第二次递归调用分配的空间，而不是分配新的空间。最终，在函数$f(x_3)$中，我们到达了基本情况，函数可以直接返回到原始调用的地方，而不需要逐步返回到上一个调用的函数。 尾递归函数可以当做非尾递归函数执行，也就是调用成堆的栈，而不影响结果。通常，编译器会识别尾递归并优化执行过程。但是，并不是所有语言都支持这种优化。例如，C、C++支持尾递归优化，而Java和Python不支持尾递归优化。 练习：二叉树的最大深度详见【LeetCode】104、二叉树的最大深度 Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. 代码如下： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root==NULL) return 0; if (root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return 1; int leftDepth = maxDepth(root-&gt;left); int rightDepth = maxDepth(root-&gt;right); if (leftDepth &gt; rightDepth) &#123; return leftDepth+1; &#125; else &#123; return rightDepth+1; &#125; &#125;&#125;; 解答：二叉树的最大深度要花钱才能解锁，没有看:joy:。 练习：Pow(x, n)详见【LeetCode】50、Pow(x,n) Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: 12Input: 2.00000, 10Output: 1024.00000 Example 2: 12Input: 2.10000, 3Output: 9.26100 Example 3: 123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range $[-2^{31},2^{31}-1]​$ 代码如下： 12345678910class Solution &#123;public: double myPow(double x, int n) &#123; if (n == 0) return 1; double half = myPow(x, n / 2); if (n % 2 == 0) return half * half; if (n &gt; 0) return half * half * x; return half * half / x; &#125;&#125;; 解答：Pow(x, n)要花钱才能解锁，没有看:joy:。 五、Conclusion 总结在之前的章节，我们了解了递归的概念的原则。 作为提醒，以下是解决递归问题的共用工作流程： 定义递归函数； 总结递归关系和基本情况； 如果有重复计算问题的话，使用缓存计算来消除； 如果可能，使用尾递归来优化空间复杂度； 在本章，将对递归算法做一些总结，并且提供一些在利用递归解决问题的过程中可能用到的tips。 总结——递归-1现在，我们了解到递归确实是一个可以用来解决很多问题的有效方法。但是，由于时间和空间的限制，并不是所有问题都能用递归解决。递归可能会有一些负面效果，如栈溢出问题。 在这章，将分享一些可以更好的利用递归来解决实际问题的tips： 疑惑的时候，把递归关系写下来。 有时，乍一看，问题能够用递归算法解决并不明显。但是，由于递归算法和我们所熟悉的数学非常接近，所以利用数学公式推导出一些关系式总是有帮助的。通常，可以帮助澄清问题概念并揭示隐藏的递归关系。在本章后面，可以通过一个例子（Unique Binary Search Trees II）来了解在数学公式的辅助下利用递归方法解决问题。 如果可能，使用缓存计算。 在起草递归算法的时候，可以从最简单的策略开始。有时，在递归过程中会存在重复计算，如斐波那契数问题。在这种情况下，应该尝试使用缓存计算技术，将中间结果缓存以后后续重复使用。缓存计算利用空间上的一些折中来换取时间复杂度的大幅提升。 当出现栈溢出问题时，尾递归可能会有帮助。 使用递归算法通常有几种不同的实现。尾递归是其中一个特定的实现形式。和缓存计算不同，尾递归可以通过消除递归算法带来的堆栈开销来优化算法的空间复杂度。更重要的是，使用尾递归可以避免递归算法常出现的栈溢出问题。尾递归的另一个优点是比非尾递归更容易阅读和理解。因为和非尾递归不同，尾递归中不存在递归后调用的问题（即递归操作是函数的最后操作）。所以，只要可能，应该尽量使用尾递归。 后续现在，利用目前为止所了解到的递归知识，可以在LeetCode上解决更多问题。在本章中，还提供了几个练习。 练习：合并两个有序链表详见【LeetCode】21、合并两个有序链表 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 代码如下： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1==NULL) return l2; if (l2==NULL) return l1; if (l1-&gt;val&lt;l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 解答：合并两个有序链表要花钱才能解锁，没有看:joy:。 练习：第k个语法符号详见【LeetCode】779、第k个语法符号 On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). 123456789101112131415161718Examples:Input: N = 1, K = 1Output: 0Input: N = 2, K = 1Output: 0Input: N = 2, K = 2Output: 1Input: N = 4, K = 5Output: 1Explanation:row 1: 0row 2: 01row 3: 0110row 4: 01101001 Note: N will be an integer in the range [1, 30]. K will be an integer in the range [1, 2^(N-1)]. 代码如下： 12345678910111213class Solution &#123;public: int kthGrammar(int N, int K) &#123; if (N==0) return 0; if (K%2 == 0) &#123; return kthGrammar(N-1, K/2)==0 ? 1:0; &#125; else &#123; return kthGrammar(N-1, (K+1)/2)==0 ? 0:1; &#125; &#125;&#125;; 解答：第k个语法符号要花钱才能解锁，没有看:joy:。 练习：不同的二叉搜索树IIGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&apos;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 等复习了二叉树再后续补充，，， 解答：不同的二叉搜索树II要花钱才能解锁，没有看:joy:。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中list的一些小技巧]]></title>
    <url>%2F2019%2F03%2F20%2Fpython_list_tips%2F</url>
    <content type="text"><![CDATA[列表展开 12345678910111213141516171819202122232425262728import itertools################ case 1a = [[1, 2], [3, 4], [5, 6]]print list(itertools.chain.from_iterable(a))%timeit -n 10000 list(itertools.chain.from_iterable(a))print sum(a, [])%timeit -n 10000 sum(a, [])print [x for l in a for x in l]%timeit -n 10000 [x for l in a for x in l]# result:# [1, 2, 3, 4, 5, 6]# 10000 loops, best of 3: 801 ns per loop# [1, 2, 3, 4, 5, 6]# 10000 loops, best of 3: 359 ns per loop# [1, 2, 3, 4, 5, 6]# 10000 loops, best of 3: 371 ns per loop################ case 2b = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]][x for l1 in b for l2 in l1 for x in l2]# [1, 2, 3, 4, 5, 6, 7, 8]################ case 3a = [1, 2, [3, 4], [[5, 6], [7, 8]]]flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]flatten(a)# [1, 2, 3, 4, 5, 6, 7, 8] 相邻元素压缩&amp;依次相连12345678910111213# python3a = [1, 2, 3, 4, 5, 6]list(zip(*([iter(a)] * 2)))# [(1, 2), (3, 4), (5, 6)]list(zip(*([iter(a)] * 3)))# [(1, 2, 3), (4, 5, 6)]temp = ['a', 'b', 'c', 'd', 'e','f']list(zip(temp[:-1],temp[1:]))# [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')]list(zip(temp[:-2],temp[1:-1],temp[2:]))# [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中zip的一些内容]]></title>
    <url>%2F2019%2F03%2F19%2Fpython_zip%2F</url>
    <content type="text"><![CDATA[1、zip基本说明zip函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，返回由这些元组组成的列表。在Python3.x中为了减少内存，返回的是一个对象，可以用list()转换来输出列表。 如果各个迭代器的元素个数不一样，则返回列表长度与最短的对象相同，利用*号操作符，可以将元组解压为列表。 语法1zip([iterable, ...]) 参数： iterable：一个或多个迭代器； 返回值： 返回一个对象； 示例1234567891011121314151617a = [1,2,3]b = [4,5,6]c = [4,5,6,7,8]zipped = zip(a,b) # 返回一个对象zipped# &lt;zip object at 0x103abc288&gt;list(zipped) # list() 转换为列表# [(1, 4), (2, 5), (3, 6)]list(zip(a,c)) # 元素个数与最短的列表一致# [(1, 4), (2, 5), (3, 6)]a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式，*是Python函数可变参数的一种表示形式，加*的表示传入一个元组对象进行解包list(a1)# [1, 2, 3]list(a2)# [4, 5, 6] 2、一些使用相邻元素压缩器12345a = [1, 2, 3, 4, 5, 6]list(zip(*([iter(a)] * 2)))# [(1, 2), (3, 4), (5, 6)]list(zip(*([iter(a)] * 3)))# [(1, 2, 3), (4, 5, 6)] 首先理解迭代器，iter()可以将一个序列生成为一个迭代器，迭代器的特点是可以用for in语句迭代。原理是迭代器对象有一个next方法，可以每次移动迭代的指针，一旦迭代完，没有下一个元素的时候，会触发一个StopIteration异常。迭代器的特点是，迭代了一次以后，指针就移动了，不会自动回溯。例如，可以用for in迭代列表无数次，但只能迭代一次迭代器，如下： 123456789101112131415&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; x = iter(a)&gt;&gt;&gt; for i in x:... print(i)... 123456&gt;&gt;&gt; for i in x:... print(i) # 因为x已经被迭代过了，迭代的指针不会回溯，所以没有值了... &gt;&gt;&gt; 而在上述相邻元素压缩器的使用过程中，可以发现： 12345a = [1, 2, 3, 4, 5, 6][iter(a)] * 3# [&lt;listiterator at 0x7fa6c00ec1d0&gt;,# &lt;listiterator at 0x7fa6c00ec1d0&gt;,# &lt;listiterator at 0x7fa6c00ec1d0&gt;] 三个迭代器实际上是同一个迭代器。 再来理解zip，如前文所述，zip将两个序列对应打包，如： 1234&gt;&gt;&gt; a1 = [1, 3, 5]&gt;&gt;&gt; a2 = [2, 4, 6]&gt;&gt;&gt; list(zip(a1, a2))[(1, 2), (3, 4), (5, 6)] 而*则表示传入一个对象进行解包，如： 12345&gt;&gt;&gt; t = (a1, a2)&gt;&gt;&gt; list(zip(t)) # 不加*号，zip 只有一个参数 t[([1, 3, 5],), ([2, 4, 6],)]&gt;&gt;&gt; list(zip(*t)) # 加*号的作用就是将元祖t，解包成a1,a2为zip的两个函数参数[(1, 2), (3, 4), (5, 6)] 最后理解为什么使用迭代器，如下： 12345678&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; x = iter(a)&gt;&gt;&gt; t = [a, a]&gt;&gt;&gt; list(zip(*t)) # case 1，不使用迭代器[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)] &gt;&gt;&gt; tx = [x, x] &gt;&gt;&gt; list(zip(*tx)) # case 2，使用迭代器[(1, 2), (3, 4), (5, 6)] 在case 1中，zip传入的两个参数a，等于打包了两个列表，并在zip(*)中进行解包，等价于： 1zip([1, 2, 3, 4, 5, 6],[1, 2, 3, 4, 5, 6]) 在case 2中，x是迭代器对象，迭代过程会调用next方法，迭代过一次后会自动移动且不会回溯。也就是说zip执行过程中先调用第一个参数x的next方法得到参数1，再调用第二个参数x的next方法，上文我们已知这两个迭代器其实是同一个迭代器对象，所以第二次调用x的next方法时，迭代器指针已经移动，所以得到参数2，整个过程类似如下： 123456x.next -&gt; 1x.next -&gt; 2zip(x.next(), x.next()) ---&gt; zip(1, 2)x.next -&gt; 3x.next -&gt; 4zip(x.next(), x.next()) ---&gt; zip(3, 4) 等价于： 1zip([1, 3, 5], [2, 4, 6]) 基于此，就可以理解使用zip做相邻元素压缩器的完整执行过程了。 列表元素依次相连 注意与相邻元素压缩器的效果区别。 12345temp = ['a', 'b', 'c', 'd', 'e','f']print(temp)# ['a', 'b', 'c', 'd', 'e', 'f']list(zip(temp[:-1],temp[1:]))# [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')] 这个用法比较好理解，temp[:-1]去除列表最后一个元素，temp[1:]去除列表第一个元素，则上述过程等价于： 1zip(['a', 'b', 'c', 'd', 'e'], ['b', 'c', 'd', 'e', 'f']) 基于该用法可衍生出多个元素依次相连的用法，如： 12list(zip(temp[:-2],temp[1:-1],temp[2:]))# [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')] 也可以用这种方法实现列表相邻元素压缩器的效果，如： 123a = [1, 2, 3, 4, 5, 6]list(zip(a[::3], a[1::3], a[2::3]))# [(1, 2, 3), (4, 5, 6)] 取列表相同位置元素12345678nums = ['flower','flow','flight']for i in zip(*nums): print(i)# ('f', 'f', 'f')# ('l', 'l', 'l')# ('o', 'o', 'i')# ('w', 'w', 'g') 反转字典123m = &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125;dict(zip(m.values(), m.keys()))# &#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>zip</tag>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】5、最长回文子串]]></title>
    <url>%2F2019%2F03%2F19%2Fleetcode_5%2F</url>
    <content type="text"><![CDATA[5、Longest Palindromic Substring最长回文子串 难度：中等 题目描述 英文： Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 中文： 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 解题思路思路一动态规划方法，维护一个二维数组$tags$，其中$tags[i][j]$表示字符串区间$[i,j]$是否为回文串，当$i=j$时，字符串只有一个字符，肯定是回文串，当$j=i+1$时，字符串为相邻的两个字符，需要判断$s[i]$是否等于$s[j]$，如果$i$和$j$不相邻，即$j-i\ge2$时，除了判断$s[i]$和$s[j]$是否相等，还要判断$tags[i+1][j-1]$是否为真，则有如下递推式： tags[i][j]= \begin{cases} 1, & \text{if $i==j$}\\ s[i]==s[j],&\text{if $j=i+1$}\\ s[i]==s[j]\ \&\&\ tags[i+1][j-1],& \text{if $j>i+1$} \end{cases}代码提交 Python3，用时6708ms，内存21.9M 时间复杂度：$O(n^2)$ 123456789101112131415161718192021222324class Solution: def longestPalindrome(self, s): length = len(s) if length &lt;= 1: return s # 初始化二维数组 tags # 不可以用 tags = [[False]*length]*length 的方式，深浅拷贝 tags = [[False for col in range(length)] for row in range(length)] left = 0 right = 0 templen = 0 for j in range(length): # if i==j tags[j][j] = True # j &gt; i for i in range(j): tags[i][j] = (s[i] == s[j] and (j-i &lt; 2 or tags[i+1][j-1])) # 更新当前记录的最长回文子串信息 if tags[i][j] and templen &lt; j-i+1: left = i right = j templen = j-i+1 return s[left:right+1] 思路二参考链接 弱鸡的讲说，这个思路是一致的，但是代码没太看明白。。。 根据回文的特性，一个大回文按比例缩小后的字符串也必定是回文，比如ABCCBA，那BCCB肯定也是回文。所以我们可以根据动态规划的两个特点：（1）把大问题拆解为小问题（2）重复利用之前的计算结果这道题。如何划分小问题，我们可以先把所有长度最短为1的子字符串计算出来，根据起始位置从左向右，这些必定是回文。然后计算所有长度为2的子字符串，再根据起始位置从左向右。到长度为3的时候，我们就可以利用上次的计算结果：如果中心对称的短字符串不是回文，那长字符串也不是，如果短字符串是回文，那就要看长字符串两头是否一样。这样，一直到长度最大的子字符串，我们就把整个字符串集穷举完了。 代码提交 Python3，用时160ms，内存13M 12345678910111213141516171819202122232425class Solution: def longestPalindrome(self, s): # 使用动态规划，用空间换时间，把问题拆分 # 获取字符串s的长度 str_length = len(s) # 记录最大字符串长度 max_length = 0 # 记录位置 start = 0 # 循环遍历字符串的每一个字符 for i in range(str_length): # 如果当前循环次数-当前最大长度大于等于1 并 字符串[当前循环次数-当前最大长度-1:当前循环次数+1] == 取反后字符串 if i - max_length &gt;= 1 and s[i-max_length-1: i+1] == s[i-max_length-1: i+1][::-1]: # 记录当前开始位置 start = i - max_length - 1 # 取字符串最小长度为2，所以+=2，s[i-max_length-1: i+1] max_length += 2 continue # 如果当前循环次数-当前最大长度大于等于0 并 字符串[当前循环次数-当前最大长度:当前循环次数+1] == 取反后字符串 if i - max_length &gt;= 0 and s[i-max_length: i+1] == s[i-max_length: i+1][::-1]: start = i - max_length # 取字符串最小长度为1，所以+=1，s[i-max_length: i+1] max_length += 1 # 返回最长回文子串 return s[start: start + max_length] 思路三解决最长回文子串的一个时间复杂度为$O (n)$的算法——Manacher算法。 还没有仔细看，应该是针对该问题的一个比较巧妙的算法。 可参考：最长回文子串——Manacher 算法，LeetCode]最长回文子串（Longest Palindromic Substring）。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】213、打家劫舍II]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode_213%2F</url>
    <content type="text"><![CDATA[213、House Robber II打家劫舍II 难度：中等 题目描述 英文： You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 中文： 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 Example 1: 12345678Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 Example 2: 123456789Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 解题思路思路一相比“打家劫舍I”多了首尾不能相连的限制，可以通过对1~n-1和2~n两个序列分别按“打家劫舍I”的思路计算一遍，最后取最大值返回即可。 顺序遍历整个数组，当遍历到第i个值时，有两种情况： 之前遍历过程中的curSum始终大于0，假设当前子序列为a,a+1,a+2,...,b-2,b-1,b，此时考虑所有可能： 以当前子序列开头为开头，以中间任一处结尾的序列，如a,a+1,a+2,...b-2：这种情况一致在遍历过程中保存更新； 以当前子序列结尾为结尾，以中间任一处开头的序列，如a+2,...,b-2,b-1,b：这种情况一定小于当前的完整子序列的和，因为前面缺失的部分的和一定是大于0的（讨论的前提就是遍历过程加和始终大于0）； 以中间元素为开头和结尾的序列，如a+2,...,b-2：这种情况，首先按照前一条讨论，补全前面缺失的部分，之后就变成了第一条讨论的情况； 也就是说，i前面的所有可能序列情况都已经考虑到了； curSum出现小于0的情况，此时由于已遍历过的连续子序列加和&lt;0，则遍历过的这个连续子序列不能完整的被包含到新形成的序列中了；而是否要全部放弃，还是保留末尾的部分元素？参考之前的讨论，以当前子序列结尾为结尾，以中间任一处开头的序列的加和是小于完整子序列的，也就是说是&lt;0的，因为此时遍历过的连续子序列需要全部放弃，即curSum置0，并重新开始累加。 其中，每次curSum&lt;0时的下一位置即为和最大的子序列的开始，每次curSum&gt;maxSum时的位置即为和最大的子序列的结尾。 代码提交 Python3，用时56ms，内存13.2M 123456789101112131415161718class Solution: def rob1(self, nums): if not nums: return 0 if len(nums) == 1: return nums[0] temp = [nums[0], max(nums[0], nums[1])] for i in range(2, len(nums)): temp.extend([max(temp[i-1], temp[i-2]+nums[i])]) return temp[-1] def rob(self, nums): if not nums: return 0 if len(nums) == 1: return nums[0] return max(self.rob1(nums[1:]), self.rob1(nums[:-1]))]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】198、打家劫舍]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode_198%2F</url>
    <content type="text"><![CDATA[198、House Robber打家劫舍 难度：简单 题目描述 英文： You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 中文： 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 Example 1: 12345678910Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 Example 2: 12345678910Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路思路一动态规划，根据题意，不能窃取相邻的房屋，那么第$n$天的最高金额，要么等于第$n-1$天的最高金额，要么等于$n-2$天的最高金额加上第$n$天可获得的金额。 用$f (n)$表示第$n$天的最高金额，$p_n$表示第$n$天可获得的金额，则$f (n) = \max (f(n-1) , f(n-2)+p_n)$，其中，$f(1) = p_1 , f(2)=\max (p_1, p_2)​$。 Ps. 开始简单的以为，就是奇数位求和，偶数位求和，然后取最大值，后来发现不对，只要求有间隔，但间隔不一定为1，如测试用例[2,1,1,2]，则间隔为2，取首尾两个元素时为最大值。 代码提交 Python3，用时64ms，内存13.1M 时间复杂度：$O (n) ​$ 1234567891011class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] temp = [nums[0], max(nums[0], nums[1])] for i in range(2, len(nums)): temp.append(max(temp[i-1], temp[i-2]+nums[i])) return temp[-1] 在Python中，list添加元素的方法，expend效率要高于append，调整后，用时52ms，如下： 1234567891011class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] temp = [nums[0], max(nums[0], nums[1])] for i in range(2, len(nums)): temp.extend([max(temp[i-1], temp[i-2]+nums[i])]) return temp[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】121、买卖股票的最佳时机]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode_121%2F</url>
    <content type="text"><![CDATA[121、Best Time to Buy and Sell Stock买卖股票的最佳时机 难度：简单 题目描述 英文： Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. 中文： 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 Example 1: 123456789Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 Example 2: 1234567Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路思路一动态规划问题，第$i$天的最高利润，要么等于前$i-1$天的最高利润，要么等于第$i$天的卖出价减去前$i-1$天的最低买入价。 用$f (i)$表示第$i$天的最高利润，$p_i$表示第$i$天的价格，则$f (i) = \max ( f(i-1) , p_i - \min (p_1,p_2,…,p_{i-1}) )$。 要注意卖出价高于买入价的限制。 代码提交 Python3，用时6040ms，内存14.2M 1234567891011class Solution: def maxProfit(self, prices: List[int]) -&gt; int: length = len(prices) if length &lt;= 1: return 0 temp = [prices[1]-prices[0]] for i in range(1, length): temp.append(max(temp[i-1], prices[i]-min(prices[:i]), 0)) return temp[-1] 每次都会判断前$i-1$天的最低价，可以将最低价进行保存。 Python3，用时104ms，内存14M 1234567891011121314class Solution: def maxProfit(self, prices: List[int]) -&gt; int: length = len(prices) if length &lt;= 1: return 0 temp = [prices[1]-prices[0]] tempMin = prices[0] for i in range(1, length): if prices[i] &lt; tempMin: tempMin = prices[i] temp.append(max(temp[i-1], prices[i]-tempMin)) return temp[-1] 思路二遍历数组，寻找最低价之后的最高收益。 判断第$i$天的价格，是否是当前最低价，不是最低价则判断是否可获得当前最大收益（获得当前最大收益的节点不一定是当前最高价的节点，当前最高价可能出现在最低价之前，所以无法更新最低价的时候，判断收益而不是试图更新最高价）。 代码提交 Python3，用时80ms，内存13.8M 12345678910111213141516class Solution: import sys def maxProfit(self, prices: List[int]) -&gt; int: length = len(prices) if length &lt;= 1: return 0 tempMin = sys.maxsize tempMax = 0 for i in prices: if i &lt; tempMin: tempMin = i elif i-tempMin &gt; tempMax: tempMax = i-tempMin return tempMax]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】70、爬楼梯]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode_70%2F</url>
    <content type="text"><![CDATA[70、Climbing Stairs爬楼梯 难度：简单 题目描述 英文： You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 中文： 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 Example 1: 12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2: 123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 解题思路思路一动态规划问题，直接递归，用$f (n)$表示到达第$n$阶时的方法数，共有两种爬楼方式（一次一阶，一次两阶），那么到达第$n$阶可以通过“到达第$n-1$阶后再走一次一阶”和“到达第$n-2$阶后再走一次两阶”两种方式，那么只需要考虑到达$n-1$阶和$n-2$阶各有多少种方法即可，即$f(n) = f(n-1) + f(n-2)$，终止条件为$f(1) = 1 , f(2)=2$。 代码提交 Python3，超时 时间复杂度：T(n) = O(1.618 ^ n)（1.618就是黄金分割，(1+5–√)/2(1+5)/2）。 空间复杂度取决于递归的深度，显然是O(n)。 1234567class Solution: def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 if n == 2: return 2 return self.climbStairs(n-1) + self.climbStairs(n-2) 直接递归的方法重复计算太多，直接超时，将计算过的结果进行缓存，使用递归的方式，如下： Python3，用时80ms，内存13.2M 时间复杂度是O(n) 空间复杂度是O(1) 12345678910class Solution: def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 if n == 2: return 2 tempNum = [0,1,2] for i in range(3, n+1): tempNum.append(tempNum[i-1] + tempNum[i-2]) return tempNum[n] 思路二递归表达式及终止条件值符合斐波那契数列。其实跟上面的方法差不多。 代码提交 Python3，用时52ms，内存13.1M 时间复杂性：$O (n)​$ 1234567class Solution: def climbStairs(self, n: int) -&gt; int: a = 0 b = 1 for i in range(n+1): a, b = a + b, a return a]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】53、最大子序和]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_53%2F</url>
    <content type="text"><![CDATA[53、Maximum Subarray最大子序和 难度：简单 题目描述 英文： Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. 中文： 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. 进阶 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路思路一遍历数组，用curSum维护当前位置累加的和，当curSum&lt;0时，将其置为0，重新开始累加，每次都更新全局最大值。 顺序遍历整个数组，当遍历到第i个值时，有两种情况： 之前遍历过程中的curSum始终大于0，假设当前子序列为a,a+1,a+2,...,b-2,b-1,b，此时考虑所有可能： 以当前子序列开头为开头，以中间任一处结尾的序列，如a,a+1,a+2,...b-2：这种情况一致在遍历过程中保存更新； 以当前子序列结尾为结尾，以中间任一处开头的序列，如a+2,...,b-2,b-1,b：这种情况一定小于当前的完整子序列的和，因为前面缺失的部分的和一定是大于0的（讨论的前提就是遍历过程加和始终大于0）； 以中间元素为开头和结尾的序列，如a+2,...,b-2：这种情况，首先按照前一条讨论，补全前面缺失的部分，之后就变成了第一条讨论的情况； 也就是说，i前面的所有可能序列情况都已经考虑到了； curSum出现小于0的情况，此时由于已遍历过的连续子序列加和&lt;0，则遍历过的这个连续子序列不能完整的被包含到新形成的序列中了；而是否要全部放弃，还是保留末尾的部分元素？参考之前的讨论，以当前子序列结尾为结尾，以中间任一处开头的序列的加和是小于完整子序列的，也就是说是&lt;0的，因为此时遍历过的连续子序列需要全部放弃，即curSum置0，并重新开始累加。 其中，每次curSum&lt;0时的下一位置即为和最大的子序列的开始，每次curSum&gt;maxSum时的位置即为和最大的子序列的结尾。 代码提交 Python3，用时96ms，内存13.6M 时间复杂度：$O (n) $ 123456789101112131415class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] maxSum = nums[0] curSum = 0 for i in range(len(nums)): curSum += nums[i] maxSum = max(maxSum, curSum) if curSum &lt; 0: curSum = 0 return maxSum 思路二动态规划，用tempSum保存以第i个元素结尾的最大连续子序列的和，假设对于元素i，其前面的所有元素结尾的序列和都已经得到，则以第i个元素结尾的子序列的和要么是以第i-1个元素结尾的和最大的子序列加上当前元素，要么就是当前元素本身，即tempSum[i] = max(tempSum[i-1]+nums[i], nums[i])。（实际等价于看以i-1个元素结尾的和最大的子序列的和是否小于0，等价于思路一了）当i=0时，最大子序列和即为tempSum[0] = nums[0]。 代码提交 Python3，用时104ms，内存14.2M 时间复杂度：$O (n) ​$ 123456789101112class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] tempSum = [] tempSum.append(nums[0]) for i in range(1, len(nums)): tempSum.append(max(tempSum[i-1]+nums[i], nums[i])) return max(tempSum) 可以直接用nums来保存子序列最大和，能节约一点内存，如下： 12345678910class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] for i in range(1, len(nums)): nums[i] = max(nums[i-1]+nums[i], nums[i]) return max(nums) 思路三提示说可以尝试用分治法，那么就将整个数组不断切分成子数组，最后选最大值返回。 用二分法切分数组，最大子序和要么在左半部分，要么在右半部分，要么横跨左右两部分（既包含左侧的最后一个元素，也包含右侧的第一个元素），返回这三种情况的最大值即可。 横跨左右两部分的情况，可以从中间位置逐次向左右两侧遍历，并更新最大值。 代码提交 Python3，用时272ms，内存13.7M 时间复杂度：$O(n\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] left = 0 right = len(nums)-1 maxSum = self.divide(nums, left, right) return maxSum def divide(self, nums, left, right): # 切分到只有一个元素时，返回 if left == right: return nums[left] # 确立中心点 center = (left + right)//2 # 子序列完全在左侧的最大和 leftMax = self.divide(nums, left, center) # 子序列完全在右侧的最大和 rightMax = self.divide(nums, center+1, right) # 子序列横跨左右两侧的最大和 # 从中间点逐次向左边界靠近 leftSum = 0 leftBorderSum = 0 for i in range(center-1, left-1, -1): leftSum += nums[i] leftBorderSum = max(leftSum, leftBorderSum) # 从中间点逐次向右边界靠近 rightSum = 0 rightBorderSum = 0 for i in range(center+1, right+1): rightSum += nums[i] rightBorderSum = max(rightSum, rightBorderSum) centerMax = leftBorderSum + nums[center] + rightBorderSum return max(leftMax, centerMax, rightMax)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】136、只出现一次的数字]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_136%2F</url>
    <content type="text"><![CDATA[136、Single Number只出现一次的数字 难度：简单 题目描述 英文： Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 中文： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 Example 1: 12Input: [2,2,1]Output: 1 Example 2: 12Input: [4,1,2,1,2]Output: 4 解题思路思路一只有一个元素只出现一次，其余元素都出现两次，所以可以先对原数组去重并求和，再用两倍的和减去原数组的和，得到的结果就是只出现一次的元素值。 只适合只有一个元素次数不同的情况，且使用了额外空间。 代码提交 Python2，用时44ms，内存12.6M 1234567class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ return 2 * sum(set(nums)) - sum(nums) 思路二利用位运算的异或操作，任何数字异或其自身都等于零，任何数字异或零还等于其本身。 题目只有一个元素出现一次，其余元素都出现两次，出现两次的元素异或结果都为零，剩余一个出现一次的元素，与零异或后结果还是其本身，也就是说对所有元素进行异或操作后，结果即为只出现一次的那一个元素值。 代码提交 Python2，用时44ms，内存12.2M 看提交情况，用时最短的代码也是这个思路，约24ms，所以用时可能也和其他一些系统随机因素有关系吧。 12345678910class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ temp = 0 for i in nums: temp ^= i return temp]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】414、第三大的数]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_414%2F</url>
    <content type="text"><![CDATA[414、Third Maximum Number第三大的数 难度：简单 题目描述 英文： Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). 中文： 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例Example 1: 12345Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1. Example 2: 12345Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead. Example 3: 123456Input: [2, 2, 3, 1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 解题思路利用三个变量分别记录数组第1、2、3大的数字，遍历一遍数组即可更新前三大的数，时间复杂度O(n)。 引申出的top-k问题，以及解决top-k问题的BFPRT算法，后续再详细记录。 代码提交 Python2，用时28ms，内存11.1M 123456789101112131415class Solution(object): def thirdMax(self, nums): """ :type nums: List[int] :rtype: int """ first = second = third = None for temp in nums: if temp &gt; first: first, second, third = temp, first, second elif first &gt; temp &gt; second: second, third = temp, second elif second &gt; temp &gt; third: third = temp return third if third is not None else first TipsNone]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python各种排序]]></title>
    <url>%2F2019%2F03%2F13%2Fpython_lambda_sorted%2F</url>
    <content type="text"><![CDATA[0、基础 主要用到list.sort()、sorted()、lambda进行各种排序操作。 其中：list.sort()是Python列表的一个内置排序方法，只供list结构使用，list.sort()方法排序时直接修改原列表，返回None。而sorted()函数接受一切迭代器，返回新列表。 相比list.sort()，sorted()使用范围更广，但是如果不需要保留原列表的情况下对列表排序，可以选择list.sort()方法，不需要复制原有列表，消耗内存小，效率也较高。 list.sort()list.sort()函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。 语法1list.sort(cmp=None, key=None, reverse=False) 参数 cmp：可选参数，如果指定了该参数则使用该参数的方法进行排序，Python3取消了该参数； key：用来进行比较的元素，取自可迭代对象中，指定可迭代对象中的一个元素来进行排序； reverse：排序规则，True降序，False升序（默认）； 返回值 该方法直接修改原列表，返回None； 示例12345678910111213# 列表排序test = ['Google', 'Runoob', 'Taobao', 'Facebook']test.sort()print(test)# result:# ['Facebook', 'Google', 'Runoob', 'Taobao']# 列表降序排序vowels = ['e', 'a', 'u', 'o', 'i']vowels.sort(reverse=True)print (vowels)# result:# ['u', 'o', 'i', 'e', 'a'] sorted()sorted()函数对所有可迭代对象进行排序操作。 语法1sorted(iterable, key=None, reverse=False) 参数 iterable：可迭代对象； key：用来进行比较的元素，取自可迭代对象中，指定可迭代对象中的一个元素来进行排序； reverse：排序规则，True降序，False升序（默认）； 返回值 返回排序好的列表； 示例12345678910# 排序sorted([5, 2, 3, 1, 4])# result：# [1, 2, 3, 4, 5]# 降序排序example_list = [5, 0, 6, 1, 2, 7, 3, 4]sorted(example_list, reverse=True)# result：# [7, 6, 5, 4, 3, 2, 1, 0] lambdaPython使用lambda创建匿名函数，即不使用def这样的标准语句来定义函数，允许快速定义单行函数，类似于C语言的宏，可以用在任何需要函数的地方。 lambda的主体是一个表达式，而不是一个代码块，仅能在其中封装有限的逻辑； lambda函数拥有自己的命名空间，不能访问参数列表之外或全局命名空间里的参数； lambda并不会带来程序效率的提高，只是使代码更简洁？ 语法1lambda [arg1 [,arg2,.....argn]]:expression 上述用法等价于： 12def &lt;lambda&gt;(arg1 [,arg2,......argn]): return expression 示例123456789sum = lambda arg1, arg2: arg1 + arg2 # 调用sum函数print ("sum(10,20) = ", sum( 10, 20 ))print ("sum(20,30) = ", sum( 20, 30 ))# result:# sum(10,20) = 30# sum(20,30) = 50 1、各种排序 参考链接 1.1、list排序12345678910111213lis = ['a', 'b', 'c']print(sorted(lis))# ['a', 'b', 'c']print(sorted(lis, reverse=True))# ['c', 'b', 'a']lis.sort()print(lis)# ['a', 'b', 'c']lis.sort(reverse=True)print(lis)# ['c', 'b', 'a'] 1.2、dict按key排序12345dic = &#123;'c': 1, 'b': 2, 'a': 3&#125;print(sorted(dic))# ['a', 'b', 'c']print(sorted(dic, reverse=True))# ['c', 'b', 'a'] 1.3、dict按value排序12345dic = &#123;'c': 1, 'b': 2, 'a': 3&#125;print(sorted(dic, key=lambda k: dic[k]))# ['c', 'b', 'a']print(sorted(dic, key=lambda k: dic[k], reverse=True))# ['a', 'b', 'c'] 1.4、list内嵌套list排序123456789lis = [[4, 2, 9], [1, 5, 6], [7, 8, 3]]print(sorted(lis, key=lambda k: k[0]))# [[1, 5, 6], [4, 2, 9], [7, 8, 3]]print(sorted(lis, key=lambda k: k[1]))# [[4, 2, 9], [1, 5, 6], [7, 8, 3]]print(sorted(lis, key=lambda k: k[2]))# [[7, 8, 3], [1, 5, 6], [4, 2, 9]]print(sorted(lis, key=lambda k: k[0], reverse=True))# [[7, 8, 3], [4, 2, 9], [1, 5, 6]] 1.5、dict内嵌套dict排序12345678910111213dic = &#123; 'a': &#123;'x': 3, 'y': 2, 'z': 1&#125;, 'b': &#123;'x': 2, 'y': 1, 'z': 3&#125;, 'c': &#123;'x': 1, 'y': 3, 'z': 2&#125;,&#125;print(sorted(dic, key=lambda k: dic[k]['x']))# ['c', 'b', 'a']print(sorted(dic, key=lambda k: dic[k]['y']))# ['b', 'a', 'c']print(sorted(dic, key=lambda k: dic[k]['z']))# ['a', 'c', 'b']print(sorted(dic, key=lambda k: dic[k]['x'], reverse=True))# ['a', 'b', 'c'] 1.6、list内嵌套dict排序12345678910111213lis = [ &#123;'x': 3, 'y': 2, 'z': 1&#125;, &#123;'x': 2, 'y': 1, 'z': 3&#125;, &#123;'x': 1, 'y': 3, 'z': 2&#125;,]print(sorted(lis, key=lambda k: k['x']))# [&#123;'z': 2, 'x': 1, 'y': 3&#125;, &#123;'z': 3, 'x': 2, 'y': 1&#125;, &#123;'z': 1, 'x': 3, 'y': 2&#125;]print(sorted(lis, key=lambda k: k['y']))# [&#123;'z': 3, 'x': 2, 'y': 1&#125;, &#123;'z': 1, 'x': 3, 'y': 2&#125;, &#123;'z': 2, 'x': 1, 'y': 3&#125;]print(sorted(lis, key=lambda k: k['z']))# [&#123;'z': 1, 'x': 3, 'y': 2&#125;, &#123;'z': 2, 'x': 1, 'y': 3&#125;, &#123;'z': 3, 'x': 2, 'y': 1&#125;]print(sorted(lis, key=lambda k: k['x'], reverse=True))# [&#123;'z': 1, 'x': 3, 'y': 2&#125;, &#123;'z': 3, 'x': 2, 'y': 1&#125;, &#123;'z': 2, 'x': 1, 'y': 3&#125;] 1.7、dict内嵌套list排序12345678910111213dic = &#123; 'a': [1, 2, 3], 'b': [2, 1, 3], 'c': [3, 1, 2],&#125;print(sorted(dic, key=lambda k: dic[k][0]))# ['a', 'b', 'c']print(sorted(dic, key=lambda k: dic[k][1]))# ['b', 'c', 'a']print(sorted(dic, key=lambda k: dic[k][2]))# ['c', 'b', 'a']print(sorted(dic, key=lambda k: dic[k][0], reverse=True))# ['c', 'b', 'a'] 1.8、按照多个参数排序使用operator模块的itemgetter()实现。 1234567891011from operator import itemgetterstudent_tuples = [('john', 'A', 15),('jane', 'B', 12),('dave', 'B', 10)]print (sorted(student_tuples, key = itemgetter(2))) # 根据年龄排序print (sorted(student_tuples, key = itemgetter(1, 2))) # 根据成绩和年龄排序print (sorted(student_tuples, key = itemgetter(1, 2), reverse=True)) # 反转排序结果# result:# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]# [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]# [('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)] 2、其他list排序可视情况采用sorted()或list.sort()，其他各种排序主要是sorted()和lambda的结合操作； dict的排序只取其key，所以需要对value操作时需要在lambda中先转换为对应的value才可以； 排序是稳定的，即如果多个元素有相同的key，则排序前后其先后顺序不变；]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>lambda</tag>
        <tag>排序</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】937、重新排列日志文件]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_937%2F</url>
    <content type="text"><![CDATA[937、Reorder Log Files重新排列日志文件 难度：简单 题目描述 英文： You have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs. It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order. Return the final order of the logs. 中文： 你有一个日志数组 logs。每条日志都是以空格分隔的字串。 对于每条日志，其第一个字为字母数字标识符。然后，要么： 标识符后面的每个字将仅由小写字母组成，或； 标识符后面的每个字将仅由数字组成。 我们将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。 将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按字母顺序排序，忽略标识符，标识符仅用于表示关系。数字日志应该按原来的顺序排列。 返回日志的最终顺序。 提示 0 &lt;= logs.length &lt;= 100 3 &lt;= logs[i].length &lt;= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier. 示例Example 1: 12Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;] 解题思路思路一先区分数字日志和字母日志，然后字母日志按内容排序，最后合并两部分内容输出。 代码提交 Python2，用时48ms，内存11.1M 1234567891011121314151617class Solution(object): def reorderLogFiles(self, logs): """ :type logs: List[str] :rtype: List[str] """ letterList = [] numberList = [] for log in logs: logList = log.split(" ") if logList[1].isdigit(): numberList.append(log) else: letterList.append((logList[0], " ".join(logList[1:]))) letterList.sort(key=lambda x:x[1]) resultList = [" ".join(a) for a in letterList] return resultList+numberList 后来看了一下用时短的代码，方法都很简单，但是代码很简洁高效。 用0、1标记字母、数字日志，之后一次排序返回。 Python2，用时36ms，内存11.1M 1234567891011class Solution(object): def reorderLogFiles(self, logs): """ :type logs: List[str] :rtype: List[str] """ def f(log): id, rest = log.split(' ', 1) return (0, rest) if rest[0].isalpha() else (1,) return sorted(logs, key = f)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】936、戳印序列]]></title>
    <url>%2F2019%2F03%2F12%2Fleetcode_936%2F</url>
    <content type="text"><![CDATA[936、Stamping The Sequence戳印序列 难度：困难 题目描述 英文： You want to form a target string of lowercase letters. At the beginning, your sequence is target.length &#39;?&#39; marks. You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp. You can make up to 10 * target.length turns. For example, if the initial sequence is “?????”, and your stamp is &quot;abc&quot;, then you may make “abc??”, “?abc?”, “??abc” in the first turn. (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn. If the sequence is not possible to stamp, return an empty array. For example, if the sequence is “ababc”, and the stamp is &quot;abc&quot;, then we could return the answer [0, 2], corresponding to the moves “?????” -&gt; “abc??” -&gt; “ababc”. Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves. Any answers specifying more than this number of moves will not be accepted. 中文： 你想要用小写字母组成一个目标字符串 target。 开始的时候，序列由 target.length 个 &#39;?&#39; 记号组成。而你有一个小写字母印章 stamp。 在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 10 * target.length 个回合。 举个例子，如果初始序列为 “?????”，而你的印章 stamp 是 &quot;abc&quot;，那么在第一回合，你可以得到 “abc??”、”?abc?”、”??abc”。（请注意，印章必须完全包含在序列的边界内才能盖下去。） 如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。 例如，如果序列是 “ababc”，印章是 &quot;abc&quot;，那么我们就可以返回与操作 “?????” -&gt; “abc??” -&gt; “ababc” 相对应的答案 [0, 2]； 另外，如果可以印出序列，那么需要保证可以在 10 * target.length 个回合内完成。任何超过此数字的答案将不被接受。 提示 1 &lt;= stamp.length &lt;= target.length &lt;= 1000 stamp 和 target 只包含小写字母。 示例Example 1: 123Input: stamp = &quot;abc&quot;, target = &quot;ababc&quot;Output: [0,2]([1,0,2] would also be accepted as an answer, as well as some other answers.) Example 2: 12Input: stamp = &quot;abca&quot;, target = &quot;aabcaca&quot;Output: [3,0,1] 解题思路思路一题目是从?????到ababc的问题，替换时要考虑会覆盖到已经替换好的部分。可以逆向替换，从ababc到?????，?可以看做通配符，遍历target，逐位和stamp比较，如果可以匹配到，则记录当时的index，并修改覆盖后的字符，循环上述过程，直到得到了?????序列或无法继续匹配下去。 例如，stamp=&#39;abca&#39;，target=&#39;aabcaca&#39;，则整个替换过程为aabcaca =&gt; a????ca =&gt; ?????ca =&gt; ???????，替换位置索引序列为1-&gt;0-&gt;3，所以题目所求的序列即为[3,0,1]。 代码提交 Python2，用时6480ms，内存10.9M 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object): def movesToStamp(self, stamp, target): """ :type stamp: str :type target: str :rtype: List[int] """ # 如果target首尾字符和stamp不同，则肯定无法覆盖，直接返回[] if target[0] != stamp[0] or target[-1] != stamp[-1]: return [] slen, tlen = len(stamp), len(target) temptarget = target res = [] # 检查是否可以stamp一次，返回索引 def checkstamp(temptarget): # 遍历target，并记录可以覆盖的位置索引index for index in range(tlen): hasletter, stampj, tempi = False, 0, index # 遍历stamp，并对比target[index:index+len(stamp)]是否可以覆盖 while stampj &lt; slen and tempi &lt; tlen and (temptarget[tempi] == "?" or temptarget[tempi] == stamp[stampj]): # 待覆盖内容包含非“?”内容，不匹配完全由“?”组成的内容 if temptarget[tempi] == stamp[stampj]: hasletter = True stampj += 1 tempi += 1 # 修改覆盖后的target if hasletter and stampj == slen: temptarget = temptarget[:index] + "?"*slen + temptarget[index+slen:] return index, temptarget return -1, temptarget # 到完全覆盖时停止 while temptarget != "?"*tlen: temp, temptarget = checkstamp(temptarget) if temp == -1: return [] res.append(temp) # 返回逆序序列 return res[::-1] 思路二参考链接 上述方法一的checkstamp过程有很多重复计算，事实上不需要每次都从头开始遍历，可以进行一些优化。 只进行一次字符串匹配的循环，在时间进行了优化，相应的内存消耗增加。记录每一个位置 i 对应长度为lenS的字符串上有哪些部分是能对应的，哪些些是不对应的。再将完全对应的字符串的位置全部压入队列。 在队列中的每一个位置都是已匹配位置，在change中声明当前位置已匹配，之后考虑当前位置改动后可能会产生影响的所有位置 i 对应的长度为lenS的字符串。 代码提交 Python2，用时436ms，内存14.4M 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import collectionsclass Solution(object): def movesToStamp(self, stamp, target): """ :type stamp: str :type target: str :rtype: List[int] """ M, N = len(stamp), len(target) queue = collections.deque() done = [False] * N ans = [] A = [] for i in range(N - M + 1): # For each window [i, i+M), # A[i] will contain info on what needs to change # before we can reverse stamp at i. made, todo = set(), set() for j, c in enumerate(stamp): a = target[i+j] if a == c: made.add(i+j) else: todo.add(i+j) A.append((made, todo)) # If we can reverse stamp at i immediately, # enqueue letters from this window. if not todo: ans.append(i) for j in range(i, i + len(stamp)): if not done[j]: queue.append(j) done[j] = True # For each enqueued letter, while queue: i = queue.popleft() # For each window that is potentially affected, # j: start of window for j in range(max(0, i-M+1), min(N-M, i)+1): if i in A[j][1]: # This window is affected A[j][1].discard(i) # Remove it from todo list of this window if not A[j][1]: # Todo list of this window is empty ans.append(j) for m in A[j][0]: # For each letter to potentially enqueue, if not done[m]: queue.append(m) done[m] = True return ans[::-1] if all(done) else []]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异或操作&位运算]]></title>
    <url>%2F2019%2F03%2F07%2Fweiyunsuan%2F</url>
    <content type="text"><![CDATA[做题时用到了按位异或的操作，有点蒙蒙的，大概查了查位运算的一些东西，略作总结，主要以Python为例。 参考链接 位运算简介位运算是把数字用二进制表示之后，对每一位上0或1的运算。 所有的运算（包括位运算）在计算机内部都是通过补码的形式进行运算的。 补码是计算机表示数据的一般方式，其规则为：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上1(相当于将原码数值位取反然后在最低位加1)。 例如： 数字 6 在8位计算机中的补码为：0000 0110 （即为其原码） 数字 -6 在8位计算机中的补码为：1111 1010 主要的位运算总共有6种：与、或、异或、取反、左移、右移，如下表所示： 表中示例： a=60，二进制表示 0011 1100 b=13，二进制表示 0000 1101 运算符 描述 示例 &amp; 按位与：参与运算的两个值，如果两个对应位都为1，则该位的结果为1，否则为0； (a&amp;b)结果为12，二进制 0000 1100 \ 按位或：只要对应的两个二进制位中有一个为1时，该位的结果就为1； (a\ b)结果为61，二进制 0011 1101 ^ 按位异或：当两个对应的二进制位不同时，该位的结果为1； (a^b)结果为49，二进制 0011 0001 ~ 按位取反：对数据的每个二进制位取反，即把1变成0，把0变成1； (~a)结果为 -61，二进制 1100 0011（有符号二进制数的补码形式） \&lt;\&lt; 按位左移：数据的每个二进制位均左移若干位，\&lt;\&lt;右边的数字指定移动位数，高位丢弃，低位补0； (a\&lt;\&lt;2)结果为240，二进制 1111 0000 >> 按位右移：数据的每个二进制位均右移若干位，>>右边的数字指定移动位数，具体见下文； (a>>2)结果为15，二进制 0000 1111 左移运算符：m\&lt;\&lt;n 表示把 m 左移 n 位，最左边的 n 位被丢弃，同时在最右边补上 n 个0，如下： 1200001010 &lt;&lt; 2 = 0010100010001010 &lt;&lt; 3 = 01010000 右移运算符：m>>n 表示把 m 右移 n 位，最右边的 n 位被丢弃，但最左边的处理方式有所不同：如果符号位为0，则右移后高位补0，如果符号位为1，则高位补1，也就是说，如果数字是正数，则右移后在最左边补 n 个0，如果数字为负数，则右移后在最左边补 n 个1。如下： 1200001010 &gt;&gt; 2 = 0000001010001010 &gt;&gt; 3 = 11110001 如下为Python中所有位运算操作符示意： 123456789101112131415161718192021222324a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0c = a &amp; b; # 12 = 0000 1100print "a &amp; b 的值为：", cc = a | b; # 61 = 0011 1101 print "a | b 的值为：", cc = a ^ b; # 49 = 0011 0001print "a ^ b 的值为：", cc = ~a; # -61 = 1100 0011print " ~a 的值为：", cc = a &lt;&lt; 2; # 240 = 1111 0000print " a&lt;&lt;2 的值为：", cc = a &gt;&gt; 2; # 15 = 0000 1111print " a&gt;&gt;2 的值为：", c# result:# a &amp; b 的值为： 12# a | b 的值为： 61# a ^ b 的值为： 49# ~a 的值为： -61# a&lt;&lt;2 的值为： 240# a&gt;&gt;2 的值为： 15 移位运算运算规则 左移运算符：m\&lt;\&lt;n 表示把 m 左移 n 位，最左边的 n 位被丢弃，同时在最右边补上 n 个0，如下： 1200001010 &lt;&lt; 2 = 0010100010001010 &lt;&lt; 3 = 01010000 右移运算符：m>>n 表示把 m 右移 n 位，最右边的 n 位被丢弃，但最左边的处理方式有所不同：如果符号位为0，则右移后高位补0，如果符号位为1，则高位补1，也就是说，如果数字是正数，则右移后在最左边补 n 个0，如果数字为负数，则右移后在最左边补 n 个1。如下： 1200001010 &gt;&gt; 2 = 0000001010001010 &gt;&gt; 3 = 11110001 特殊应用 移位运算是最有效的计算乘/除法的运算之一，把整数左/右移一位，和把整数乘以/除以 2 在数学上是等价的。 1234567891011a = 2print a &lt;&lt; 1 # 左移一位等效于a = a * 2;# result: 4print a &lt;&lt; 2 # a左移两位等效于a = a * 2的2次方（4）；# result: 8a = 16print a &gt;&gt; 1 # 右移一位等效于a = a / 2；# result: 8print a &gt;&gt; 2 # 右移两位等效于a = a / (2**2)；# result: 4 按位与运算规则0&amp;0=0，0&amp;1=0，1&amp;0=0，1&amp;1=1。 即：两位同时为“1”，结果才为“1”，否则为0，有0则0。 特殊应用 清零指定位： mask中指定位置0，其它位为1，a = a &amp; mask。 取一个数的指定二进制位： mask中指定位置1，其它位为0，a = a &amp; mask。 判断一个数二进制表示中1的个数： 一个整数减去1，再和原数做与运算，会把该整数二进制表示中最右边一个1变为0。 如： 实现一个函数，输入一个正数，输出该数二进制表示中1的个数： 12345678num = 0n=5 # 二进制：101while(n): n &amp;= (n-1) num += 1print str(num)# result: 2 判断一个正数是不是2的整数次方： 如果是2的整数次方，则其二进制表示中有且只有一位是1。 1234a=4print a&amp;(a-1) == 0# result: True 按位或运算规则0|0=0；0|1=1；1|0=1；1|1=1。 即 ：参加运算的两个对象只要有一个为1，其值为1，有1则1。 特殊应用 对数据的指定位置为1： mask指定位置1，其它位为0，a = a | mask。 如：将 a = 1010 0000 低四位置1，则 a | 0000 1111 即可。 按位异或运算规则0^0=0；0^1=1；1^0=1；1^1=0。 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0，同0异1。 异或特点： 0异或任何数均为原数 1异或任何数，结果为对该数取反 任何数异或自己，结果为0 特殊应用 使特定位翻转： mask的特定位置1，其它位为0，a = a ^ mask。 如，对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算：10100001^00000110 = 10100111。 不使用临时变量，交换两个数的值： 如，交换两个整数a=10100001，b=00000110的值： 123a = a^b # a=10100111b = b^a # b=10100001a = a^b # a=00000110 与0异或，保留原值： a ^ 0仍为a。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>异或</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】599、两个列表的最小索引总和]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode_599%2F</url>
    <content type="text"><![CDATA[599、Minimum Index Sum of Two Lists 两个列表的最小索引总和 难度：简单 题目描述 英文： Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. 中文： 假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。 示例Example 1: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]Output: [&quot;Shogun&quot;]Explanation: The only restaurant they both like is &quot;Shogun&quot;. Example 2: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]Output: [&quot;Shogun&quot;]Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1). 提示 The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists. 代码提交 Python2，用时128ms，内存11.1M 12345678910111213141516171819202122class Solution(object): def findRestaurant(self, list1, list2): """ :type list1: List[str] :type list2: List[str] :rtype: List[str] """ dict1 = &#123;&#125; for index, name in enumerate(list1): dict1[name] = index templist = [] tempsum = 3000 for index, name in enumerate(list2): if name in dict1: cursum = index+dict1[name] if cursum &lt; tempsum: templist = [name] tempsum = cursum elif cursum == tempsum: templist.append(name) return templist TipsPython查找dict的key时，应使用if key in dict，而不是if key in dict.keys()。 前者是在dict中查找，dict对象的存储结构是hash表，最优情况下查询复杂度为O(1)； 后者等于是在list中查找，list对象的存储结构是线性表，查询复杂度为O(n)。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[%time,%timeit魔法命令]]></title>
    <url>%2F2019%2F03%2F04%2Fjupyter_timeit%2F</url>
    <content type="text"><![CDATA[在Jupyter-notebook中有几个用于计时的魔法命令%time、%%time、%timeit、%%timeit，可以非常简单的获取部分代码的运行耗时。 所有以%开头的方法，都是所谓的魔法命令（Magic function），也就是IPython内置的一些方法。魔法方法要区分%和%%，以%开头的叫做line magic，是专门针对一行的命令，以%%开头的叫做cell magic，是针对多行（一个cell）的命令。 以%%开头的魔法命令，必须放在一个cell的第一行，并且统计该cell中剩余的所有代码。分别来看： %time 给出当前行的代码运行一次所花费的时间； 123456a,b = 1,2%time a,b = b,a# output:# CPU times: user 2 µs, sys: 1 µs, total: 3 µs# Wall time: 5.01 µs 其中： user：表示执行用户代码（内核外）消耗的CPU时间； sys：表示进程在内核中消耗的CPU时间； 所以，CPU总耗时看total即可，也就是uset和sys之和。 Wall time是最终总耗时，包括IO、排队的耗时，也就是感知到的总耗时。 Wall time $&lt;$ CPU 表明进程是计算密集型（CPU bound），利用多核处理器的并行执行优势； Wall time $\approx$ CPU 表明进程是计算密集型，未并行执行； Wall time $&gt;​$ CPU 表明进程是I/O密集型（I/O bound），多核并行执行优势并不明显； %%time 给出当前cell的代码运行一次所花费的时间； 1234567%%timea,b = 1,2a,b = b,a# output:# CPU times: user 2 µs, sys: 1e+03 ns, total: 3 µs# Wall time: 5.96 µs %timeit -n 1000 给出当前行的代码运行n次所花费的时间（取最快三次的平均用时）； 1234%timeit -n 10000 c = pow(2,20)# output:# 10000 loops, best of 3: 198 ns per loop %%timeit -n 1000 给出当前cell的代码运行n次所花费的时间（取最快三次的平均用时）； 12345678%%timeit -n 10000a,b = 1,2c=aa=bb=c# output:# 10000 loops, best of 3: 68.5 ns per loop]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[若干Python性能优化小tips]]></title>
    <url>%2F2019%2F03%2F04%2Ffasterpython%2F</url>
    <content type="text"><![CDATA[若干简单易实现的Python性能优化小tips。 部分参考：https://segmentfault.com/a/1190000000666603 一些tips在刷题过程确实得到验证，尚有一些未验证但在实际简单测试中效率有提升。 优化算法时间复杂度 不论什么语言，算法的时间复杂度对程序的执行效率都有决定性影响，在Python中可以通过选择合适的数据结构来优化时间复杂度，如list和set查找指定元素的时间复杂度分别为O(n)和O(1)。同时，可以根据具体情况，采用分治、贪心、动态规划等算法思想。（不过优化算法有些有时候也不是很容易实现，，，） 在算法的常见时间复杂度上排序如下： O(1)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HMM和Viterbi算法]]></title>
    <url>%2F2019%2F03%2F01%2FHMM_IM%2F</url>
    <content type="text"><![CDATA[背景试图实现一个基于隐马尔科夫模型的拼音输入法，根据用户输入的拼音序列转换为对应的汉字，完成中文的输入。 输入法基本需求 通常一个拼音会对应多个汉字，如何确定在当前状态下，输入的拼音对应哪个汉字； 拼音序列通常可以对应多种可能的汉字组合，如何确定哪一种组合是相对最好的一种组合，如对于拼音序列yi chang，有异常、一场、宜昌等多种汉字组合，如何进行选择； HMM简介模型定义HMM（Hidden Markov Models，隐马尔科夫模型）是一种基本的统计模型，可以应用在语音识别、自然语言处理、模式识别等很多领域。 HMM的一个前提是马尔科夫假设，即假设模型的当前状态仅依赖于前面的几个状态。马尔科夫假设极大的简化了问题，但也可能丢失一些重要信息。一个马尔科夫过程是指状态间的转移仅依赖于前n个状态的过程，该过程即为n阶马尔科夫模型，其中n是影响下一个状态选择的前n个状态。（通常所说的HMM，指一阶HMM） HMM是在一个标准的马尔科夫过程中引入一组隐藏状态，以及观察状态与隐藏状态之间的一些概率关系，描述了一个含有隐藏状态的马尔科夫过程。 使用HMM模型时，通常问题有以下两个主要特征： 问题是基于序列的，如时间序列、状态序列； 问题中有两类数据，一类数据序列是可以观测到的，即观察序列，另一类数据序列是不能观测到的，即隐藏状态序列，简称状态序列； 例如在打算要做拼音输入法任务中，可以将拼音看做是隐藏状态，而拼音转化的文字结果作为一系列的观察状态，可以看到，引入隐藏状态的同时，观察序列与隐藏过程也具有一定的概率关系。 可以参考上图，其中$Z_i​$为隐藏状态序列，$X_i​$为隐藏状态生成的观察状态序列。隐藏状态序列$Z_i​$满足马尔科夫过程的要求，且观察状态序列$X_i​$与$Z_i​$之间存在概率关系，即模型中的$X_i​$与$X_i+1​$是存在关联的。 模型参数首先定义一些基本符号： $Q=\lbrace q_1,q_2,…,q_N \rbrace$，Q是所有可能的隐藏状态集合，其中N为可能的隐藏状态数，对应所有可能的汉字的状态数量； $V=\lbrace v_1,v_2,…,v_M \rbrace$，V是所有可能的观察状态集合，其中M为可能的观察状态数，对应所有可能的拼音的状态数量； $I=\lbrace i_1,i_2,…,i_T \rbrace​$，I 是长度为T的隐藏状态序列，对应用户输入的拼音序列所对应的汉字序列； $O=\lbrace o_1,o_2,…o_T \rbrace​$，O 是对应的观察序列，对应用户输入的拼音序列； HMM除上述状态集合外，还包括三组概率集合，用一个三元组$\lambda​$来刻画HMM，可写作$\lambda = (A,B,\pi)​$。 A 是隐藏状态转移概率分布，通常用矩阵表示，称为状态转移矩阵： A=[a_{ij}]_{N\times N} \quad where\quad a_{ij}=P(i_{t+1}=q_j|i_t=q_i)即，$a_{ij}​$ 是在时刻 t 处于状态 $q_i​$ 的条件下，在时刻 $t+1​$ 转移到状态 $q_j​$ 的概率，对应汉字到汉字之间的转移概率； B 是观察状态发射概率分布，通常用矩阵表示，称为混淆矩阵或发射矩阵： B=[b_{ik}]_{N\times M} \quad where\quad b_{ik}=P(o_t=v_k|i_t=q_i)即，$b_{ik}​$ 是在时刻 t 下的隐藏状态 $q_i​$ 到观察状态 $v_k​$ 的发射概率，对应汉字到拼音之间的发射概率； π 是初始状态概率，用向量表示： \pi = (\pi_i)_N \quad where \quad \pi=P(i_1=q_i)即，$\pi_i​$ 是在时刻 t=1 时处于隐藏状态 $q_i​$ 的概率； 可以看到，HMM（一阶）有两个基本假设： 齐次假设： P(i_t|i_{t-1},o_{t-1},i_{t-2},o_{t-2},...,i_1,o_1)=P(i_t|i_{t-1})即，任意时刻的隐藏状态只依赖于它前一个时刻的隐藏状态； 观测独立性假设： P(o_t|i_{T-1},o_{T-1},i_{T-2},o_{T-2},...i_1,o_1)=P(o_t|i_t)即，任意时刻的观察状态只依赖于当前时刻的隐藏状态； 用HMM解决的三类基本问题一旦一个系统可以作为HMM被描述，则可以用来解决三个基本问题 1。其中前两个是模式识别的问题：给定HMM求一个观察序列的概率（评估），搜索最有可能生成一个观察序列的隐藏状态序列（解码）。第三个问题是给定观察序列生成一个HMM（学习）。 评估（概率计算问题）：前向算法——动态规划 给定模型$\lambda = (A,B,\pi)​$和观察序列$O=\lbrace o_1,o_2,…o_T \rbrace​$，计算在模型 $ \lambda ​$ 参数已知的情况下，计算观察序列 $O​$ 出现的概率 $P(O|\lambda)​$； 学习（模型学习问题）：前向-后向算法（也叫Baum-Welch算法）——EM 已知观察序列$O=\lbrace o_1,o_2,…o_T \rbrace​$，学习使得观察序列概率 $P(O|\lambda)​$最大的模型$\lambda = (A,B,\pi)​$参数； 即根据观察序列用极大似然估计的方法估计参数生成隐马尔科夫模型； 解码（预测问题）：Viterbi算法——动态规划 已知模型$\lambda = (A,B,\pi)$和观察序列$O=\lbrace o_1,o_2,…o_T \rbrace$，求给定观察序列的情况下条件概率$P(I|O,\lambda)$最大的（隐藏）状态序列$I=\lbrace i_1,i_2,…,i_T \rbrace$； 即给定观察序列，搜索最有可能的对应的隐藏状态序列； Viterbi算法基于以上可知，拼音输入法的问题，属于解码问题，即已知模型和观察序列，求最有可能的对应的隐藏状态序列。 理论上，可以通过枚举所有的状态转移序列来求解解码问题，但效率非常低，暴力枚举的思路是枚举所有的长度T的状态序列，计算该状态序列与观察序列的联合概率。在状态种类为$N$的情况下，共有$N^T$种排列组合，每种组合计算联合概率的计算量为$T$，则总的计算复杂度为$O(TN^T)$ ，可见该方法并不可取。 因此常用维特比（Viterbi）算法来解决。 Viterbi算法是一个通用的求序列最短路径的动态规划算法。 如上图所示，Viterbi算法简单来说就是：从开始状态之后每走一步，就记录下到达该时刻每个状态时，对应该状态所有路径中的概率最大值，并且以这个最大值为基准继续向后前进。显然，如果这个最大值都不能使该状态成为最大似然估计路径上的节点的话，那么该节点的其他更小的概率值（包括对应的路径）就更不可能了。 Viterbi算法通过一种有效的方法来分析HMM模型的观察序列，并捕获最可能的隐藏序列，利用递归的方法减少计算量，并且对于观察序列的整个上下文都进行了很好的考虑，对包含噪音的序列也能进行良好的分析。 Viterbi算法详细过程 该部分内容主要参考52nlp上关于HMM的详细讲解，整理一遍便于自己详细理解。 如上文所说，通过暴力枚举的方法来找到最可能的序列的代价是非常昂贵的，因此Viterbi算法考虑用递归的方式来寻找最有可能的隐藏状态序列。所以，我们首先定义局部概率 $\delta​$ ，表示到达网格中的某个中间状态时的概率值，之后来详细了解如何在$t=1​$和$t=n (n&gt;1)​$时如何计算其局部概率值。 定义局部概率和局部最佳路径 观察上图的网格，显示的是汉字对于观察序列（拼音序列）的一阶转移情况。对于网格中的每一个中间及终止状态，都有一个可以到达该状态的最可能路径。比如，在$t=3​$时刻的三个状态中，每一个都有一条到达该状态的最可能路径，可能如下图所示： 这些路径即为局部最佳路径，而每条局部最佳路径的概率值即为局部概率$\delta​$，用$ \delta(i,t)​$表示在 $t​$ 时刻到达状态 $i​$ 的所有路径概率中最大的概率值，局部最佳路径即对应该最大概率值的隐藏状态序列。基于此可知，在 $t=T​$ 时刻，每个状态都有一个局部概率及相应的局部最佳路径，因此，可以通过选择该时刻局部概率值最大的状态（及其对应的最佳路径）来确定全局最佳路径，即全局最佳隐藏状态序列。 计算$t=1$时刻的局部概率局部概率指到达该状态时的最佳路径的概率值，当$t=1​$时，该路径是不存在的，因此，用$t=1​$时刻所处状态的初始概率值及相应观察状态的转移概率值来计算$t=1​$时的局部概率，即： \delta _1(i)=\pi (i)b_{io_1}计算$t&gt;1$时刻的局部概率考虑如图所示的网格： 计算 $t$ 时刻到达状态 $X$ 的最佳路径，显然，这条最佳路径一定会通过 $t-1$ 时刻的状态 $A$、$B$、$C$ 之中的某一个。也就是说，到达状态 $X$ 的最佳路径一定是路径(状态序列），...，A，X、（状态序列），...，B，X、（状态序列），...，C，X三条之中的一条。 我们知道在一阶马尔科夫假设下，状态 $X$ 在一个状态序列之后发生的概率只取决于之前的一个状态，也就是说，路径末端是 $AX$ 的最佳路径将是到达 $A$ 的最佳路径再紧跟 $X$ ，那么这条路径的概率即为：$P(到达状态A的最佳路径)\times P(X|A)\times P(观察状态|X)$。 由此可知，到达状态 $X$ 的最佳路径概率计算方式为： P(X\ at\ time\ t)=\max_{i=A,B,C}P(i\ at\ time\ (t-1))\times P(X|i)\times P(obs\ at\ time\ t|X)其中，$P(i at time (t-1))​$是$t-1​$时刻的局部概率$\delta​$，$P(X|i)​$是状态转移概率（隐藏状态到观察状态的发射概率），$P(obs at time t|X)​$是观察概率。 对上述公式进行泛化可知，在 $t​$ 时刻，观察状态是 $k_t​$ ，到达隐藏状态 $i​$ 最佳局部路径概率为： \delta _t(i)=\max \limits_j(\delta _{t-1}(j)\times a_{ji}\times b_{io_t})我们假设前一个状态的局部概率已知，同时利用状态转移概率和对应的观察概率，就可以从中选择当前状态的最大概率了（局部概率 $\delta$ ）。 使用反向指针记录最佳路径 考虑上图的网格，经过前面的过程我们已经得到了每个状态的局部概率，但我们最终的目标是希望得到网格中的最佳隐藏序列，也就是说，最终的目标是需要得到网格中的局部最佳路径。 回顾之前我们得到局部概率的过程，$t$ 时刻的局部概率是通过 $t-1$ 时刻的局部概率得到的，也就是说，在计算得到 $t$ 时刻的局部概率 $\delta _t(i)$ 之后，我们就可以知道这个局部概率 $\delta _t(i)$ 是由 $t-1$ 时刻的哪一个状态而得到的。因此，在这个过程中，我们通过给每一个状态赋予一个反向指针 $\psi$ 来记录，这个指针指向导致当前状态最优概率的前一时刻的某个状态。 反向指针在形式上的公式如下： \psi _t(i)=argmax_j(\delta _{t-1}(j)a_{ji})这个反向指针的表达式是通过转移概率（某时刻的隐藏状态，演变到下一时刻某个隐藏状态的概率）以及前一时刻的局部概率计算得到的，没有使用到观察概率（隐藏状态到观察状态的发射概率）。 经过上述过程，已经可以通过递归的方式得到网格中每个状态的最佳局部概率，以及相应的局部最佳路径。 在使用Viterbi算法的过程中，我们对于网格中的每一个状态都计算一个局部概率，同时包含一个反向指针来指向最可能到达该状态的路径。当完成整个计算过程之后，我们首先在终止状态找到最可能的状态，之后通过反向指针回溯到初始时刻，从而回溯路径对应的状态序列就是我们最终得到的最佳的隐藏状态序列了。 Viterbi算法形式化表达及计算流程上文对Viterbi算法的流程做了详细的梳理，现在来总结一下Viterbi算法的形式化定义及完整流程： 输入：HMM模型 $\lambda =(A,B,\pi)$ ，观察序列 $O=(o_1,o_2,…o_T)$ ； 输出：最有可能的隐藏状态序列 $I^*=\lbrace i_1^*,i_2^*,…i_T^*\rbrace$ ； 算法流程： 初始化局部状态（$t=1$）： \delta _1(i)=\pi _ib_{io_1}\ ,\ i=1,2,...N \psi _1(i)=0\ ,\ i=1,2,...N其中， $N​$ 表示隐藏状态的长度，在拼音转汉字的过程中对应汉字的长度。 这一步通过观察状态的初始概率，和对应的观察状态到隐藏状态的发射概率，得到初始时刻的局部概率。 递推，通过动态规划递推时刻 $t=2,3,…T$ 时刻的局部状态（$t&gt;1$）： \delta _t(i)=\max_{1\leq j\leq N}[\delta _{t-1}(j)a_{ji}]b_{io_t}\ ,\ i=1,2,...N \psi _t(i)=\arg\max _{1\leq j\leq N}[\delta _{t-1}(j)a_{ji}]\ ,\ i=1,2,...N其中，$i$ 表示当前时刻隐藏序列的各个状态，$j$ 表示前一时刻隐藏序列的各个状态。 当前状态节点的选取，是通过考虑所有的转移概率，包括当前的发射概率，以及前一时刻的局部概率，综合计算，最后记录最大值，同时也记录了最大概率对应的前一时刻的状态节点。 终止： P^*=\max _{1\leq i\leq N}\delta _T(i) i_T^*=\arg \max _{1\leq i\leq N}[\delta _T(i)]计算终止时刻 T 时刻最大的概率值$\delta _T(i)$，即为最佳隐藏状态序列出现的概率，计算终止时刻 T 时刻最大的$\psi _t(i)$，即为最佳的隐藏状态。 回溯最优路径，对$t=T-1,T-2,…,1$： i_t^*=\psi _{t+1}(i_{t+1}^*)按照此过程回溯整个网格，回溯完成时，就得到了生成给定观察序列的最可能的隐藏状态序列 $I^*=(i_1^*,i_2^*,…i_T^*)$。 Viterbi算法代码实现C++版 主要参考umdhmm代码实现。 HMM模型结构定义如下： 12345678910typedef struct &#123; int N; /* number of hidden states; Q=&#123;1,2,...,N&#125; */ int M; /* number of observation symbols; V=&#123;1,2,...,M&#125;*/ double **A; /* A[1..N][1..N]. a[i][j] is the transition prob of going from state i at time t to state j at time t+1 */ double **B; /* B[1..N][1..M]. b[j][k] is the probability of of observing symbol k in state j */ double *pi; /* pi[1..N] pi[i] is the initial state distribution. */&#125; HMM; Viterbi算法主流程实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void Viterbi(HMM *phmm, int T, int *O, double **delta, int **psi, int *q, double *pprob)&#123; int i, j; /* state indices */ int t; /* time index */ int maxvalind; double maxval, val; /* 1. Initialization */ for (i = 1; i &lt;= phmm-&gt;N; i++) &#123; delta[1][i] = phmm-&gt;pi[i] * (phmm-&gt;B[i][O[1]]); psi[1][i] = 0; &#125; /* 2. Recursion */ for (t = 2; t &lt;= T; t++) &#123; for (j = 1; j &lt;= phmm-&gt;N; j++) &#123; maxval = 0.0; maxvalind = 1; for (i = 1; i &lt;= phmm-&gt;N; i++) &#123; val = delta[t-1][i]*(phmm-&gt;A[i][j]); if (val &gt; maxval) &#123; maxval = val; maxvalind = i; &#125; &#125; delta[t][j] = maxval*(phmm-&gt;B[j][O[t]]); psi[t][j] = maxvalind; &#125; &#125; /* 3. Termination */ *pprob = 0.0; q[T] = 1; for (i = 1; i &lt;= phmm-&gt;N; i++) &#123; if (delta[T][i] &gt; *pprob) &#123; *pprob = delta[T][i]; q[T] = i; &#125; &#125; /* 4. Path (state sequence) backtracking */ for (t = T - 1; t &gt;= 1; t--) q[t] = psi[t+1][q[t+1]];&#125; 基于HMM实现拼音输入法主流程在拼音输入法的主要过程中，HMM模型可以通过以下过程得到： 对训练数据的所有内容按照单字分词，并统计每个词出现的频率，以此作为初始概率 $\pi​$ ; 将训练数据的所有汉字都转换成对应的拼音，统计每个拼音对应的汉字以及各自出现的频率，以此作为发射概率 $B​$ ; 统计训练数据中每个汉字后面出现的汉字的频率，以此作为隐藏状态的转移概率 $A$ ; 经过上述过程，即可得到一个隐马尔科夫模型 $\lambda(\pi,A,B)$ 。 在此基础上，使用Viterbi算法，对用户输入的拼音序列进行解码，即可得到最终的汉字序列。 在实际应用过程中，对于一些转移概率为0的情况，可以默认设置一个较小的转移概率来避免计算结果为0的情况；同时，对于未登录词，也可以通过设置较小的初始概率来解决概率为0的问题。 1. http://www.52nlp.cn/hmm-learn-best-practices-four-hidden-markov-models &#8617;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>HMM</tag>
        <tag>隐马</tag>
        <tag>Viterbi</tag>
        <tag>拼音输入法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Real Hello World]]></title>
    <url>%2F2019%2F02%2F27%2FmyHello%2F</url>
    <content type="text"><![CDATA[This is my real hello world from hexo. **Lesley Shi**]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
