<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python中list的一些小技巧]]></title>
    <url>%2F2019%2F03%2F20%2Fpython_list_tips%2F</url>
    <content type="text"><![CDATA[列表展开 12345678910111213141516171819202122232425262728import itertools################ case 1a = [[1, 2], [3, 4], [5, 6]]print list(itertools.chain.from_iterable(a))%timeit -n 10000 list(itertools.chain.from_iterable(a))print sum(a, [])%timeit -n 10000 sum(a, [])print [x for l in a for x in l]%timeit -n 10000 [x for l in a for x in l]# result:# [1, 2, 3, 4, 5, 6]# 10000 loops, best of 3: 801 ns per loop# [1, 2, 3, 4, 5, 6]# 10000 loops, best of 3: 359 ns per loop# [1, 2, 3, 4, 5, 6]# 10000 loops, best of 3: 371 ns per loop################ case 2b = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]][x for l1 in b for l2 in l1 for x in l2]# [1, 2, 3, 4, 5, 6, 7, 8]################ case 3a = [1, 2, [3, 4], [[5, 6], [7, 8]]]flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]flatten(a)# [1, 2, 3, 4, 5, 6, 7, 8] 相邻元素压缩&amp;依次相连12345678910111213# python3a = [1, 2, 3, 4, 5, 6]list(zip(*([iter(a)] * 2)))# [(1, 2), (3, 4), (5, 6)]list(zip(*([iter(a)] * 3)))# [(1, 2, 3), (4, 5, 6)]temp = ['a', 'b', 'c', 'd', 'e','f']list(zip(temp[:-1],temp[1:]))# [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')]list(zip(temp[:-2],temp[1:-1],temp[2:]))# [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中zip的一些内容]]></title>
    <url>%2F2019%2F03%2F19%2Fpython_zip%2F</url>
    <content type="text"><![CDATA[1、zip基本说明zip函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，返回由这些元组组成的列表。在Python3.x中为了减少内存，返回的是一个对象，可以用list()转换来输出列表。 如果各个迭代器的元素个数不一样，则返回列表长度与最短的对象相同，利用*号操作符，可以将元组解压为列表。 语法1zip([iterable, ...]) 参数： iterable：一个或多个迭代器； 返回值： 返回一个对象； 示例1234567891011121314151617a = [1,2,3]b = [4,5,6]c = [4,5,6,7,8]zipped = zip(a,b) # 返回一个对象zipped# &lt;zip object at 0x103abc288&gt;list(zipped) # list() 转换为列表# [(1, 4), (2, 5), (3, 6)]list(zip(a,c)) # 元素个数与最短的列表一致# [(1, 4), (2, 5), (3, 6)]a1, a2 = zip(*zip(a,b)) # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式，*是Python函数可变参数的一种表示形式，加*的表示传入一个元组对象进行解包list(a1)# [1, 2, 3]list(a2)# [4, 5, 6] 2、一些使用相邻元素压缩器12345a = [1, 2, 3, 4, 5, 6]list(zip(*([iter(a)] * 2)))# [(1, 2), (3, 4), (5, 6)]list(zip(*([iter(a)] * 3)))# [(1, 2, 3), (4, 5, 6)] 首先理解迭代器，iter()可以将一个序列生成为一个迭代器，迭代器的特点是可以用for in语句迭代。原理是迭代器对象有一个next方法，可以每次移动迭代的指针，一旦迭代完，没有下一个元素的时候，会触发一个StopIteration异常。迭代器的特点是，迭代了一次以后，指针就移动了，不会自动回溯。例如，可以用for in迭代列表无数次，但只能迭代一次迭代器，如下： 123456789101112131415&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; x = iter(a)&gt;&gt;&gt; for i in x:... print(i)... 123456&gt;&gt;&gt; for i in x:... print(i) # 因为x已经被迭代过了，迭代的指针不会回溯，所以没有值了... &gt;&gt;&gt; 而在上述相邻元素压缩器的使用过程中，可以发现： 12345a = [1, 2, 3, 4, 5, 6][iter(a)] * 3# [&lt;listiterator at 0x7fa6c00ec1d0&gt;,# &lt;listiterator at 0x7fa6c00ec1d0&gt;,# &lt;listiterator at 0x7fa6c00ec1d0&gt;] 三个迭代器实际上是同一个迭代器。 再来理解zip，如前文所述，zip将两个序列对应打包，如： 1234&gt;&gt;&gt; a1 = [1, 3, 5]&gt;&gt;&gt; a2 = [2, 4, 6]&gt;&gt;&gt; list(zip(a1, a2))[(1, 2), (3, 4), (5, 6)] 而*则表示传入一个对象进行解包，如： 12345&gt;&gt;&gt; t = (a1, a2)&gt;&gt;&gt; list(zip(t)) # 不加*号，zip 只有一个参数 t[([1, 3, 5],), ([2, 4, 6],)]&gt;&gt;&gt; list(zip(*t)) # 加*号的作用就是将元祖t，解包成a1,a2为zip的两个函数参数[(1, 2), (3, 4), (5, 6)] 最后理解为什么使用迭代器，如下： 12345678&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; x = iter(a)&gt;&gt;&gt; t = [a, a]&gt;&gt;&gt; list(zip(*t)) # case 1，不使用迭代器[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)] &gt;&gt;&gt; tx = [x, x] &gt;&gt;&gt; list(zip(*tx)) # case 2，使用迭代器[(1, 2), (3, 4), (5, 6)] 在case 1中，zip传入的两个参数a，等于打包了两个列表，并在zip(*)中进行解包，等价于： 1zip([1, 2, 3, 4, 5, 6],[1, 2, 3, 4, 5, 6]) 在case 2中，x是迭代器对象，迭代过程会调用next方法，迭代过一次后会自动移动且不会回溯。也就是说zip执行过程中先调用第一个参数x的next方法得到参数1，再调用第二个参数x的next方法，上文我们已知这两个迭代器其实是同一个迭代器对象，所以第二次调用x的next方法时，迭代器指针已经移动，所以得到参数2，整个过程类似如下： 123456x.next -&gt; 1x.next -&gt; 2zip(x.next(), x.next()) ---&gt; zip(1, 2)x.next -&gt; 3x.next -&gt; 4zip(x.next(), x.next()) ---&gt; zip(3, 4) 等价于： 1zip([1, 3, 5], [2, 4, 6]) 基于此，就可以理解使用zip做相邻元素压缩器的完整执行过程了。 列表元素依次相连 注意与相邻元素压缩器的效果区别。 12345temp = ['a', 'b', 'c', 'd', 'e','f']print(temp)# ['a', 'b', 'c', 'd', 'e', 'f']list(zip(temp[:-1],temp[1:]))# [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')] 这个用法比较好理解，temp[:-1]去除列表最后一个元素，temp[1:]去除列表第一个元素，则上述过程等价于： 1zip(['a', 'b', 'c', 'd', 'e'], ['b', 'c', 'd', 'e', 'f']) 基于该用法可衍生出多个元素依次相连的用法，如： 12list(zip(temp[:-2],temp[1:-1],temp[2:]))# [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')] 也可以用这种方法实现列表相邻元素压缩器的效果，如： 123a = [1, 2, 3, 4, 5, 6]list(zip(a[::3], a[1::3], a[2::3]))# [(1, 2, 3), (4, 5, 6)] 取列表相同位置元素12345678nums = ['flower','flow','flight']for i in zip(*nums): print(i)# ('f', 'f', 'f')# ('l', 'l', 'l')# ('o', 'o', 'i')# ('w', 'w', 'g') 反转字典123m = &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125;dict(zip(m.values(), m.keys()))# &#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>zip</tag>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】5、最长回文子串]]></title>
    <url>%2F2019%2F03%2F19%2Fleetcode_5%2F</url>
    <content type="text"><![CDATA[5、Longest Palindromic Substring最长回文子串 难度：中等 题目描述 英文： Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 中文： 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 解题思路思路一动态规划方法，维护一个二维数组$tags$，其中$tags[i][j]$表示字符串区间$[i,j]$是否为回文串，当$i=j$时，字符串只有一个字符，肯定是回文串，当$j=i+1$时，字符串为相邻的两个字符，需要判断$s[i]$是否等于$s[j]$，如果$i$和$j$不相邻，即$j-i\ge2$时，除了判断$s[i]$和$s[j]$是否相等，还要判断$tags[i+1][j-1]$是否为真，则有如下递推式： tags[i][j]= \begin{cases} 1, & \text{if $i==j$}\\ s[i]==s[j],&\text{if $j=i+1$}\\ s[i]==s[j]\ \&\&\ tags[i+1][j-1],& \text{if $j>i+1$} \end{cases}代码提交 Python3，用时6708ms，内存21.9M 时间复杂度：$O(n^2)$ 123456789101112131415161718192021222324class Solution: def longestPalindrome(self, s): length = len(s) if length &lt;= 1: return s # 初始化二维数组 tags # 不可以用 tags = [[False]*length]*length 的方式，深浅拷贝 tags = [[False for col in range(length)] for row in range(length)] left = 0 right = 0 templen = 0 for j in range(length): # if i==j tags[j][j] = True # j &gt; i for i in range(j): tags[i][j] = (s[i] == s[j] and (j-i &lt; 2 or tags[i+1][j-1])) # 更新当前记录的最长回文子串信息 if tags[i][j] and templen &lt; j-i+1: left = i right = j templen = j-i+1 return s[left:right+1] 思路二参考链接 弱鸡的讲说，这个思路是一致的，但是代码没太看明白。。。 根据回文的特性，一个大回文按比例缩小后的字符串也必定是回文，比如ABCCBA，那BCCB肯定也是回文。所以我们可以根据动态规划的两个特点：（1）把大问题拆解为小问题（2）重复利用之前的计算结果这道题。如何划分小问题，我们可以先把所有长度最短为1的子字符串计算出来，根据起始位置从左向右，这些必定是回文。然后计算所有长度为2的子字符串，再根据起始位置从左向右。到长度为3的时候，我们就可以利用上次的计算结果：如果中心对称的短字符串不是回文，那长字符串也不是，如果短字符串是回文，那就要看长字符串两头是否一样。这样，一直到长度最大的子字符串，我们就把整个字符串集穷举完了。 代码提交 Python3，用时160ms，内存13M 12345678910111213141516171819202122232425class Solution: def longestPalindrome(self, s): # 使用动态规划，用空间换时间，把问题拆分 # 获取字符串s的长度 str_length = len(s) # 记录最大字符串长度 max_length = 0 # 记录位置 start = 0 # 循环遍历字符串的每一个字符 for i in range(str_length): # 如果当前循环次数-当前最大长度大于等于1 并 字符串[当前循环次数-当前最大长度-1:当前循环次数+1] == 取反后字符串 if i - max_length &gt;= 1 and s[i-max_length-1: i+1] == s[i-max_length-1: i+1][::-1]: # 记录当前开始位置 start = i - max_length - 1 # 取字符串最小长度为2，所以+=2，s[i-max_length-1: i+1] max_length += 2 continue # 如果当前循环次数-当前最大长度大于等于0 并 字符串[当前循环次数-当前最大长度:当前循环次数+1] == 取反后字符串 if i - max_length &gt;= 0 and s[i-max_length: i+1] == s[i-max_length: i+1][::-1]: start = i - max_length # 取字符串最小长度为1，所以+=1，s[i-max_length: i+1] max_length += 1 # 返回最长回文子串 return s[start: start + max_length] 思路三解决最长回文子串的一个时间复杂度为$O (n)$的算法——Manacher算法。 还没有仔细看，应该是针对该问题的一个比较巧妙的算法。 可参考：最长回文子串——Manacher 算法，LeetCode]最长回文子串（Longest Palindromic Substring）。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】213、打家劫舍II]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode_213%2F</url>
    <content type="text"><![CDATA[213、House Robber II打家劫舍II 难度：中等 题目描述 英文： You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 中文： 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 Example 1: 12345678Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 Example 2: 123456789Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 解题思路思路一相比“打家劫舍I”多了首尾不能相连的限制，可以通过对1~n-1和2~n两个序列分别按“打家劫舍I”的思路计算一遍，最后取最大值返回即可。 顺序遍历整个数组，当遍历到第i个值时，有两种情况： 之前遍历过程中的curSum始终大于0，假设当前子序列为a,a+1,a+2,...,b-2,b-1,b，此时考虑所有可能： 以当前子序列开头为开头，以中间任一处结尾的序列，如a,a+1,a+2,...b-2：这种情况一致在遍历过程中保存更新； 以当前子序列结尾为结尾，以中间任一处开头的序列，如a+2,...,b-2,b-1,b：这种情况一定小于当前的完整子序列的和，因为前面缺失的部分的和一定是大于0的（讨论的前提就是遍历过程加和始终大于0）； 以中间元素为开头和结尾的序列，如a+2,...,b-2：这种情况，首先按照前一条讨论，补全前面缺失的部分，之后就变成了第一条讨论的情况； 也就是说，i前面的所有可能序列情况都已经考虑到了； curSum出现小于0的情况，此时由于已遍历过的连续子序列加和&lt;0，则遍历过的这个连续子序列不能完整的被包含到新形成的序列中了；而是否要全部放弃，还是保留末尾的部分元素？参考之前的讨论，以当前子序列结尾为结尾，以中间任一处开头的序列的加和是小于完整子序列的，也就是说是&lt;0的，因为此时遍历过的连续子序列需要全部放弃，即curSum置0，并重新开始累加。 其中，每次curSum&lt;0时的下一位置即为和最大的子序列的开始，每次curSum&gt;maxSum时的位置即为和最大的子序列的结尾。 代码提交 Python3，用时56ms，内存13.2M 123456789101112131415161718class Solution: def rob1(self, nums): if not nums: return 0 if len(nums) == 1: return nums[0] temp = [nums[0], max(nums[0], nums[1])] for i in range(2, len(nums)): temp.extend([max(temp[i-1], temp[i-2]+nums[i])]) return temp[-1] def rob(self, nums): if not nums: return 0 if len(nums) == 1: return nums[0] return max(self.rob1(nums[1:]), self.rob1(nums[:-1]))]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】198、打家劫舍]]></title>
    <url>%2F2019%2F03%2F15%2Fleetcode_198%2F</url>
    <content type="text"><![CDATA[198、House Robber打家劫舍 难度：简单 题目描述 英文： You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 中文： 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 Example 1: 12345678910Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 Example 2: 12345678910Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路思路一动态规划，根据题意，不能窃取相邻的房屋，那么第$n$天的最高金额，要么等于第$n-1$天的最高金额，要么等于$n-2$天的最高金额加上第$n$天可获得的金额。 用$f (n)$表示第$n$天的最高金额，$p_n$表示第$n$天可获得的金额，则$f (n) = \max (f(n-1) , f(n-2)+p_n)$，其中，$f(1) = p_1 , f(2)=\max (p_1, p_2)​$。 Ps. 开始简单的以为，就是奇数位求和，偶数位求和，然后取最大值，后来发现不对，只要求有间隔，但间隔不一定为1，如测试用例[2,1,1,2]，则间隔为2，取首尾两个元素时为最大值。 代码提交 Python3，用时64ms，内存13.1M 时间复杂度：$O (n) ​$ 1234567891011class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] temp = [nums[0], max(nums[0], nums[1])] for i in range(2, len(nums)): temp.append(max(temp[i-1], temp[i-2]+nums[i])) return temp[-1] 在Python中，list添加元素的方法，expend效率要高于append，调整后，用时52ms，如下： 1234567891011class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] temp = [nums[0], max(nums[0], nums[1])] for i in range(2, len(nums)): temp.extend([max(temp[i-1], temp[i-2]+nums[i])]) return temp[-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】121、买卖股票的最佳时机]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode_121%2F</url>
    <content type="text"><![CDATA[121、Best Time to Buy and Sell Stock买卖股票的最佳时机 难度：简单 题目描述 英文： Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. 中文： 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 Example 1: 123456789Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 Example 2: 1234567Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路思路一动态规划问题，第$i$天的最高利润，要么等于前$i-1$天的最高利润，要么等于第$i$天的卖出价减去前$i-1$天的最低买入价。 用$f (i)$表示第$i$天的最高利润，$p_i$表示第$i$天的价格，则$f (i) = \max ( f(i-1) , p_i - \min (p_1,p_2,…,p_{i-1}) )$。 要注意卖出价高于买入价的限制。 代码提交 Python3，用时6040ms，内存14.2M 1234567891011class Solution: def maxProfit(self, prices: List[int]) -&gt; int: length = len(prices) if length &lt;= 1: return 0 temp = [prices[1]-prices[0]] for i in range(1, length): temp.append(max(temp[i-1], prices[i]-min(prices[:i]), 0)) return temp[-1] 每次都会判断前$i-1$天的最低价，可以将最低价进行保存。 Python3，用时104ms，内存14M 1234567891011121314class Solution: def maxProfit(self, prices: List[int]) -&gt; int: length = len(prices) if length &lt;= 1: return 0 temp = [prices[1]-prices[0]] tempMin = prices[0] for i in range(1, length): if prices[i] &lt; tempMin: tempMin = prices[i] temp.append(max(temp[i-1], prices[i]-tempMin)) return temp[-1] 思路二遍历数组，寻找最低价之后的最高收益。 判断第$i$天的价格，是否是当前最低价，不是最低价则判断是否可获得当前最大收益（获得当前最大收益的节点不一定是当前最高价的节点，当前最高价可能出现在最低价之前，所以无法更新最低价的时候，判断收益而不是试图更新最高价）。 代码提交 Python3，用时80ms，内存13.8M 12345678910111213141516class Solution: import sys def maxProfit(self, prices: List[int]) -&gt; int: length = len(prices) if length &lt;= 1: return 0 tempMin = sys.maxsize tempMax = 0 for i in prices: if i &lt; tempMin: tempMin = i elif i-tempMin &gt; tempMax: tempMax = i-tempMin return tempMax]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】70、爬楼梯]]></title>
    <url>%2F2019%2F03%2F14%2Fleetcode_70%2F</url>
    <content type="text"><![CDATA[70、Climbing Stairs爬楼梯 难度：简单 题目描述 英文： You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 中文： 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 Example 1: 12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2: 123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 解题思路思路一动态规划问题，直接递归，用$f (n)$表示到达第$n$阶时的方法数，共有两种爬楼方式（一次一阶，一次两阶），那么到达第$n$阶可以通过“到达第$n-1$阶后再走一次一阶”和“到达第$n-2$阶后再走一次两阶”两种方式，那么只需要考虑到达$n-1$阶和$n-2$阶各有多少种方法即可，即$f(n) = f(n-1) + f(n-2)$，终止条件为$f(1) = 1 , f(2)=2$。 代码提交 Python3，超时 时间复杂度：T(n) = O(1.618 ^ n)（1.618就是黄金分割，(1+5–√)/2(1+5)/2）。 空间复杂度取决于递归的深度，显然是O(n)。 1234567class Solution: def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 if n == 2: return 2 return self.climbStairs(n-1) + self.climbStairs(n-2) 直接递归的方法重复计算太多，直接超时，将计算过的结果进行缓存，使用递归的方式，如下： Python3，用时80ms，内存13.2M 时间复杂度是O(n) 空间复杂度是O(1) 12345678910class Solution: def climbStairs(self, n: int) -&gt; int: if n == 1: return 1 if n == 2: return 2 tempNum = [0,1,2] for i in range(3, n+1): tempNum.append(tempNum[i-1] + tempNum[i-2]) return tempNum[n] 思路二递归表达式及终止条件值符合斐波那契数列。其实跟上面的方法差不多。 代码提交 Python3，用时52ms，内存13.1M 时间复杂性：$O (n)​$ 1234567class Solution: def climbStairs(self, n: int) -&gt; int: a = 0 b = 1 for i in range(n+1): a, b = a + b, a return a]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】53、最大子序和]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_53%2F</url>
    <content type="text"><![CDATA[53、Maximum Subarray最大子序和 难度：简单 题目描述 英文： Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. 中文： 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. 进阶 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路思路一遍历数组，用curSum维护当前位置累加的和，当curSum&lt;0时，将其置为0，重新开始累加，每次都更新全局最大值。 顺序遍历整个数组，当遍历到第i个值时，有两种情况： 之前遍历过程中的curSum始终大于0，假设当前子序列为a,a+1,a+2,...,b-2,b-1,b，此时考虑所有可能： 以当前子序列开头为开头，以中间任一处结尾的序列，如a,a+1,a+2,...b-2：这种情况一致在遍历过程中保存更新； 以当前子序列结尾为结尾，以中间任一处开头的序列，如a+2,...,b-2,b-1,b：这种情况一定小于当前的完整子序列的和，因为前面缺失的部分的和一定是大于0的（讨论的前提就是遍历过程加和始终大于0）； 以中间元素为开头和结尾的序列，如a+2,...,b-2：这种情况，首先按照前一条讨论，补全前面缺失的部分，之后就变成了第一条讨论的情况； 也就是说，i前面的所有可能序列情况都已经考虑到了； curSum出现小于0的情况，此时由于已遍历过的连续子序列加和&lt;0，则遍历过的这个连续子序列不能完整的被包含到新形成的序列中了；而是否要全部放弃，还是保留末尾的部分元素？参考之前的讨论，以当前子序列结尾为结尾，以中间任一处开头的序列的加和是小于完整子序列的，也就是说是&lt;0的，因为此时遍历过的连续子序列需要全部放弃，即curSum置0，并重新开始累加。 其中，每次curSum&lt;0时的下一位置即为和最大的子序列的开始，每次curSum&gt;maxSum时的位置即为和最大的子序列的结尾。 代码提交 Python3，用时96ms，内存13.6M 时间复杂度：$O (n) $ 123456789101112131415class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] maxSum = nums[0] curSum = 0 for i in range(len(nums)): curSum += nums[i] maxSum = max(maxSum, curSum) if curSum &lt; 0: curSum = 0 return maxSum 思路二动态规划，用tempSum保存以第i个元素结尾的最大连续子序列的和，假设对于元素i，其前面的所有元素结尾的序列和都已经得到，则以第i个元素结尾的子序列的和要么是以第i-1个元素结尾的和最大的子序列加上当前元素，要么就是当前元素本身，即tempSum[i] = max(tempSum[i-1]+nums[i], nums[i])。（实际等价于看以i-1个元素结尾的和最大的子序列的和是否小于0，等价于思路一了）当i=0时，最大子序列和即为tempSum[0] = nums[0]。 代码提交 Python3，用时104ms，内存14.2M 时间复杂度：$O (n) ​$ 123456789101112class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] tempSum = [] tempSum.append(nums[0]) for i in range(1, len(nums)): tempSum.append(max(tempSum[i-1]+nums[i], nums[i])) return max(tempSum) 可以直接用nums来保存子序列最大和，能节约一点内存，如下： 12345678910class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] for i in range(1, len(nums)): nums[i] = max(nums[i-1]+nums[i], nums[i]) return max(nums) 思路三提示说可以尝试用分治法，那么就将整个数组不断切分成子数组，最后选最大值返回。 用二分法切分数组，最大子序和要么在左半部分，要么在右半部分，要么横跨左右两部分（既包含左侧的最后一个元素，也包含右侧的第一个元素），返回这三种情况的最大值即可。 横跨左右两部分的情况，可以从中间位置逐次向左右两侧遍历，并更新最大值。 代码提交 Python3，用时272ms，内存13.7M 时间复杂度：$O(n\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: if not nums: return None if len(nums) == 1: return nums[0] left = 0 right = len(nums)-1 maxSum = self.divide(nums, left, right) return maxSum def divide(self, nums, left, right): # 切分到只有一个元素时，返回 if left == right: return nums[left] # 确立中心点 center = (left + right)//2 # 子序列完全在左侧的最大和 leftMax = self.divide(nums, left, center) # 子序列完全在右侧的最大和 rightMax = self.divide(nums, center+1, right) # 子序列横跨左右两侧的最大和 # 从中间点逐次向左边界靠近 leftSum = 0 leftBorderSum = 0 for i in range(center-1, left-1, -1): leftSum += nums[i] leftBorderSum = max(leftSum, leftBorderSum) # 从中间点逐次向右边界靠近 rightSum = 0 rightBorderSum = 0 for i in range(center+1, right+1): rightSum += nums[i] rightBorderSum = max(rightSum, rightBorderSum) centerMax = leftBorderSum + nums[center] + rightBorderSum return max(leftMax, centerMax, rightMax)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】136、只出现一次的数字]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_136%2F</url>
    <content type="text"><![CDATA[136、Single Number只出现一次的数字 难度：简单 题目描述 英文： Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 中文： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 Example 1: 12Input: [2,2,1]Output: 1 Example 2: 12Input: [4,1,2,1,2]Output: 4 解题思路思路一只有一个元素只出现一次，其余元素都出现两次，所以可以先对原数组去重并求和，再用两倍的和减去原数组的和，得到的结果就是只出现一次的元素值。 只适合只有一个元素次数不同的情况，且使用了额外空间。 代码提交 Python2，用时44ms，内存12.6M 1234567class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ return 2 * sum(set(nums)) - sum(nums) 思路二利用位运算的异或操作，任何数字异或其自身都等于零，任何数字异或零还等于其本身。 题目只有一个元素出现一次，其余元素都出现两次，出现两次的元素异或结果都为零，剩余一个出现一次的元素，与零异或后结果还是其本身，也就是说对所有元素进行异或操作后，结果即为只出现一次的那一个元素值。 代码提交 Python2，用时44ms，内存12.2M 看提交情况，用时最短的代码也是这个思路，约24ms，所以用时可能也和其他一些系统随机因素有关系吧。 12345678910class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ temp = 0 for i in nums: temp ^= i return temp]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】414、第三大的数]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_414%2F</url>
    <content type="text"><![CDATA[414、Third Maximum Number第三大的数 难度：简单 题目描述 英文： Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). 中文： 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例Example 1: 12345Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1. Example 2: 12345Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead. Example 3: 123456Input: [2, 2, 3, 1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 解题思路利用三个变量分别记录数组第1、2、3大的数字，遍历一遍数组即可更新前三大的数，时间复杂度O(n)。 引申出的top-k问题，以及解决top-k问题的BFPRT算法，后续再详细记录。 代码提交 Python2，用时28ms，内存11.1M 123456789101112131415class Solution(object): def thirdMax(self, nums): """ :type nums: List[int] :rtype: int """ first = second = third = None for temp in nums: if temp &gt; first: first, second, third = temp, first, second elif first &gt; temp &gt; second: second, third = temp, second elif second &gt; temp &gt; third: third = temp return third if third is not None else first TipsNone]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python各种排序]]></title>
    <url>%2F2019%2F03%2F13%2Fpython_lambda_sorted%2F</url>
    <content type="text"><![CDATA[0、基础 主要用到list.sort()、sorted()、lambda进行各种排序操作。 其中：list.sort()是Python列表的一个内置排序方法，只供list结构使用，list.sort()方法排序时直接修改原列表，返回None。而sorted()函数接受一切迭代器，返回新列表。 相比list.sort()，sorted()使用范围更广，但是如果不需要保留原列表的情况下对列表排序，可以选择list.sort()方法，不需要复制原有列表，消耗内存小，效率也较高。 list.sort()list.sort()函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。 语法1list.sort(cmp=None, key=None, reverse=False) 参数 cmp：可选参数，如果指定了该参数则使用该参数的方法进行排序，Python3取消了该参数； key：用来进行比较的元素，取自可迭代对象中，指定可迭代对象中的一个元素来进行排序； reverse：排序规则，True降序，False升序（默认）； 返回值 该方法直接修改原列表，返回None； 示例12345678910111213# 列表排序test = ['Google', 'Runoob', 'Taobao', 'Facebook']test.sort()print(test)# result:# ['Facebook', 'Google', 'Runoob', 'Taobao']# 列表降序排序vowels = ['e', 'a', 'u', 'o', 'i']vowels.sort(reverse=True)print (vowels)# result:# ['u', 'o', 'i', 'e', 'a'] sorted()sorted()函数对所有可迭代对象进行排序操作。 语法1sorted(iterable, key=None, reverse=False) 参数 iterable：可迭代对象； key：用来进行比较的元素，取自可迭代对象中，指定可迭代对象中的一个元素来进行排序； reverse：排序规则，True降序，False升序（默认）； 返回值 返回排序好的列表； 示例12345678910# 排序sorted([5, 2, 3, 1, 4])# result：# [1, 2, 3, 4, 5]# 降序排序example_list = [5, 0, 6, 1, 2, 7, 3, 4]sorted(example_list, reverse=True)# result：# [7, 6, 5, 4, 3, 2, 1, 0] lambdaPython使用lambda创建匿名函数，即不使用def这样的标准语句来定义函数，允许快速定义单行函数，类似于C语言的宏，可以用在任何需要函数的地方。 lambda的主体是一个表达式，而不是一个代码块，仅能在其中封装有限的逻辑； lambda函数拥有自己的命名空间，不能访问参数列表之外或全局命名空间里的参数； lambda并不会带来程序效率的提高，只是使代码更简洁？ 语法1lambda [arg1 [,arg2,.....argn]]:expression 上述用法等价于： 12def &lt;lambda&gt;(arg1 [,arg2,......argn]): return expression 示例123456789sum = lambda arg1, arg2: arg1 + arg2 # 调用sum函数print ("sum(10,20) = ", sum( 10, 20 ))print ("sum(20,30) = ", sum( 20, 30 ))# result:# sum(10,20) = 30# sum(20,30) = 50 1、各种排序 参考链接 1.1、list排序12345678910111213lis = ['a', 'b', 'c']print(sorted(lis))# ['a', 'b', 'c']print(sorted(lis, reverse=True))# ['c', 'b', 'a']lis.sort()print(lis)# ['a', 'b', 'c']lis.sort(reverse=True)print(lis)# ['c', 'b', 'a'] 1.2、dict按key排序12345dic = &#123;'c': 1, 'b': 2, 'a': 3&#125;print(sorted(dic))# ['a', 'b', 'c']print(sorted(dic, reverse=True))# ['c', 'b', 'a'] 1.3、dict按value排序12345dic = &#123;'c': 1, 'b': 2, 'a': 3&#125;print(sorted(dic, key=lambda k: dic[k]))# ['c', 'b', 'a']print(sorted(dic, key=lambda k: dic[k], reverse=True))# ['a', 'b', 'c'] 1.4、list内嵌套list排序123456789lis = [[4, 2, 9], [1, 5, 6], [7, 8, 3]]print(sorted(lis, key=lambda k: k[0]))# [[1, 5, 6], [4, 2, 9], [7, 8, 3]]print(sorted(lis, key=lambda k: k[1]))# [[4, 2, 9], [1, 5, 6], [7, 8, 3]]print(sorted(lis, key=lambda k: k[2]))# [[7, 8, 3], [1, 5, 6], [4, 2, 9]]print(sorted(lis, key=lambda k: k[0], reverse=True))# [[7, 8, 3], [4, 2, 9], [1, 5, 6]] 1.5、dict内嵌套dict排序12345678910111213dic = &#123; 'a': &#123;'x': 3, 'y': 2, 'z': 1&#125;, 'b': &#123;'x': 2, 'y': 1, 'z': 3&#125;, 'c': &#123;'x': 1, 'y': 3, 'z': 2&#125;,&#125;print(sorted(dic, key=lambda k: dic[k]['x']))# ['c', 'b', 'a']print(sorted(dic, key=lambda k: dic[k]['y']))# ['b', 'a', 'c']print(sorted(dic, key=lambda k: dic[k]['z']))# ['a', 'c', 'b']print(sorted(dic, key=lambda k: dic[k]['x'], reverse=True))# ['a', 'b', 'c'] 1.6、list内嵌套dict排序12345678910111213lis = [ &#123;'x': 3, 'y': 2, 'z': 1&#125;, &#123;'x': 2, 'y': 1, 'z': 3&#125;, &#123;'x': 1, 'y': 3, 'z': 2&#125;,]print(sorted(lis, key=lambda k: k['x']))# [&#123;'z': 2, 'x': 1, 'y': 3&#125;, &#123;'z': 3, 'x': 2, 'y': 1&#125;, &#123;'z': 1, 'x': 3, 'y': 2&#125;]print(sorted(lis, key=lambda k: k['y']))# [&#123;'z': 3, 'x': 2, 'y': 1&#125;, &#123;'z': 1, 'x': 3, 'y': 2&#125;, &#123;'z': 2, 'x': 1, 'y': 3&#125;]print(sorted(lis, key=lambda k: k['z']))# [&#123;'z': 1, 'x': 3, 'y': 2&#125;, &#123;'z': 2, 'x': 1, 'y': 3&#125;, &#123;'z': 3, 'x': 2, 'y': 1&#125;]print(sorted(lis, key=lambda k: k['x'], reverse=True))# [&#123;'z': 1, 'x': 3, 'y': 2&#125;, &#123;'z': 3, 'x': 2, 'y': 1&#125;, &#123;'z': 2, 'x': 1, 'y': 3&#125;] 1.7、dict内嵌套list排序12345678910111213dic = &#123; 'a': [1, 2, 3], 'b': [2, 1, 3], 'c': [3, 1, 2],&#125;print(sorted(dic, key=lambda k: dic[k][0]))# ['a', 'b', 'c']print(sorted(dic, key=lambda k: dic[k][1]))# ['b', 'c', 'a']print(sorted(dic, key=lambda k: dic[k][2]))# ['c', 'b', 'a']print(sorted(dic, key=lambda k: dic[k][0], reverse=True))# ['c', 'b', 'a'] 1.8、按照多个参数排序使用operator模块的itemgetter()实现。 1234567891011from operator import itemgetterstudent_tuples = [('john', 'A', 15),('jane', 'B', 12),('dave', 'B', 10)]print (sorted(student_tuples, key = itemgetter(2))) # 根据年龄排序print (sorted(student_tuples, key = itemgetter(1, 2))) # 根据成绩和年龄排序print (sorted(student_tuples, key = itemgetter(1, 2), reverse=True)) # 反转排序结果# result:# [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]# [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]# [('jane', 'B', 12), ('dave', 'B', 10), ('john', 'A', 15)] 2、其他list排序可视情况采用sorted()或list.sort()，其他各种排序主要是sorted()和lambda的结合操作； dict的排序只取其key，所以需要对value操作时需要在lambda中先转换为对应的value才可以； 排序是稳定的，即如果多个元素有相同的key，则排序前后其先后顺序不变；]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>lambda</tag>
        <tag>排序</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】937、重新排列日志文件]]></title>
    <url>%2F2019%2F03%2F13%2Fleetcode_937%2F</url>
    <content type="text"><![CDATA[937、Reorder Log Files重新排列日志文件 难度：简单 题目描述 英文： You have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs. It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order. Return the final order of the logs. 中文： 你有一个日志数组 logs。每条日志都是以空格分隔的字串。 对于每条日志，其第一个字为字母数字标识符。然后，要么： 标识符后面的每个字将仅由小写字母组成，或； 标识符后面的每个字将仅由数字组成。 我们将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。 将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按字母顺序排序，忽略标识符，标识符仅用于表示关系。数字日志应该按原来的顺序排列。 返回日志的最终顺序。 提示 0 &lt;= logs.length &lt;= 100 3 &lt;= logs[i].length &lt;= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier. 示例Example 1: 12Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;] 解题思路思路一先区分数字日志和字母日志，然后字母日志按内容排序，最后合并两部分内容输出。 代码提交 Python2，用时48ms，内存11.1M 1234567891011121314151617class Solution(object): def reorderLogFiles(self, logs): """ :type logs: List[str] :rtype: List[str] """ letterList = [] numberList = [] for log in logs: logList = log.split(" ") if logList[1].isdigit(): numberList.append(log) else: letterList.append((logList[0], " ".join(logList[1:]))) letterList.sort(key=lambda x:x[1]) resultList = [" ".join(a) for a in letterList] return resultList+numberList 后来看了一下用时短的代码，方法都很简单，但是代码很简洁高效。 用0、1标记字母、数字日志，之后一次排序返回。 Python2，用时36ms，内存11.1M 1234567891011class Solution(object): def reorderLogFiles(self, logs): """ :type logs: List[str] :rtype: List[str] """ def f(log): id, rest = log.split(' ', 1) return (0, rest) if rest[0].isalpha() else (1,) return sorted(logs, key = f)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】936、戳印序列]]></title>
    <url>%2F2019%2F03%2F12%2Fleetcode_936%2F</url>
    <content type="text"><![CDATA[936、Stamping The Sequence戳印序列 难度：困难 题目描述 英文： You want to form a target string of lowercase letters. At the beginning, your sequence is target.length &#39;?&#39; marks. You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp. You can make up to 10 * target.length turns. For example, if the initial sequence is “?????”, and your stamp is &quot;abc&quot;, then you may make “abc??”, “?abc?”, “??abc” in the first turn. (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn. If the sequence is not possible to stamp, return an empty array. For example, if the sequence is “ababc”, and the stamp is &quot;abc&quot;, then we could return the answer [0, 2], corresponding to the moves “?????” -&gt; “abc??” -&gt; “ababc”. Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves. Any answers specifying more than this number of moves will not be accepted. 中文： 你想要用小写字母组成一个目标字符串 target。 开始的时候，序列由 target.length 个 &#39;?&#39; 记号组成。而你有一个小写字母印章 stamp。 在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 10 * target.length 个回合。 举个例子，如果初始序列为 “?????”，而你的印章 stamp 是 &quot;abc&quot;，那么在第一回合，你可以得到 “abc??”、”?abc?”、”??abc”。（请注意，印章必须完全包含在序列的边界内才能盖下去。） 如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。 例如，如果序列是 “ababc”，印章是 &quot;abc&quot;，那么我们就可以返回与操作 “?????” -&gt; “abc??” -&gt; “ababc” 相对应的答案 [0, 2]； 另外，如果可以印出序列，那么需要保证可以在 10 * target.length 个回合内完成。任何超过此数字的答案将不被接受。 提示 1 &lt;= stamp.length &lt;= target.length &lt;= 1000 stamp 和 target 只包含小写字母。 示例Example 1: 123Input: stamp = &quot;abc&quot;, target = &quot;ababc&quot;Output: [0,2]([1,0,2] would also be accepted as an answer, as well as some other answers.) Example 2: 12Input: stamp = &quot;abca&quot;, target = &quot;aabcaca&quot;Output: [3,0,1] 解题思路思路一题目是从?????到ababc的问题，替换时要考虑会覆盖到已经替换好的部分。可以逆向替换，从ababc到?????，?可以看做通配符，遍历target，逐位和stamp比较，如果可以匹配到，则记录当时的index，并修改覆盖后的字符，循环上述过程，直到得到了?????序列或无法继续匹配下去。 例如，stamp=&#39;abca&#39;，target=&#39;aabcaca&#39;，则整个替换过程为aabcaca =&gt; a????ca =&gt; ?????ca =&gt; ???????，替换位置索引序列为1-&gt;0-&gt;3，所以题目所求的序列即为[3,0,1]。 代码提交 Python2，用时6480ms，内存10.9M 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object): def movesToStamp(self, stamp, target): """ :type stamp: str :type target: str :rtype: List[int] """ # 如果target首尾字符和stamp不同，则肯定无法覆盖，直接返回[] if target[0] != stamp[0] or target[-1] != stamp[-1]: return [] slen, tlen = len(stamp), len(target) temptarget = target res = [] # 检查是否可以stamp一次，返回索引 def checkstamp(temptarget): # 遍历target，并记录可以覆盖的位置索引index for index in range(tlen): hasletter, stampj, tempi = False, 0, index # 遍历stamp，并对比target[index:index+len(stamp)]是否可以覆盖 while stampj &lt; slen and tempi &lt; tlen and (temptarget[tempi] == "?" or temptarget[tempi] == stamp[stampj]): # 待覆盖内容包含非“?”内容，不匹配完全由“?”组成的内容 if temptarget[tempi] == stamp[stampj]: hasletter = True stampj += 1 tempi += 1 # 修改覆盖后的target if hasletter and stampj == slen: temptarget = temptarget[:index] + "?"*slen + temptarget[index+slen:] return index, temptarget return -1, temptarget # 到完全覆盖时停止 while temptarget != "?"*tlen: temp, temptarget = checkstamp(temptarget) if temp == -1: return [] res.append(temp) # 返回逆序序列 return res[::-1] 思路二参考链接 上述方法一的checkstamp过程有很多重复计算，事实上不需要每次都从头开始遍历，可以进行一些优化。 只进行一次字符串匹配的循环，在时间进行了优化，相应的内存消耗增加。记录每一个位置 i 对应长度为lenS的字符串上有哪些部分是能对应的，哪些些是不对应的。再将完全对应的字符串的位置全部压入队列。 在队列中的每一个位置都是已匹配位置，在change中声明当前位置已匹配，之后考虑当前位置改动后可能会产生影响的所有位置 i 对应的长度为lenS的字符串。 代码提交 Python2，用时436ms，内存14.4M 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import collectionsclass Solution(object): def movesToStamp(self, stamp, target): """ :type stamp: str :type target: str :rtype: List[int] """ M, N = len(stamp), len(target) queue = collections.deque() done = [False] * N ans = [] A = [] for i in range(N - M + 1): # For each window [i, i+M), # A[i] will contain info on what needs to change # before we can reverse stamp at i. made, todo = set(), set() for j, c in enumerate(stamp): a = target[i+j] if a == c: made.add(i+j) else: todo.add(i+j) A.append((made, todo)) # If we can reverse stamp at i immediately, # enqueue letters from this window. if not todo: ans.append(i) for j in range(i, i + len(stamp)): if not done[j]: queue.append(j) done[j] = True # For each enqueued letter, while queue: i = queue.popleft() # For each window that is potentially affected, # j: start of window for j in range(max(0, i-M+1), min(N-M, i)+1): if i in A[j][1]: # This window is affected A[j][1].discard(i) # Remove it from todo list of this window if not A[j][1]: # Todo list of this window is empty ans.append(j) for m in A[j][0]: # For each letter to potentially enqueue, if not done[m]: queue.append(m) done[m] = True return ans[::-1] if all(done) else []]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异或操作&位运算]]></title>
    <url>%2F2019%2F03%2F07%2Fweiyunsuan%2F</url>
    <content type="text"><![CDATA[做题时用到了按位异或的操作，有点蒙蒙的，大概查了查位运算的一些东西，略作总结，主要以Python为例。 参考链接 位运算简介位运算是把数字用二进制表示之后，对每一位上0或1的运算。 所有的运算（包括位运算）在计算机内部都是通过补码的形式进行运算的。 补码是计算机表示数据的一般方式，其规则为：如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码加上1(相当于将原码数值位取反然后在最低位加1)。 例如： 数字 6 在8位计算机中的补码为：0000 0110 （即为其原码） 数字 -6 在8位计算机中的补码为：1111 1010 主要的位运算总共有6种：与、或、异或、取反、左移、右移，如下表所示： 表中示例： a=60，二进制表示 0011 1100 b=13，二进制表示 0000 1101 运算符 描述 示例 &amp; 按位与：参与运算的两个值，如果两个对应位都为1，则该位的结果为1，否则为0； (a&amp;b)结果为12，二进制 0000 1100 \ 按位或：只要对应的两个二进制位中有一个为1时，该位的结果就为1； (a\ b)结果为61，二进制 0011 1101 ^ 按位异或：当两个对应的二进制位不同时，该位的结果为1； (a^b)结果为49，二进制 0011 0001 ~ 按位取反：对数据的每个二进制位取反，即把1变成0，把0变成1； (~a)结果为 -61，二进制 1100 0011（有符号二进制数的补码形式） \&lt;\&lt; 按位左移：数据的每个二进制位均左移若干位，\&lt;\&lt;右边的数字指定移动位数，高位丢弃，低位补0； (a\&lt;\&lt;2)结果为240，二进制 1111 0000 >> 按位右移：数据的每个二进制位均右移若干位，>>右边的数字指定移动位数，具体见下文； (a>>2)结果为15，二进制 0000 1111 左移运算符：m\&lt;\&lt;n 表示把 m 左移 n 位，最左边的 n 位被丢弃，同时在最右边补上 n 个0，如下： 1200001010 &lt;&lt; 2 = 0010100010001010 &lt;&lt; 3 = 01010000 右移运算符：m>>n 表示把 m 右移 n 位，最右边的 n 位被丢弃，但最左边的处理方式有所不同：如果符号位为0，则右移后高位补0，如果符号位为1，则高位补1，也就是说，如果数字是正数，则右移后在最左边补 n 个0，如果数字为负数，则右移后在最左边补 n 个1。如下： 1200001010 &gt;&gt; 2 = 0000001010001010 &gt;&gt; 3 = 11110001 如下为Python中所有位运算操作符示意： 123456789101112131415161718192021222324a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0c = a &amp; b; # 12 = 0000 1100print "a &amp; b 的值为：", cc = a | b; # 61 = 0011 1101 print "a | b 的值为：", cc = a ^ b; # 49 = 0011 0001print "a ^ b 的值为：", cc = ~a; # -61 = 1100 0011print " ~a 的值为：", cc = a &lt;&lt; 2; # 240 = 1111 0000print " a&lt;&lt;2 的值为：", cc = a &gt;&gt; 2; # 15 = 0000 1111print " a&gt;&gt;2 的值为：", c# result:# a &amp; b 的值为： 12# a | b 的值为： 61# a ^ b 的值为： 49# ~a 的值为： -61# a&lt;&lt;2 的值为： 240# a&gt;&gt;2 的值为： 15 移位运算运算规则 左移运算符：m\&lt;\&lt;n 表示把 m 左移 n 位，最左边的 n 位被丢弃，同时在最右边补上 n 个0，如下： 1200001010 &lt;&lt; 2 = 0010100010001010 &lt;&lt; 3 = 01010000 右移运算符：m>>n 表示把 m 右移 n 位，最右边的 n 位被丢弃，但最左边的处理方式有所不同：如果符号位为0，则右移后高位补0，如果符号位为1，则高位补1，也就是说，如果数字是正数，则右移后在最左边补 n 个0，如果数字为负数，则右移后在最左边补 n 个1。如下： 1200001010 &gt;&gt; 2 = 0000001010001010 &gt;&gt; 3 = 11110001 特殊应用 移位运算是最有效的计算乘/除法的运算之一，把整数左/右移一位，和把整数乘以/除以 2 在数学上是等价的。 1234567891011a = 2print a &lt;&lt; 1 # 左移一位等效于a = a * 2;# result: 4print a &lt;&lt; 2 # a左移两位等效于a = a * 2的2次方（4）；# result: 8a = 16print a &gt;&gt; 1 # 右移一位等效于a = a / 2；# result: 8print a &gt;&gt; 2 # 右移两位等效于a = a / (2**2)；# result: 4 按位与运算规则0&amp;0=0，0&amp;1=0，1&amp;0=0，1&amp;1=1。 即：两位同时为“1”，结果才为“1”，否则为0，有0则0。 特殊应用 清零指定位： mask中指定位置0，其它位为1，a = a &amp; mask。 取一个数的指定二进制位： mask中指定位置1，其它位为0，a = a &amp; mask。 判断一个数二进制表示中1的个数： 一个整数减去1，再和原数做与运算，会把该整数二进制表示中最右边一个1变为0。 如： 实现一个函数，输入一个正数，输出该数二进制表示中1的个数： 12345678num = 0n=5 # 二进制：101while(n): n &amp;= (n-1) num += 1print str(num)# result: 2 判断一个正数是不是2的整数次方： 如果是2的整数次方，则其二进制表示中有且只有一位是1。 1234a=4print a&amp;(a-1) == 0# result: True 按位或运算规则0|0=0；0|1=1；1|0=1；1|1=1。 即 ：参加运算的两个对象只要有一个为1，其值为1，有1则1。 特殊应用 对数据的指定位置为1： mask指定位置1，其它位为0，a = a | mask。 如：将 a = 1010 0000 低四位置1，则 a | 0000 1111 即可。 按位异或运算规则0^0=0；0^1=1；1^0=1；1^1=0。 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0，同0异1。 异或特点： 0异或任何数均为原数 1异或任何数，结果为对该数取反 任何数异或自己，结果为0 特殊应用 使特定位翻转： mask的特定位置1，其它位为0，a = a ^ mask。 如，对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算：10100001^00000110 = 10100111。 不使用临时变量，交换两个数的值： 如，交换两个整数a=10100001，b=00000110的值： 123a = a^b # a=10100111b = b^a # b=10100001a = a^b # a=00000110 与0异或，保留原值： a ^ 0仍为a。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>异或</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[%time,%timeit魔法命令]]></title>
    <url>%2F2019%2F03%2F04%2Fjupyter_timeit%2F</url>
    <content type="text"><![CDATA[在Jupyter-notebook中有几个用于计时的魔法命令%time、%%time、%timeit、%%timeit，可以非常简单的获取部分代码的运行耗时。 所有以%开头的方法，都是所谓的魔法命令（Magic function），也就是IPython内置的一些方法。魔法方法要区分%和%%，以%开头的叫做line magic，是专门针对一行的命令，以%%开头的叫做cell magic，是针对多行（一个cell）的命令。 以%%开头的魔法命令，必须放在一个cell的第一行，并且统计该cell中剩余的所有代码。分别来看： %time 给出当前行的代码运行一次所花费的时间； 123456a,b = 1,2%time a,b = b,a# output:# CPU times: user 2 µs, sys: 1 µs, total: 3 µs# Wall time: 5.01 µs 其中： user：表示执行用户代码（内核外）消耗的CPU时间； sys：表示进程在内核中消耗的CPU时间； 所以，CPU总耗时看total即可，也就是uset和sys之和。 Wall time是最终总耗时，包括IO、排队的耗时，也就是感知到的总耗时。 Wall time $&lt;$ CPU 表明进程是计算密集型（CPU bound），利用多核处理器的并行执行优势； Wall time $\approx$ CPU 表明进程是计算密集型，未并行执行； Wall time $&gt;​$ CPU 表明进程是I/O密集型（I/O bound），多核并行执行优势并不明显； %%time 给出当前cell的代码运行一次所花费的时间； 1234567%%timea,b = 1,2a,b = b,a# output:# CPU times: user 2 µs, sys: 1e+03 ns, total: 3 µs# Wall time: 5.96 µs %timeit -n 1000 给出当前行的代码运行n次所花费的时间（取最快三次的平均用时）； 1234%timeit -n 10000 c = pow(2,20)# output:# 10000 loops, best of 3: 198 ns per loop %%timeit -n 1000 给出当前cell的代码运行n次所花费的时间（取最快三次的平均用时）； 12345678%%timeit -n 10000a,b = 1,2c=aa=bb=c# output:# 10000 loops, best of 3: 68.5 ns per loop]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[若干Python性能优化小tips]]></title>
    <url>%2F2019%2F03%2F04%2Ffasterpython%2F</url>
    <content type="text"><![CDATA[若干简单易实现的Python性能优化小tips。 部分参考：https://segmentfault.com/a/1190000000666603 一些tips在刷题过程确实得到验证，尚有一些未验证但在实际简单测试中效率有提升。 优化算法时间复杂度 不论什么语言，算法的时间复杂度对程序的执行效率都有决定性影响，在Python中可以通过选择合适的数据结构来优化时间复杂度，如list和set查找指定元素的时间复杂度分别为O(n)和O(1)。同时，可以根据具体情况，采用分治、贪心、动态规划等算法思想。（不过优化算法有些有时候也不是很容易实现，，，） 在算法的常见时间复杂度上排序如下： O(1)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】599、两个列表的最小索引总和]]></title>
    <url>%2F2019%2F03%2F04%2Fleetcode_599%2F</url>
    <content type="text"><![CDATA[599、Minimum Index Sum of Two Lists 两个列表的最小索引总和 难度：简单 题目描述 英文： Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. 中文： 假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。 示例Example 1: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]Output: [&quot;Shogun&quot;]Explanation: The only restaurant they both like is &quot;Shogun&quot;. Example 2: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]Output: [&quot;Shogun&quot;]Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1). 提示 The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists. 代码提交 Python2，用时128ms，内存11.1M 12345678910111213141516171819202122class Solution(object): def findRestaurant(self, list1, list2): """ :type list1: List[str] :type list2: List[str] :rtype: List[str] """ dict1 = &#123;&#125; for index, name in enumerate(list1): dict1[name] = index templist = [] tempsum = 3000 for index, name in enumerate(list2): if name in dict1: cursum = index+dict1[name] if cursum &lt; tempsum: templist = [name] tempsum = cursum elif cursum == tempsum: templist.append(name) return templist TipsPython查找dict的key时，应使用if key in dict，而不是if key in dict.keys()。 前者是在dict中查找，dict对象的存储结构是hash表，最优情况下查询复杂度为O(1)； 后者等于是在list中查找，list对象的存储结构是线性表，查询复杂度为O(n)。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HMM和Viterbi算法]]></title>
    <url>%2F2019%2F03%2F01%2FHMM_IM%2F</url>
    <content type="text"><![CDATA[背景试图实现一个基于隐马尔科夫模型的拼音输入法，根据用户输入的拼音序列转换为对应的汉字，完成中文的输入。 输入法基本需求 通常一个拼音会对应多个汉字，如何确定在当前状态下，输入的拼音对应哪个汉字； 拼音序列通常可以对应多种可能的汉字组合，如何确定哪一种组合是相对最好的一种组合，如对于拼音序列yi chang，有异常、一场、宜昌等多种汉字组合，如何进行选择； HMM简介模型定义HMM（Hidden Markov Models，隐马尔科夫模型）是一种基本的统计模型，可以应用在语音识别、自然语言处理、模式识别等很多领域。 HMM的一个前提是马尔科夫假设，即假设模型的当前状态仅依赖于前面的几个状态。马尔科夫假设极大的简化了问题，但也可能丢失一些重要信息。一个马尔科夫过程是指状态间的转移仅依赖于前n个状态的过程，该过程即为n阶马尔科夫模型，其中n是影响下一个状态选择的前n个状态。（通常所说的HMM，指一阶HMM） HMM是在一个标准的马尔科夫过程中引入一组隐藏状态，以及观察状态与隐藏状态之间的一些概率关系，描述了一个含有隐藏状态的马尔科夫过程。 使用HMM模型时，通常问题有以下两个主要特征： 问题是基于序列的，如时间序列、状态序列； 问题中有两类数据，一类数据序列是可以观测到的，即观察序列，另一类数据序列是不能观测到的，即隐藏状态序列，简称状态序列； 例如在打算要做拼音输入法任务中，可以将拼音看做是隐藏状态，而拼音转化的文字结果作为一系列的观察状态，可以看到，引入隐藏状态的同时，观察序列与隐藏过程也具有一定的概率关系。 可以参考上图，其中$Z_i​$为隐藏状态序列，$X_i​$为隐藏状态生成的观察状态序列。隐藏状态序列$Z_i​$满足马尔科夫过程的要求，且观察状态序列$X_i​$与$Z_i​$之间存在概率关系，即模型中的$X_i​$与$X_i+1​$是存在关联的。 模型参数首先定义一些基本符号： $Q=\lbrace q_1,q_2,…,q_N \rbrace$，Q是所有可能的隐藏状态集合，其中N为可能的隐藏状态数，对应所有可能的汉字的状态数量； $V=\lbrace v_1,v_2,…,v_M \rbrace$，V是所有可能的观察状态集合，其中M为可能的观察状态数，对应所有可能的拼音的状态数量； $I=\lbrace i_1,i_2,…,i_T \rbrace​$，I 是长度为T的隐藏状态序列，对应用户输入的拼音序列所对应的汉字序列； $O=\lbrace o_1,o_2,…o_T \rbrace​$，O 是对应的观察序列，对应用户输入的拼音序列； HMM除上述状态集合外，还包括三组概率集合，用一个三元组$\lambda​$来刻画HMM，可写作$\lambda = (A,B,\pi)​$。 A 是隐藏状态转移概率分布，通常用矩阵表示，称为状态转移矩阵： A=[a_{ij}]_{N\times N} \quad where\quad a_{ij}=P(i_{t+1}=q_j|i_t=q_i)即，$a_{ij}​$ 是在时刻 t 处于状态 $q_i​$ 的条件下，在时刻 $t+1​$ 转移到状态 $q_j​$ 的概率，对应汉字到汉字之间的转移概率； B 是观察状态发射概率分布，通常用矩阵表示，称为混淆矩阵或发射矩阵： B=[b_{ik}]_{N\times M} \quad where\quad b_{ik}=P(o_t=v_k|i_t=q_i)即，$b_{ik}​$ 是在时刻 t 下的隐藏状态 $q_i​$ 到观察状态 $v_k​$ 的发射概率，对应汉字到拼音之间的发射概率； π 是初始状态概率，用向量表示： \pi = (\pi_i)_N \quad where \quad \pi=P(i_1=q_i)即，$\pi_i​$ 是在时刻 t=1 时处于隐藏状态 $q_i​$ 的概率； 可以看到，HMM（一阶）有两个基本假设： 齐次假设： P(i_t|i_{t-1},o_{t-1},i_{t-2},o_{t-2},...,i_1,o_1)=P(i_t|i_{t-1})即，任意时刻的隐藏状态只依赖于它前一个时刻的隐藏状态； 观测独立性假设： P(o_t|i_{T-1},o_{T-1},i_{T-2},o_{T-2},...i_1,o_1)=P(o_t|i_t)即，任意时刻的观察状态只依赖于当前时刻的隐藏状态； 用HMM解决的三类基本问题一旦一个系统可以作为HMM被描述，则可以用来解决三个基本问题 1。其中前两个是模式识别的问题：给定HMM求一个观察序列的概率（评估），搜索最有可能生成一个观察序列的隐藏状态序列（解码）。第三个问题是给定观察序列生成一个HMM（学习）。 评估（概率计算问题）：前向算法——动态规划 给定模型$\lambda = (A,B,\pi)​$和观察序列$O=\lbrace o_1,o_2,…o_T \rbrace​$，计算在模型 $ \lambda ​$ 参数已知的情况下，计算观察序列 $O​$ 出现的概率 $P(O|\lambda)​$； 学习（模型学习问题）：前向-后向算法（也叫Baum-Welch算法）——EM 已知观察序列$O=\lbrace o_1,o_2,…o_T \rbrace​$，学习使得观察序列概率 $P(O|\lambda)​$最大的模型$\lambda = (A,B,\pi)​$参数； 即根据观察序列用极大似然估计的方法估计参数生成隐马尔科夫模型； 解码（预测问题）：Viterbi算法——动态规划 已知模型$\lambda = (A,B,\pi)$和观察序列$O=\lbrace o_1,o_2,…o_T \rbrace$，求给定观察序列的情况下条件概率$P(I|O,\lambda)$最大的（隐藏）状态序列$I=\lbrace i_1,i_2,…,i_T \rbrace$； 即给定观察序列，搜索最有可能的对应的隐藏状态序列； Viterbi算法基于以上可知，拼音输入法的问题，属于解码问题，即已知模型和观察序列，求最有可能的对应的隐藏状态序列。 理论上，可以通过枚举所有的状态转移序列来求解解码问题，但效率非常低，暴力枚举的思路是枚举所有的长度T的状态序列，计算该状态序列与观察序列的联合概率。在状态种类为$N$的情况下，共有$N^T$种排列组合，每种组合计算联合概率的计算量为$T$，则总的计算复杂度为$O(TN^T)$ ，可见该方法并不可取。 因此常用维特比（Viterbi）算法来解决。 Viterbi算法是一个通用的求序列最短路径的动态规划算法。 如上图所示，Viterbi算法简单来说就是：从开始状态之后每走一步，就记录下到达该时刻每个状态时，对应该状态所有路径中的概率最大值，并且以这个最大值为基准继续向后前进。显然，如果这个最大值都不能使该状态成为最大似然估计路径上的节点的话，那么该节点的其他更小的概率值（包括对应的路径）就更不可能了。 Viterbi算法通过一种有效的方法来分析HMM模型的观察序列，并捕获最可能的隐藏序列，利用递归的方法减少计算量，并且对于观察序列的整个上下文都进行了很好的考虑，对包含噪音的序列也能进行良好的分析。 Viterbi算法详细过程 该部分内容主要参考52nlp上关于HMM的详细讲解，整理一遍便于自己详细理解。 如上文所说，通过暴力枚举的方法来找到最可能的序列的代价是非常昂贵的，因此Viterbi算法考虑用递归的方式来寻找最有可能的隐藏状态序列。所以，我们首先定义局部概率 $\delta​$ ，表示到达网格中的某个中间状态时的概率值，之后来详细了解如何在$t=1​$和$t=n (n&gt;1)​$时如何计算其局部概率值。 定义局部概率和局部最佳路径 观察上图的网格，显示的是汉字对于观察序列（拼音序列）的一阶转移情况。对于网格中的每一个中间及终止状态，都有一个可以到达该状态的最可能路径。比如，在$t=3​$时刻的三个状态中，每一个都有一条到达该状态的最可能路径，可能如下图所示： 这些路径即为局部最佳路径，而每条局部最佳路径的概率值即为局部概率$\delta​$，用$ \delta(i,t)​$表示在 $t​$ 时刻到达状态 $i​$ 的所有路径概率中最大的概率值，局部最佳路径即对应该最大概率值的隐藏状态序列。基于此可知，在 $t=T​$ 时刻，每个状态都有一个局部概率及相应的局部最佳路径，因此，可以通过选择该时刻局部概率值最大的状态（及其对应的最佳路径）来确定全局最佳路径，即全局最佳隐藏状态序列。 计算$t=1$时刻的局部概率局部概率指到达该状态时的最佳路径的概率值，当$t=1​$时，该路径是不存在的，因此，用$t=1​$时刻所处状态的初始概率值及相应观察状态的转移概率值来计算$t=1​$时的局部概率，即： \delta _1(i)=\pi (i)b_{io_1}计算$t&gt;1$时刻的局部概率考虑如图所示的网格： 计算 $t$ 时刻到达状态 $X$ 的最佳路径，显然，这条最佳路径一定会通过 $t-1$ 时刻的状态 $A$、$B$、$C$ 之中的某一个。也就是说，到达状态 $X$ 的最佳路径一定是路径(状态序列），...，A，X、（状态序列），...，B，X、（状态序列），...，C，X三条之中的一条。 我们知道在一阶马尔科夫假设下，状态 $X$ 在一个状态序列之后发生的概率只取决于之前的一个状态，也就是说，路径末端是 $AX$ 的最佳路径将是到达 $A$ 的最佳路径再紧跟 $X$ ，那么这条路径的概率即为：$P(到达状态A的最佳路径)\times P(X|A)\times P(观察状态|X)$。 由此可知，到达状态 $X$ 的最佳路径概率计算方式为： P(X\ at\ time\ t)=\max_{i=A,B,C}P(i\ at\ time\ (t-1))\times P(X|i)\times P(obs\ at\ time\ t|X)其中，$P(i at time (t-1))​$是$t-1​$时刻的局部概率$\delta​$，$P(X|i)​$是状态转移概率（隐藏状态到观察状态的发射概率），$P(obs at time t|X)​$是观察概率。 对上述公式进行泛化可知，在 $t​$ 时刻，观察状态是 $k_t​$ ，到达隐藏状态 $i​$ 最佳局部路径概率为： \delta _t(i)=\max \limits_j(\delta _{t-1}(j)\times a_{ji}\times b_{io_t})我们假设前一个状态的局部概率已知，同时利用状态转移概率和对应的观察概率，就可以从中选择当前状态的最大概率了（局部概率 $\delta$ ）。 使用反向指针记录最佳路径 考虑上图的网格，经过前面的过程我们已经得到了每个状态的局部概率，但我们最终的目标是希望得到网格中的最佳隐藏序列，也就是说，最终的目标是需要得到网格中的局部最佳路径。 回顾之前我们得到局部概率的过程，$t$ 时刻的局部概率是通过 $t-1$ 时刻的局部概率得到的，也就是说，在计算得到 $t$ 时刻的局部概率 $\delta _t(i)$ 之后，我们就可以知道这个局部概率 $\delta _t(i)$ 是由 $t-1$ 时刻的哪一个状态而得到的。因此，在这个过程中，我们通过给每一个状态赋予一个反向指针 $\psi$ 来记录，这个指针指向导致当前状态最优概率的前一时刻的某个状态。 反向指针在形式上的公式如下： \psi _t(i)=argmax_j(\delta _{t-1}(j)a_{ji})这个反向指针的表达式是通过转移概率（某时刻的隐藏状态，演变到下一时刻某个隐藏状态的概率）以及前一时刻的局部概率计算得到的，没有使用到观察概率（隐藏状态到观察状态的发射概率）。 经过上述过程，已经可以通过递归的方式得到网格中每个状态的最佳局部概率，以及相应的局部最佳路径。 在使用Viterbi算法的过程中，我们对于网格中的每一个状态都计算一个局部概率，同时包含一个反向指针来指向最可能到达该状态的路径。当完成整个计算过程之后，我们首先在终止状态找到最可能的状态，之后通过反向指针回溯到初始时刻，从而回溯路径对应的状态序列就是我们最终得到的最佳的隐藏状态序列了。 Viterbi算法形式化表达及计算流程上文对Viterbi算法的流程做了详细的梳理，现在来总结一下Viterbi算法的形式化定义及完整流程： 输入：HMM模型 $\lambda =(A,B,\pi)$ ，观察序列 $O=(o_1,o_2,…o_T)$ ； 输出：最有可能的隐藏状态序列 $I^*=\lbrace i_1^*,i_2^*,…i_T^*\rbrace$ ； 算法流程： 初始化局部状态（$t=1$）： \delta _1(i)=\pi _ib_{io_1}\ ,\ i=1,2,...N \psi _1(i)=0\ ,\ i=1,2,...N其中， $N​$ 表示隐藏状态的长度，在拼音转汉字的过程中对应汉字的长度。 这一步通过观察状态的初始概率，和对应的观察状态到隐藏状态的发射概率，得到初始时刻的局部概率。 递推，通过动态规划递推时刻 $t=2,3,…T$ 时刻的局部状态（$t&gt;1$）： \delta _t(i)=\max_{1\leq j\leq N}[\delta _{t-1}(j)a_{ji}]b_{io_t}\ ,\ i=1,2,...N \psi _t(i)=\arg\max _{1\leq j\leq N}[\delta _{t-1}(j)a_{ji}]\ ,\ i=1,2,...N其中，$i$ 表示当前时刻隐藏序列的各个状态，$j$ 表示前一时刻隐藏序列的各个状态。 当前状态节点的选取，是通过考虑所有的转移概率，包括当前的发射概率，以及前一时刻的局部概率，综合计算，最后记录最大值，同时也记录了最大概率对应的前一时刻的状态节点。 终止： P^*=\max _{1\leq i\leq N}\delta _T(i) i_T^*=\arg \max _{1\leq i\leq N}[\delta _T(i)]计算终止时刻 T 时刻最大的概率值$\delta _T(i)$，即为最佳隐藏状态序列出现的概率，计算终止时刻 T 时刻最大的$\psi _t(i)$，即为最佳的隐藏状态。 回溯最优路径，对$t=T-1,T-2,…,1$： i_t^*=\psi _{t+1}(i_{t+1}^*)按照此过程回溯整个网格，回溯完成时，就得到了生成给定观察序列的最可能的隐藏状态序列 $I^*=(i_1^*,i_2^*,…i_T^*)$。 Viterbi算法代码实现C++版 主要参考umdhmm代码实现。 HMM模型结构定义如下： 12345678910typedef struct &#123; int N; /* number of hidden states; Q=&#123;1,2,...,N&#125; */ int M; /* number of observation symbols; V=&#123;1,2,...,M&#125;*/ double **A; /* A[1..N][1..N]. a[i][j] is the transition prob of going from state i at time t to state j at time t+1 */ double **B; /* B[1..N][1..M]. b[j][k] is the probability of of observing symbol k in state j */ double *pi; /* pi[1..N] pi[i] is the initial state distribution. */&#125; HMM; Viterbi算法主流程实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void Viterbi(HMM *phmm, int T, int *O, double **delta, int **psi, int *q, double *pprob)&#123; int i, j; /* state indices */ int t; /* time index */ int maxvalind; double maxval, val; /* 1. Initialization */ for (i = 1; i &lt;= phmm-&gt;N; i++) &#123; delta[1][i] = phmm-&gt;pi[i] * (phmm-&gt;B[i][O[1]]); psi[1][i] = 0; &#125; /* 2. Recursion */ for (t = 2; t &lt;= T; t++) &#123; for (j = 1; j &lt;= phmm-&gt;N; j++) &#123; maxval = 0.0; maxvalind = 1; for (i = 1; i &lt;= phmm-&gt;N; i++) &#123; val = delta[t-1][i]*(phmm-&gt;A[i][j]); if (val &gt; maxval) &#123; maxval = val; maxvalind = i; &#125; &#125; delta[t][j] = maxval*(phmm-&gt;B[j][O[t]]); psi[t][j] = maxvalind; &#125; &#125; /* 3. Termination */ *pprob = 0.0; q[T] = 1; for (i = 1; i &lt;= phmm-&gt;N; i++) &#123; if (delta[T][i] &gt; *pprob) &#123; *pprob = delta[T][i]; q[T] = i; &#125; &#125; /* 4. Path (state sequence) backtracking */ for (t = T - 1; t &gt;= 1; t--) q[t] = psi[t+1][q[t+1]];&#125; 基于HMM实现拼音输入法主流程在拼音输入法的主要过程中，HMM模型可以通过以下过程得到： 对训练数据的所有内容按照单字分词，并统计每个词出现的频率，以此作为初始概率 $\pi​$ ; 将训练数据的所有汉字都转换成对应的拼音，统计每个拼音对应的汉字以及各自出现的频率，以此作为发射概率 $B​$ ; 统计训练数据中每个汉字后面出现的汉字的频率，以此作为隐藏状态的转移概率 $A$ ; 经过上述过程，即可得到一个隐马尔科夫模型 $\lambda(\pi,A,B)$ 。 在此基础上，使用Viterbi算法，对用户输入的拼音序列进行解码，即可得到最终的汉字序列。 在实际应用过程中，对于一些转移概率为0的情况，可以默认设置一个较小的转移概率来避免计算结果为0的情况；同时，对于未登录词，也可以通过设置较小的初始概率来解决概率为0的问题。 1. http://www.52nlp.cn/hmm-learn-best-practices-four-hidden-markov-models &#8617;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>HMM</tag>
        <tag>隐马</tag>
        <tag>Viterbi</tag>
        <tag>拼音输入法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Real Hello World]]></title>
    <url>%2F2019%2F02%2F27%2FmyHello%2F</url>
    <content type="text"><![CDATA[This is my real hello world from hexo. **Lesley Shi**]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
