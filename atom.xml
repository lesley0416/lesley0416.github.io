<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lesley&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lesley0416.github.io/"/>
  <updated>2019-03-26T03:13:44.000Z</updated>
  <id>https://lesley0416.github.io/</id>
  
  <author>
    <name>Lesley Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【LeetCode】21、合并两个有序链表</title>
    <link href="https://lesley0416.github.io/2019/03/26/leetcode_21/"/>
    <id>https://lesley0416.github.io/2019/03/26/leetcode_21/</id>
    <published>2019-03-26T03:07:50.000Z</published>
    <updated>2019-03-26T03:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>21、<a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">Merge Two Sorted Lists</a>合并两个有序链表</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p></li><li><p>中文：</p><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路，比较头结点，保留较小值，再合并后续内容。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时8ms，内存9M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val&lt;l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;21、&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Merge Two Sorted Lists&lt;/a&gt;合并两个有序链表&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="链表" scheme="https://lesley0416.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】779、第k个语法符号</title>
    <link href="https://lesley0416.github.io/2019/03/26/leetcode_779/"/>
    <id>https://lesley0416.github.io/2019/03/26/leetcode_779/</id>
    <published>2019-03-26T03:07:50.000Z</published>
    <updated>2019-03-27T14:13:18.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>21、<a href="https://leetcode.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">K-th Symbol in Grammar</a>第k个语法符号</p><p>难度：中等</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code>with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p><p>Given row <code>N</code> and index <code>K</code>, return the <code>K</code>-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p></li><li><p>中文：</p><p>在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p><p>给定行数 <code>N</code> 和序数 <code>K</code>，返回第 <code>N</code> 行中第 <code>K</code>个字符。（<code>K</code>从1开始）</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 1, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: N = 4, K = 5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row 1: 0</span><br><span class="line">row 2: 01</span><br><span class="line">row 3: 0110</span><br><span class="line">row 4: 01101001</span><br></pre></td></tr></table></figure></li><li><p>注意</p><ol><li><code>N</code> 的范围 <code>[1, 30]</code>.</li><li><code>K</code> 的范围 <code>[1, 2^(N-1)]</code>.</li></ol></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路。</p><p>整个结构可以看做是一棵二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    0</span><br><span class="line">   / \</span><br><span class="line">  0   1</span><br><span class="line"> /\   /\</span><br><span class="line">0  1 1  0</span><br></pre></td></tr></table></figure><p>当一个节点是0的时候，两个子节点分别为0和1，当节点是1的时候，两个子节点分别为1和0。通过把K除以2，可以知道K的位置是左节点还是右节点。如果K是偶数，那么当前节点为右子节点，父节点是$N-1$行的第$K/2$个节点，如果K为奇数的话，则当前节点为左子节点。父节点是$N-1$行的第$(K+1)/2$个节点。</p><p>当前节点依赖于父节点，所以递归向前查找父节点，直至第一行结束。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存8.1M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (K%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthGrammar(N<span class="number">-1</span>, K/<span class="number">2</span>)==<span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> kthGrammar(N<span class="number">-1</span>, (K+<span class="number">1</span>)/<span class="number">2</span>)==<span class="number">0</span> ? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;21、&lt;a href=&quot;https://leetcode.com/problems/k-th-symbol-in-grammar/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K-th Symbol in Grammar&lt;/a&gt;第k个语法符号&lt;/p&gt;
&lt;p&gt;难度：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="链表" scheme="https://lesley0416.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】50、Pow(x,n)</title>
    <link href="https://lesley0416.github.io/2019/03/25/leetcode_50/"/>
    <id>https://lesley0416.github.io/2019/03/25/leetcode_50/</id>
    <published>2019-03-25T09:10:50.000Z</published>
    <updated>2019-03-25T09:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>50、<a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">Pow(x,n)</a>Pow(x,n)</p><p>难度：中等</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a>, which calculates <em>x</em> raised to the power <em>n</em>(xn).</p></li><li><p>中文：</p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure></li><li><p>Note:</p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> is a 32-bit signed integer, within the range $[-2^{31},2^{31}-1]$</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路，直接用for循环让x乘以自己n次会超时。用递归的思路，对计算过程进行二分计算。每次把n缩小一半，直至n缩小为0。任何数的0次方都为1，这是终止条件。如果n是偶数，返回值算个平方返回即可，如果n是奇数，则平方之后再乘以一次x。</p><p>需要注意的是，n可能为负数，如果n是负数的话，就先用绝对值计算，再对结果取倒数。</p><p>但按上述思路简单实现后，对于<code>负2的31次方</code>这个测试用例，由于绝对值超过整型最大值，所以溢出了。所以换一种写法，在每次递归中都处理n的正负，然后做相应的变换。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时8ms，内存10M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> half = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) <span class="keyword">return</span> half * half * x;</span><br><span class="line">        <span class="keyword">return</span> half * half / x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>用迭代的方法，将i初始化为n，看i是否是2的倍数，如果是，则x乘以自己即可，如果不是，则temp要再乘以x，i逐次减半，直到为0停止循环。最后看n的正负，并做相应处理。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时8ms，内存10M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i != <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;50、&lt;a href=&quot;https://leetcode.com/problems/powx-n/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pow(x,n)&lt;/a&gt;Pow(x,n)&lt;/p&gt;
&lt;p&gt;难度：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="数学" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分查找" scheme="https://lesley0416.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】104、二叉树的最大深度</title>
    <link href="https://lesley0416.github.io/2019/03/25/leetcode_104/"/>
    <id>https://lesley0416.github.io/2019/03/25/leetcode_104/</id>
    <published>2019-03-25T08:51:50.000Z</published>
    <updated>2019-03-25T09:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>104、<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a>二叉树的最大深度</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Note:</strong> A leaf is a node with no children.</p></li><li><p>中文：</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p></li><li><p>示例</p><p><strong>Example：</strong></p><p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its depth = 3.</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路，最大深度等于左节点和右节点最大深度的较大值加1。</p><blockquote><p>C++，用时16ms，内存19M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (leftDepth &gt; rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;104、&lt;a href=&quot;https://leetcode.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maximum Depth of Binary Tree&lt;/a&gt;二叉树的最大深度&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="树" scheme="https://lesley0416.github.io/tags/%E6%A0%91/"/>
    
      <category term="深度优先搜索" scheme="https://lesley0416.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="二叉树" scheme="https://lesley0416.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】509、斐波那契数</title>
    <link href="https://lesley0416.github.io/2019/03/25/leetcode_509/"/>
    <id>https://lesley0416.github.io/2019/03/25/leetcode_509/</id>
    <published>2019-03-25T02:10:50.000Z</published>
    <updated>2019-03-25T02:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>509、<a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">Fibonacci Number</a>斐波那契数</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code>and <code>1</code>. That is,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), for N &gt; 1.</span><br></pre></td></tr></table></figure><p>Given <code>N</code>, calculate <code>F(N)</code>.</p></li><li><p>中文：</p><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>给定 <code>N</code>，计算 <code>F(N)</code>。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure></li><li><p>提示</p><p>0 ≤ N ≤ 30</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用递归方法。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python，用时20ms，内存11.8M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur_fib</span><span class="params">(N)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> N <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[N]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">                result = N</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = recur_fib(N<span class="number">-1</span>) + recur_fib(N<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># put result in cache for later reference.</span></span><br><span class="line">            cache[N] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur_fib(N)</span><br></pre></td></tr></table></figure><p>使用decorator模式做递归方法中的缓存计算。</p><blockquote><p>Python，用时20ms，内存12.1M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cache</span><span class="params">(func)</span>:</span> </span><br><span class="line">        caches = &#123;&#125; </span><br><span class="line"><span class="meta">        @wraps(func) </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args)</span>:</span> </span><br><span class="line">            <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> caches: </span><br><span class="line">                caches[args] = func(*args)</span><br><span class="line">            <span class="keyword">return</span> caches[args] </span><br><span class="line">        <span class="keyword">return</span> wrap </span><br><span class="line">    </span><br><span class="line"><span class="meta">    @cache </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span> </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: </span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.fib(n<span class="number">-1</span>) + self.fib(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;509、&lt;a href=&quot;https://leetcode.com/problems/fibonacci-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fibonacci Number&lt;/a&gt;斐波那契数&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="数组" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="斐波那契数列" scheme="https://lesley0416.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——decorator</title>
    <link href="https://lesley0416.github.io/2019/03/25/decorator_python/"/>
    <id>https://lesley0416.github.io/2019/03/25/decorator_python/</id>
    <published>2019-03-25T02:08:50.000Z</published>
    <updated>2019-03-26T06:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>后续补充</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;后续补充&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="Python" scheme="https://lesley0416.github.io/categories/Python/"/>
    
    
      <category term="decorator" scheme="https://lesley0416.github.io/tags/decorator/"/>
    
      <category term="Python" scheme="https://lesley0416.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://lesley0416.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】206、反转链表</title>
    <link href="https://lesley0416.github.io/2019/03/22/leetcode_206/"/>
    <id>https://lesley0416.github.io/2019/03/22/leetcode_206/</id>
    <published>2019-03-22T06:33:50.000Z</published>
    <updated>2019-03-27T13:43:32.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>206、<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a>反转链表</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Reverse a singly linked list.</p></li><li><p>中文：</p><p>反转一个单链表。</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure></li><li><p>进阶<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="递归解决方法的视频讲解"><a href="#递归解决方法的视频讲解" class="headerlink" title="递归解决方法的视频讲解"></a>递归解决方法的视频讲解</h3><p><a href="https://www.youtube.com/watch?v=MRe3UsRadKw" target="_blank" rel="noopener">Reverse a Linked List Recursively</a></p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>参考讨论区的一种做法。</p></blockquote><p>时间复杂度O(N)，空间复杂度O(1)</p><p>这里给出两种方法：迭代法（循环），递归方法。</p><p>两种方法的思路都是一样的。如下所示</p><blockquote><p>…&lt;-x&lt;-x&lt;-x&lt;-x&lt;-pre  ||  cur-&gt;y-&gt;y-&gt;y-&gt;y…</p></blockquote><ol><li>将整个链表分成两个部分；前半部分链表，后半部分链表</li><li>pre为已经 反转 好的部分链表的头节点；</li><li>cur为当前仍然没有反转部分链表的头节点；</li><li>我们当前需要做的事情就是将cur节点加入到前半部分的链表中，<br>直到右边的链表全部加入到左边的链表中即可。</li><li>用递归的思想理解4很容易。</li></ol><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><p><strong>递归方法</strong></p><blockquote><p>C++，用时8ms，内存9M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre, ListNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>) &#123; <span class="comment">// 递归结束的判断</span></span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        <span class="keyword">return</span> reverse(pre, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>, *cur = head;</span><br><span class="line">        <span class="keyword">return</span> head ? reverse(pre, cur) : head; <span class="comment">// 如果head为空的话，我们直接返回head/NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代方法</strong></p><blockquote><p>C++，用时8ms，内存9.1M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>, *cur = head, *next = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">            next = next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>参考LeetCode上<code>递归</code>探索页给出的解决方案。</p><p>递归版，是从后往前来转变链表指针的方向；迭代版是从前往后来转变链表的方向。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 递归版</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == null || head.next == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = null;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代版</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != null)&#123;</span><br><span class="line">            ListNode p1 = null;</span><br><span class="line">            ListNode next = null;</span><br><span class="line">            ListNode p2 = head;</span><br><span class="line">            <span class="keyword">while</span> (p2 != null)&#123;</span><br><span class="line">                next = p2.next;</span><br><span class="line">                p2.next = p1;</span><br><span class="line">                p1 = p2;</span><br><span class="line">                p2 = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h3><p>参考网上的解法，巧妙利用Python的多元赋值，实现非常简洁。</p><p>具体的执行过程可参考下面的举例说明：</p><blockquote><p>前置条件：迭代指针：p = head、结果指针：res = none</p><p><strong>以1-&gt;2-&gt;3-&gt;4-&gt;5为例：</strong></p><p>过程：</p><p>res:None</p><p>第一层循环</p><p>res:1-&gt;2-&gt;3-&gt;4-&gt;5    res = p</p><p>res:1-&gt;None    res.next = res</p><p>p:2-&gt;3-&gt;4-&gt;5    p = p.next</p><p>第二层循环</p><p>res:2-&gt;3-&gt;4-&gt;5    res = p</p><p>res:2-&gt;1-&gt;None    res.next = res</p><p>p:3-&gt;4-&gt;5    p = p.next</p><p>第三层循环</p><p>res:3-&gt;4-&gt;5    res = p</p><p>res:3-&gt;2-&gt;1-&gt;None    res.next = res</p><p>p:4-&gt;5    p = p.next</p><p>第四层循环</p><p>res:4-&gt;5    res = p</p><p>res:4-&gt;3-&gt;2-&gt;1-&gt;None    res.next = res</p><p>p:5    p = p.next</p><p>第五层循环</p><p>res:5    res = p</p><p>res:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;None    res.next = res</p><p>p:None    p = p.next</p><p>end…</p></blockquote><h4 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python，用时32ms，内存12.7M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        L = ListNode(float(<span class="string">"-inf"</span>))</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="comment"># 把当前 L.next （如 [2,1]）内容临时保存起来，然后把head此时剩下的内容（如 [3,4,5]）赋给L （变成[3,4,5]），再把之前保存的L.next接回来（L变成[3,2,1]），最后head后移一步</span></span><br><span class="line">            L.next, head.next, head = head, L.next, head.next</span><br><span class="line">        <span class="keyword">return</span> L.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;206、&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reverse Linked List&lt;/a&gt;反转链表&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://lesley0416.github.io/tags/Python/"/>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="链表" scheme="https://lesley0416.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="多元赋值" scheme="https://lesley0416.github.io/tags/%E5%A4%9A%E5%85%83%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】119、杨辉三角2</title>
    <link href="https://lesley0416.github.io/2019/03/22/leetcode_119/"/>
    <id>https://lesley0416.github.io/2019/03/22/leetcode_119/</id>
    <published>2019-03-22T06:16:50.000Z</published>
    <updated>2019-03-27T13:48:31.387Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>119、<a href="https://leetcode.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">Pascal’s Triangle II</a>杨辉三角2</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p><p>Note that the row index starts from 0.</p></li><li><p>中文：</p><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p><p><img src="/2019/03/22/leetcode_119/210px-PascalTriangleAnimated2.gif"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure></li><li><p>进阶</p><p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote><p><strong>递归关系</strong></p><p>我们从定义杨辉三角的递归关系开始。</p><p>首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下：</p><script type="math/tex; mode=display">f(i,j)=f(i-1,j-1)+f(i-1,j)</script><p><strong>基本情况</strong></p><p>在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1.</p><p>所以，我们可以定义基本情况如下：</p><script type="math/tex; mode=display">f(i,j)=1\qquad where\qquad j=1\ or\ j=i</script><blockquote><p>代码没有完全对应Recursion相应位置的方法，实现过程中，采用自底向上的方法，保存前一行的中间结果。</p><p>代码上注意一下，此处的<code>rowIndex</code>从0开始。</p></blockquote><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存8.3M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        temp.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= rowIndex; row++) &#123;</span><br><span class="line">            result.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt;= row; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">0</span> || col == row) &#123;</span><br><span class="line">                    result.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.push_back(temp[col - <span class="number">1</span>] + temp[col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>和思路一类似，先开辟一个大小为$k$的空间，保留每次前一行的中间结果，在其基础上直接修改获取当前行的结果。</p><p>修改过程中，先填充当前行的末尾值（比前一行最末的位置+1位），然后从右往左依次修改，当前行位置为$j$的值，仅依赖于上一行位置为$j-1$和$j$的值，所以，逆序修改的过程中，改掉的值都是下一步计算不再需要的值。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存8.3M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(rowIndex + <span class="number">1</span>);<span class="comment">// 长度为K，默认值为0</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) &#123;<span class="comment">// 从第1行开始（从0开始数）计算每一行的参数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">                res[j] += res[j - <span class="number">1</span>];<span class="comment">// 更新j位置上的数为上一行的j-1位置与j位置的数的和，最末端为 0+上一行最末端</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;119、&lt;a href=&quot;https://leetcode.com/problems/pascals-triangle-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pascal’s Triangle II&lt;/a&gt;杨辉三角2&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="数组" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】118、杨辉三角</title>
    <link href="https://lesley0416.github.io/2019/03/22/leetcode_118/"/>
    <id>https://lesley0416.github.io/2019/03/22/leetcode_118/</id>
    <published>2019-03-22T03:54:50.000Z</published>
    <updated>2019-03-22T05:53:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>118、<a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">Pascal’s Triangle</a>杨辉三角</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p></li><li><p>中文：</p><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p><p><img src="/2019/03/22/leetcode_118/210px-PascalTriangleAnimated2.gif"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote><p><strong>递归关系</strong></p><p>我们从定义杨辉三角的递归关系开始。</p><p>首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下：</p><script type="math/tex; mode=display">f(i,j)=f(i-1,j-1)+f(i-1,j)</script><p><strong>基本情况</strong></p><p>在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1.</p><p>所以，我们可以定义基本情况如下：</p><script type="math/tex; mode=display">f(i,j)=1\qquad where\qquad j=1\ or\ j=i</script><blockquote><p>代码没有完全对应Recursion相应位置的方法，实现过程中，采用自底向上的方法，保存计算过的中间结果，避免了重复计算。</p></blockquote><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存8.8M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) &#123;</span><br><span class="line">            temp.push_back(<span class="number">1</span>);</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.push_back(<span class="number">1</span>);</span><br><span class="line">        result.push_back(temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; numRows; row++) &#123;</span><br><span class="line">            temp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt;= row; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">0</span> || col == row) &#123;</span><br><span class="line">                    temp.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.push_back(result[row - <span class="number">1</span>][col - <span class="number">1</span>] + result[row - <span class="number">1</span>][col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;118、&lt;a href=&quot;https://leetcode.com/problems/pascals-triangle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pascal’s Triangle&lt;/a&gt;杨辉三角&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="数组" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】24、两两交换链表中的节点</title>
    <link href="https://lesley0416.github.io/2019/03/21/leetcode_24/"/>
    <id>https://lesley0416.github.io/2019/03/21/leetcode_24/</id>
    <published>2019-03-21T09:32:50.000Z</published>
    <updated>2019-03-22T03:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>24、<a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a>两两交换链表中的节点</p><p>难度：中等</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p></li><li><p>中文：</p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote><p>定义函数<code>swap(head)</code>，其中输入参数<code>head</code>表示链表的头结点。函数应该返回相邻节点交换后的新链表的头结点。</p><p>按如下步骤实现这个函数：</p><ol><li>首先，我们交换链表的前两个节点，即<code>head</code>和<code>head.next</code>；</li><li>然后，我们递归调用函数<code>swap(head.next.next)</code>来处理链表的剩余部分；</li><li>最后，获得步骤2返回的子链表的头结点，并将其和步骤1的新链表相连接；</li></ol><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存9M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *t = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(head-&gt;next-&gt;next);</span><br><span class="line">        t-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;24、&lt;a href=&quot;https://leetcode.com/problems/swap-nodes-in-pairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swap Nodes in Pairs&lt;/a&gt;两两交换链表中的节点&lt;/p&gt;
&lt;p&gt;难度：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="链表" scheme="https://lesley0416.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】344、反转字符串</title>
    <link href="https://lesley0416.github.io/2019/03/21/leetcode_344/"/>
    <id>https://lesley0416.github.io/2019/03/21/leetcode_344/</id>
    <published>2019-03-21T05:41:50.000Z</published>
    <updated>2019-03-22T03:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>344、<a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">Reverse String</a>反转字符串</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>You may assume all the characters consist of <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters" target="_blank" rel="noopener">printable ascii characters</a>.</p></li><li><p>中文：</p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a> 码表中的可打印字符。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路，不使用额外空间，从首尾两端开始交换字符，并依次向内部缩小，直至交换到数组中间位置时结束。</p><p>用$s[x_i,…,x_j]$表示字符数组，其中$x_i , x_j$表示数组中的字符内容，$i,j$为对应的位置，则：</p><script type="math/tex; mode=display">s[x_i,...,x_j]=    \begin{cases}        s[x_i,...x_j], & \text{if $i>=j$}\\        s[x_j,...x_i], & \text{if $i<j$}    \end{cases}</script><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时60ms，内存19M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        swap(s, left+<span class="number">1</span>, right<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        swap(s, <span class="number">0</span>, s.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;344、&lt;a href=&quot;https://leetcode.com/problems/reverse-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reverse String&lt;/a&gt;反转字符串&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="双指针" scheme="https://lesley0416.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="字符串" scheme="https://lesley0416.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】Explore：Recursion I 递归—1</title>
    <link href="https://lesley0416.github.io/2019/03/21/leetcode_explore_recursion/"/>
    <id>https://lesley0416.github.io/2019/03/21/leetcode_explore_recursion/</id>
    <published>2019-03-21T03:03:50.000Z</published>
    <updated>2019-03-27T14:08:40.112Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要翻译自LeetCode上Explore模块的<a href="https://leetcode.com/explore/learn/card/recursion-i/" target="_blank" rel="noopener">Recursion I</a>，有直译，也有非直译的个人理解。</p><p>其中涉及的题目附有相应的解答。</p></blockquote><h1 id="Overview-综述"><a href="#Overview-综述" class="headerlink" title="Overview 综述"></a>Overview 综述</h1><p><code>Recursion</code>（递归）是计算机科学中一个重要的概念，是很多算法和数据结构的基础。但是对于很多初学者都比较难把握。</p><a id="more"></a><p>在开始本节探索之前，我们强烈建议先完成<a href="https://leetcode.com/explore/learn/card/data-structure-tree/" target="_blank" rel="noopener">二叉树</a>和<a href="https://leetcode.com/explore/learn/card/queue-stack/" target="_blank" rel="noopener">堆栈</a>两个探索页。</p><p>在这个探索页，我们将回答以下几个问题：</p><ol><li>什么是<code>recursion</code>？它是如何工作的？</li><li>如何递归的解决一个问题？</li><li>如何分析递归算法的时间和空间复杂度（time and space complexity）？</li><li>如何更好的应用递归？</li></ol><p>完成本探索页后，你在解决递归问题和分析复杂度时会变得更加自信。</p><h1 id="一、Principle-of-Recursion-递归原理"><a href="#一、Principle-of-Recursion-递归原理" class="headerlink" title="一、Principle of Recursion 递归原理"></a>一、Principle of Recursion 递归原理</h1><p>在这章，我们将会：</p><ol><li>解释递归的基本概念；</li><li>演示如何应用递归解决确切的问题；</li><li>最后提供一些练习题来练习递归；</li></ol><h2 id="递归原理"><a href="#递归原理" class="headerlink" title="递归原理"></a>递归原理</h2><blockquote><p>递归是一种将函数本身作为子程序调用来解决问题的方法。</p></blockquote><p>你可能想知道一个函数怎样调用其自身。诀窍在于每次递归的调用其本身时，都将给定的问题缩小成其子问题，这样持续的递归调用，直到子问题可以不用递归就能解决的时候停止。</p><p>一个递归函数应该有以下属性，这样才不会导致无限循环：</p><ol><li>具有简单的基本情况，即递归出口、递归结束条件，即不使用递归即可获得答案的情况；</li><li>一系列规则，称为<code>recurrence relation</code>递归关系，可以将问题逐步缩小直至递归出口；</li></ol><p>注意，可能会有多个可以调用函数本身的地方。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>从一个简单的问题开始：逆序输出字符串。</p><blockquote><p>倒序输出一个字符串。</p></blockquote><p>你可以很容易的迭代解决这个问题，例如从字符串的结尾开始遍历字符串。但是如何递归的解决呢？</p><p>首先，我们定义函数<code>printReverse(str[0...n-1])</code>，其中<code>str[0]</code>表示字符串的第一个字符，然后我们通过以下两个步骤解决这个问题：</p><ol><li><code>printReverse(str[1...n-1])</code>：逆序输出子串<code>strp[1...n-1]</code>；</li><li><code>print(str[0])</code>：输出字符串的首字符；</li></ol><p>我们在第一步中定义了递归关系。</p><p>代码如下（C++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printReverse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!*str)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    printReverse(str+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，来处理一个和示例略有不同的练习，尽量用递归来解决。</p><h2 id="练习：反转字符串"><a href="#练习：反转字符串" class="headerlink" title="练习：反转字符串"></a>练习：反转字符串</h2><a href="/2019/03/21/leetcode_344/" title="【LeetCode】344、Reverse String">【LeetCode】344、Reverse String</a><p>写一个反转字符串的函数，输入字符数组<code>char[]</code>。</p><p>不要开辟额外的控件，必须使用$O(1)​$的空间复杂度就地修改输入的数组。</p><p>假定所有的字符都是可打印的ASCII码字符。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><p>递归代码如下（自己写的，C++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        swap(s, left+<span class="number">1</span>, right<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        swap(s, <span class="number">0</span>, s.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：反转字符串"><a href="#解答：反转字符串" class="headerlink" title="解答：反转字符串"></a>解答：反转字符串</h2><p>本章，我们给出反转字符串问题的一个简单的解决方案。</p><blockquote><p>问题并不难，关键在于有一个额外的约束条件，即使用$O(1)$的额外空间进行修改。</p></blockquote><p>定义函数<code>reverseString(str[0...n-1])</code>，其中<code>str[0...n-1]</code>是一个首字符为<code>str[0]</code>的字符数组。</p><p>下面，我们讨论如何利用递归的思想来解决这个问题。</p><h3 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h3><p>如果我们按照上文逆序输出字符串的思路，我们可以有以下的方法：</p><ol><li>从输入字符串中取首字符<code>str[0]</code>；</li><li>对于剩下的子字符串，调用函数自身来递归解决，如<code>reverseString(str[1...n-1])</code>；</li><li>在步骤2返回的结果中添加首字符；</li></ol><p>这个方法可以实现题意效果，但是不满足约束条件。因为需要额外的空间来保存步骤2的中间结果，所需空间大小和字符串长度成正比（即需要$O(n)$的空间复杂度），这一点不满足$O(1)$空间复杂度的要求。</p><h3 id="另一种分治的方法"><a href="#另一种分治的方法" class="headerlink" title="另一种分治的方法"></a>另一种分治的方法</h3><p>考虑题目中的约束条件，将其放入到递归的问题中，可以理解为在两次连续的递归调用之间不使用额外的空间消耗，也就是说，我们应该把问题分解成独立的子问题。</p><p>分解成独立子问题的一个思路是将每次输入的字符串分成两部分：1、首尾字符；2、去掉首位字符后剩下的子字符串。然后可以独立的解决两部分内容。</p><p>按照上述方法，可以有以下的方法：</p><ol><li>从输入的字符串中取首尾字符<code>str[0]</code>和<code>str[n-1]</code>；</li><li>就地交换首尾字符；</li><li>递归调用函数来反转剩余的子字符串，即<code>reverseString(str[1...n-2])</code>；</li></ol><p>注意：步骤2、3可以交换，因为是两个独立的任务。但最好保持现状的顺序，这样可以使用尾递归优化调用。我们会在后面的章节详细了解尾递归。（先简单理解一下，尾递归是指函数运行的最后一步是调用其自身，尾递归由于递归在最后一步，不再需要考虑外层函数的信息，因此可以把这个函数的调用栈给优化掉，从而避免栈溢出的风险。）</p><p>代码如下（示例代码，Python3）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: List[str]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(start, end, ls)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment"># swap the first and last element</span></span><br><span class="line">            ls[start], ls[end] = ls[end], ls[start]        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> helper(start+<span class="number">1</span>, end<span class="number">-1</span>, ls)</span><br><span class="line">    </span><br><span class="line">        helper(<span class="number">0</span>, len(s)<span class="number">-1</span>, s)</span><br></pre></td></tr></table></figure><p>如图，用字符数组<code>[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</code>举例，可以看到如何进行分解并解决的。</p><p><img src="/2019/03/21/leetcode_explore_recursion/344_reverse_string.png" style="zoom:50%"></p><p>使用这种方法，在每次递归调用的时候只需要常数级内存空间用来交换首尾字符即可，满足题目的约束条件。</p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>对于一个问题而言，如果可以用递归的思路来解决的话，那我们一定可以遵循如下的思路来实现。</p><p>举例来说，我们用一个待实现的函数$F(X)$来表示问题，其中$X$表示函数的输入，也就是问题的范围。</p><p>那么，在函数$F (X)$中，我们将做如下操作：</p><ol><li>把问题分解为更小的范围，如$x_0\in X , x_1\in X , … , x_n\in X$；</li><li>递归调用函数$F(x_0),F(x_1),…,F(x_n)$来解决$X$的子问题；</li><li>最后，处理递归调用的结果，从而解决$X$对应的问题；</li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>通过递归解决另一个问题来展示上述思路。</p><blockquote><p>给定一个链表，交换其中每两个相邻节点，并返回头结点。</p><p>例如：给定列表<code>1-&gt;2-&gt;3-&gt;4</code>，应该返回交换后的列表<code>2-&gt;1-&gt;4-&gt;3</code>的头结点。</p></blockquote><p>定义函数<code>swap(head)</code>，其中输入参数<code>head</code>表示链表的头结点。函数应该返回相邻节点交换后的新链表的头结点。</p><p>按照上述思路，我们可以按如下步骤实现这个函数：</p><ol><li>首先，我们交换链表的前两个节点，即<code>head</code>和<code>head.next</code>；</li><li>然后，我们递归调用函数<code>swap(head.next.next)</code>来处理链表的剩余部分；</li><li>最后，获得步骤2返回的子链表的头结点，并将其和步骤1的新链表相连接；</li></ol><p>作为练习，可以按照上文提供的步骤试着实现该问题的完整代码。</p><h2 id="练习：两两交换链表中的节点"><a href="#练习：两两交换链表中的节点" class="headerlink" title="练习：两两交换链表中的节点"></a>练习：两两交换链表中的节点</h2><p>详见<a href="/2019/03/21/leetcode_24/" title="【LeetCode】24、Swap Nodes in Pairs">【LeetCode】24、Swap Nodes in Pairs</a></p><p><strong>Swap Nodes in Pairs </strong></p><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p>代码如下（C++，用时4ms，内存9M）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *t = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(head-&gt;next-&gt;next);</span><br><span class="line">        t-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、Recurrence-Relation-递归关系"><a href="#二、Recurrence-Relation-递归关系" class="headerlink" title="二、Recurrence Relation 递归关系"></a>二、Recurrence Relation 递归关系</h1><p>上一章我们了解了递归的基本概念。</p><p>在实现递归函数之前，有两个重要的点需要注意：<strong>基本情况</strong>和<strong>递归关系</strong>。</p><p>在这章，我们将：</p><ul><li>通过详细的例子来了解如何定义基本情况和递归关系；</li><li>做一些练习；</li></ul><h2 id="递归关系"><a href="#递归关系" class="headerlink" title="递归关系"></a>递归关系</h2><p>在实现递归函数之前，要注意两个重要的点：</p><ul><li>递归关系：总问题结果和子问题结果之间的关系；</li><li>基本情况：不需要继续递归调用就能够计算结果的情况，就是递归结束情况。（有时基本情况也被叫做<code>bottom cases</code>，因为如果我们用自顶向下的方式对问题进行分解的话，那么基本情况通常出现在问题已经被分解到最小范围的时候，即<code>bottom</code>）</li></ul><blockquote><p>一旦我们有了上述两方面内容，那么我们只需要按照<strong>递归关系</strong>不断的调用函数本身，直到到达<strong>基本情况</strong>。</p></blockquote><p>为了解释上述内容，我们来看一个经典问题：杨辉三角（也叫 帕斯卡三角）。</p><blockquote><p>杨辉三角是由一系列数字组成的三角形。其中，每一行的最左边和最右边永远是1，剩余的其他数字，每个数是其上面两个数的和。</p></blockquote><h3 id="示例：杨辉三角"><a href="#示例：杨辉三角" class="headerlink" title="示例：杨辉三角"></a>示例：杨辉三角</h3><p>下图是一个五层的杨辉三角示意图：</p><p><img src="/2019/03/21/leetcode_explore_recursion/210px-PascalTriangleAnimated2.gif"></p><p>基于以上定义，我们的问题就是生成指定层数的杨辉三角。</p><p><strong>递归关系</strong></p><p>我们从定义杨辉三角的递归关系开始。</p><p>首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下：</p><script type="math/tex; mode=display">f(i,j)=f(i-1,j-1)+f(i-1,j)</script><p><strong>基本情况</strong></p><p>在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1.</p><p>所以，我们可以定义基本情况如下：</p><script type="math/tex; mode=display">f(i,j)=1\qquad where\qquad j=1\ or\ j=i</script><p><strong>示例</strong></p><p>可以看到，一旦定义了递归关系和基本情况之后，就可以很直观的实现递归函数了，特别是定义好数学公式以后。</p><p>如下是应用上述公式计算$f(5,3)$，即第5行第3列的值的过程。</p><p><img src="/2019/03/21/leetcode_explore_recursion/PascalTriangleAnimatedDemo.gif"></p><p>要计算$f(5,3)$，我们按照递归关系将问题分解$f(5,3)=f(4,2)+f(4,3)$，之后递归计算$f(4,2)$和$f(4,3)$的值：</p><ul><li><p>对于$f(4,2)$，我们可以继续分解，直至基本情况，如下所示：</p><script type="math/tex; mode=display">f(4,2)=f(3,1)+f(3,2)=f(3,1)+(f(2,1)+f(2,2))=1+(1+1)=3</script></li><li><p>对于$f(4,3)$，同样的，我们可以将其分解如下：</p><script type="math/tex; mode=display">f(4,3)=f(3,2)+f(3,3)=(f(2,1)+f(2,2))+f(3,3)=(1+1)+1=3</script></li><li><p>最后我们组合上述子问题的结果：</p><script type="math/tex; mode=display">f(5,3)=f(4,2)+f(4,3)=3+3=6</script></li></ul><p><strong>下一步</strong></p><p>在上面的示例中，可以注意到在递归解决方案中有一些重复的计算，就是说，我们为了计算最后一行的值，重复的计算了很多中间结果。例如，为了计算$f(5,3)$，我们在计算$f(4,2)$和$f(4,3)$的过程中重复计算了两边$f(3,2)$的值。</p><p>我们将在下一章讨论如何避免这些重复计算。</p><p>按照本章的内容，可以做一些和杨辉三角相关的练习题。</p><p>详见<a href="/2019/03/22/leetcode_118/" title="【LeetCode】118、杨辉三角">【LeetCode】118、杨辉三角</a>，<a href="/2019/03/22/leetcode_119/" title="【LeetCode】119、杨辉三角2">【LeetCode】119、杨辉三角2</a>，<a href="/2019/03/22/leetcode_206/" title="【LeetCode】206、反转链表">【LeetCode】206、反转链表</a>。</p><h2 id="练习：杨辉三角"><a href="#练习：杨辉三角" class="headerlink" title="练习：杨辉三角"></a>练习：杨辉三角</h2><p><strong>Pascal’s Triangle</strong></p><p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em>of Pascal’s triangle.</p><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码如下（C++，用时4ms，内存8.8M）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) &#123;</span><br><span class="line">            temp.push_back(<span class="number">1</span>);</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.push_back(<span class="number">1</span>);</span><br><span class="line">        result.push_back(temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; numRows; row++) &#123;</span><br><span class="line">            temp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt;= row; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">0</span> || col == row) &#123;</span><br><span class="line">                    temp.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.push_back(result[row - <span class="number">1</span>][col - <span class="number">1</span>] + result[row - <span class="number">1</span>][col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：杨辉三角2"><a href="#练习：杨辉三角2" class="headerlink" title="练习：杨辉三角2"></a>练习：杨辉三角2</h2><p><strong>Pascal’s Triangle II</strong></p><p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p><p>Note that the row index starts from 0.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p><p>代码如下（C++，用时4ms，内存8.3M）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        temp.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= rowIndex; row++) &#123;</span><br><span class="line">            result.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt;= row; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">0</span> || col == row) &#123;</span><br><span class="line">                    result.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.push_back(temp[col - <span class="number">1</span>] + temp[col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：反转链表"><a href="#练习：反转链表" class="headerlink" title="练习：反转链表"></a>练习：反转链表</h2><p><strong>Reverse Linked List</strong></p><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><p>代码如下（C++，用时8ms，内存9M）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre, ListNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>) &#123; <span class="comment">// 递归结束的判断</span></span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        <span class="keyword">return</span> reverse(pre, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>, *cur = head;</span><br><span class="line">        <span class="keyword">return</span> head ? reverse(pre, cur) : head; <span class="comment">// 如果head为空的话，我们直接返回head/NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：反转链表"><a href="#解答：反转链表" class="headerlink" title="解答：反转链表"></a>解答：反转链表</h2><h3 id="方法1、迭代法"><a href="#方法1、迭代法" class="headerlink" title="方法1、迭代法"></a>方法1、迭代法</h3><p>假设有链表$1\rightarrow 2\rightarrow 3\rightarrow \emptyset$，要将其转为$\emptyset \leftarrow 1\leftarrow 2\leftarrow 3$。</p><p>遍历链表，将当前节点的<code>next</code>指针指向其前一个节点。由于链表没有指向前一个节点的指针，所以需要提前保存前一个节点的信息。同时还需要一个指针，在改变<code>next</code>指向时用来保存当前<code>next</code>的节点。最后不要忘了返回新的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O (n)$。$n$是链表长度。</li><li>空间复杂度：$O (1)$。</li></ul><h3 id="方法2、递归法"><a href="#方法2、递归法" class="headerlink" title="方法2、递归法"></a>方法2、递归法</h3><p>递归方法要考虑回退工作，略难一点。假设链表的剩余部分已经反转好了，怎么反转其前半部分呢？</p><p>对于链表$n_1\rightarrow …\rightarrow n_{k-1} \rightarrow n_k \rightarrow n_{k+1} \rightarrow … \rightarrow n_m \rightarrow \emptyset​$，假设从节点$n_{k+1}​$到节点$n_m​$已经反转好了，并且当前在节点$n_k​$处：$n_1 \rightarrow … \rightarrow n_{k-1} \rightarrow \mathbf{n_k} \rightarrow n_{k+1} \leftarrow … \leftarrow n_m​$。</p><p>我们想让$n_{k+1}$的下一个节点指向$n_k$，所以：$n_k .next.next=n_k$。</p><p>要注意的是$n_1$节点的<code>next</code>必须指向$\emptyset​$。如果忽略这一步的话，那就把链表变成首尾相接的圆形的了。如果测试链表长度为2的情况，可能会触发这个bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next); <span class="comment">// 保留头结点，递归反转剩余部分</span></span><br><span class="line">    head.next.next = head; <span class="comment">// 把剩余部分的头结点指向到保留的头结点上，类似上文说的 n(k+1) 的next指向到 nk ，实现反转</span></span><br><span class="line">    head.next = <span class="keyword">null</span>; <span class="comment">// 把保留的头结点反转，指向空，即 n(k+1) 指向 nk 后，再将 nk 指向空</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O (n)$。$n$是链表长度。</li><li>空间复杂度：$O(n)$。额外的空间消耗来源于递归所需的隐藏的栈空间，递归最深为$n$层。</li></ul><h1 id="三、Memoization-缓存计算"><a href="#三、Memoization-缓存计算" class="headerlink" title="三、Memoization 缓存计算"></a>三、Memoization 缓存计算</h1><p>在上一章，我们提到过递归算法中的<strong>重复计算</strong>问题。在最好的情况下，重复计算只是会增加算法的时间复杂度，但是在最差的情况，重复计算会导致无限循环。</p><p>因此，在这章，我们将：</p><ul><li>用一个例子开始，展示重复计算是如何导致的；</li><li>展示如何用缓存计算的技术来避免重复计算；</li></ul><h2 id="递归中的重复计算"><a href="#递归中的重复计算" class="headerlink" title="递归中的重复计算"></a>递归中的重复计算</h2><p>递归是实现算法的一种强有力的方法，但是如果不好好使用的话，也会带来额外的问题，如重复计算。例如，在上一章的后半部分，我们提到过杨辉三角中的重复计算问题，一些中间结果被反复计算了多次。</p><p>在这章，我们将进一步的讨论递归中可能发生的重复计算问题，并提出一种叫做<strong>缓存计算</strong>的常用技术手段来避免这个问题。</p><p>为了用另一个例子来演示重复计算问题，我们看一个大部分都熟悉的例子：斐波那契数列。如果我们定义函数$F(n)$来表示索引为$n$的斐波那契数，那可以得到如下所示的递归关系式：</p><script type="math/tex; mode=display">F(n)=F(n-1)+F(n-2)</script><p>而基本情况（递归结束条件）为：</p><script type="math/tex; mode=display">F(0)=0\ ,\ F(1)=1</script><p>有了斐波那契数的定义之后，可以按如下所示实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>现在，如果想计算$F(4)$，就可以按照上述公式来实现：</p><script type="math/tex; mode=display">F(4)=F(3)+F(2)=(F(2)+F(1))+F(2)</script><p>可以看到，按照上述过程，为了计算$F(4)$的结果，我们需要计算两遍$F(2)$。</p><p>如图所示，用一棵树展示了在计算$F(4)​$的过程中进行的所有重复计算（用颜色分类）：</p><p><img src="/2019/03/21/leetcode_explore_recursion/fibonacci.png" style="zoom:30%"></p><h3 id="缓存计算"><a href="#缓存计算" class="headerlink" title="缓存计算"></a>缓存计算</h3><p>为了尽可能多的消除上述情况中的重复计算，一个方法就是将中间结果<strong>保存</strong>在缓存中，这样下次遇到的时候就可以重复使用而不需要再次计算了。</p><p>这个方法就是<strong>缓存计算</strong>方法，是经常和递归一起使用的一种技术。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="noopener">Memoization</a> is an optimization technique used primarily to <strong>speed up</strong> computer programs by <strong>storing</strong> the results of expensive function calls and returning the cached result when the same inputs occur again. (Source: wikipedia)</p><p><strong>缓存计算</strong>是通过将高消耗的函数调用结果进行保存，并且在再次遇到相同输入的时候返回缓存结果，从而提升程序运行速度的一种优化技术。</p></blockquote><p>回到斐波那契函数$F(n)$，我们可以用一个哈希表来跟踪每个$F(n)$的值，用$n$做<code>key</code>。哈希表作为缓存使我们避免重复计算。缓存技术是一个很好的用一些额外空间来换取时间减少的例子。</p><p>为了对比，我们提供了如下的用缓存计算实现的斐波那契数。</p><p>作为练习，可以通过更一般性的方法来实现缓存计算，即不改变原来的函数而应用缓存计算。（可以引用设计模式<code>decorator</code>）</p><p>关于<code>decorator</code>设计模式可参考<a href="/2019/03/25/decorator_python/" title="设计模式——decorator">设计模式——decorator</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type N: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur_fib</span><span class="params">(N)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> N <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[N]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">            result = N</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = recur_fib(N<span class="number">-1</span>) + recur_fib(N<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># put result in cache for later reference.</span></span><br><span class="line">        cache[N] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recur_fib(N)</span><br></pre></td></tr></table></figure><p>使用<code>decorator</code>模式代码如下（自己实现）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cache</span><span class="params">(func)</span>:</span> </span><br><span class="line">        caches = &#123;&#125; </span><br><span class="line"><span class="meta">        @wraps(func) </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args)</span>:</span> </span><br><span class="line">            <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> caches: </span><br><span class="line">                caches[args] = func(*args)</span><br><span class="line">            <span class="keyword">return</span> caches[args] </span><br><span class="line">        <span class="keyword">return</span> wrap </span><br><span class="line">    </span><br><span class="line"><span class="meta">    @cache </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span> </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: </span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.fib(n<span class="number">-1</span>) + self.fib(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>在这章中，可以通过斐波那契数和爬楼梯问题来进行练习。</p><p>详见：<a href="/2019/03/25/leetcode_509/" title="【LeetCode】509、斐波那契数">【LeetCode】509、斐波那契数</a>，<a href="/2019/03/14/leetcode_70/" title="【LeetCode】70、爬楼梯">【LeetCode】70、爬楼梯</a></p><p>在下一章，我们将深入讨论在递归算法中的复杂度分析。</p><h2 id="练习：斐波那契数"><a href="#练习：斐波那契数" class="headerlink" title="练习：斐波那契数"></a>练习：斐波那契数</h2><p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), for N &gt; 1.</span><br></pre></td></tr></table></figure><p>Given <code>N</code>, calculate <code>F(N)</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>0 ≤ <code>N</code> ≤ 30.</p><p>代码如下（Python，用时20ms，内存11.8M）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur_fib</span><span class="params">(N)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> N <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[N]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">                result = N</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = recur_fib(N<span class="number">-1</span>) + recur_fib(N<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># put result in cache for later reference.</span></span><br><span class="line">            cache[N] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur_fib(N)</span><br></pre></td></tr></table></figure><h2 id="练习：爬楼梯"><a href="#练习：爬楼梯" class="headerlink" title="练习：爬楼梯"></a>练习：爬楼梯</h2><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><p>代码如下（Python3，用时80ms，内存13.2M）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        tempNum = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            tempNum.append(tempNum[i<span class="number">-1</span>] + tempNum[i<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> tempNum[n]</span><br></pre></td></tr></table></figure><h2 id="解答：爬楼梯"><a href="#解答：爬楼梯" class="headerlink" title="解答：爬楼梯"></a>解答：爬楼梯</h2><blockquote><p>本节代码均为原网页给出的参考代码，均为Java实现。</p></blockquote><h3 id="方法1：暴力法"><a href="#方法1：暴力法" class="headerlink" title="方法1：暴力法"></a>方法1：暴力法</h3><p>暴力法就是计算所有可能的走法组合，也就是每一步爬1层和每一步爬两层。在每一步我们都调用函数$climpStairs$来计算爬一层和爬两层的结果，并返回两个函数返回值的和。</p><script type="math/tex; mode=display">climbStairs(i,n)=climbStairs(i+1,n)+climbStairs(i+2,n)</script><p>其中$i$表示当前层数，$n$表示目标层数。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        climb_Stairs(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climb_Stairs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> climb_Stairs(i + <span class="number">1</span>, n) + climb_Stairs(i + <span class="number">2</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(2^n)$。递归树的大小是$2^n$。</p><p>如下所示为$n=5$时的递归树：</p><p><img src="/2019/03/21/leetcode_explore_recursion/70_Climbing_Stairs_rt.jpg" style="zoom:50%"></p></li><li><p>空间复杂度：$O(n)$。递归树的最大深度为$n$。</p></li></ul><h3 id="方法2：采用缓存计算的递归法"><a href="#方法2：采用缓存计算的递归法" class="headerlink" title="方法2：采用缓存计算的递归法"></a>方法2：采用缓存计算的递归法</h3><p>在上一种方法中重复计算了很多中间结果。可以用一个<code>memo</code>数组将每一步的结果进行存储，当再次调用这个函数的时候可以直接从<code>memo</code>数组中返回结果。</p><p>通过这种使用<code>memo</code>数组来调整递归树的方法，可以将递归树的大小减少到$n$。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> memo[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> climb_Stairs(<span class="number">0</span>, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climb_Stairs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span> memo[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = climb_Stairs(i + <span class="number">1</span>, n, memo) + climb_Stairs(i + <span class="number">2</span>, n, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$。递归树的大小为$n$。</li><li>空间复杂度：$O(n)$。递归树的最大深度为$n$。</li></ul><h3 id="方法3：动态规划"><a href="#方法3：动态规划" class="headerlink" title="方法3：动态规划"></a>方法3：动态规划</h3><p>可以看到，这个问题可以分解成多个子问题，并且包含最优子结构性质，也就是说，这个问题的最优解可以通过其子问题的最优解来组合得到，所以我们可以采用动态规划方法来解决这个问题。</p><p>我们可以通过以下两种方法到达第$i$层：</p><ol><li>在第$i-1$层走一步；</li><li>在第$i-2$层走两步；</li></ol><p>所以，到达第$i$层的总方法数等于到达第$i-1$层的方法数和到达第$i-2$层的方法数的总和。</p><p>用$dp[i]$表示到达第$i$层所需的总方法数，则：</p><script type="math/tex; mode=display">dp[i]=dp[i-1]+dp[i-2]</script><p>例如：</p><p><img src="/2019/03/21/leetcode_explore_recursion/climbStairsAnimation.gif"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$。单层循环到$n$。</li><li>空间复杂度：$O(n)$。使用大小为$n$的$dp$数组。</li></ul><h3 id="方法4：斐波那契数法"><a href="#方法4：斐波那契数法" class="headerlink" title="方法4：斐波那契数法"></a>方法4：斐波那契数法</h3><p>在上面的方法中使用了$dp$数组，并且$dp[i]=dp[i-1]+dp[i-2]$。可以很容易的联想到，$dp[i]$正是斐波那契数的第$i$个值：</p><script type="math/tex; mode=display">Fib(n)=Fib(n-1)+Fib(n-2)</script><p>那么，我们只需要找到斐波那契数列的第$n$个值即可，其中前两个值分别为1和2，即$Fib(1)=1$，$Fib(2)=2$。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$。计算第$n$个斐波那契数需要循环到$n$。</li><li>空间复杂度：$O(1)$。使用固定的空间。</li></ul><h3 id="方法5：Binets-Method-（比奈法？）使用矩阵的方法"><a href="#方法5：Binets-Method-（比奈法？）使用矩阵的方法" class="headerlink" title="方法5：Binets Method （比奈法？）使用矩阵的方法"></a>方法5：Binets Method （比奈法？）使用矩阵的方法</h3><p>这是一个非常有趣的使用矩阵乘法来计算第$n$个斐波那契数的方法。矩阵形式如下：</p><script type="math/tex; mode=display">\begin{bmatrix}   F_{n+1} & F_n \\   F_n & F_{n-1}\end{bmatrix}=\begin{bmatrix}   1 & 1 \\   1 & 0\end{bmatrix}</script><p>令$Q= \begin{bmatrix}F_{n+1} &amp; F_n \\ F_n &amp; F_{n-1} \end{bmatrix}​$。按照这个方法，第$n​$个斐波那契数可以由$Q^{n-1}[0,0]​$得到。</p><p>我们来看方法的证明：</p><p>可以使用数学归纳法来证明这个方法。我们知道，这个矩阵给出了第3个斐波那契数（基本情况）的正确结果，$Q^2= \begin{bmatrix}2 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}​$。这证明了基本情况是适用于这个方法的。</p><p>假设这个方法也适用于第$n$个斐波那契数的问题，即$F_n = Q^{n-1}[0,0]$，其中$Q^{n-1}= \begin{bmatrix} F_n &amp; F_{n-1} \\ F_{n-1} &amp; F_{n-2} \end{bmatrix}$。</p><p>现在，我们需要证明在上述两个条件为真的情况下，这个方法对于计算第$n+1​$个斐波那契数也是有效的，即证明$F_{n+1}=Q^n[0,0]​$。</p><p>证明过程：</p><script type="math/tex; mode=display">Q^n=\begin{bmatrix}   F_{n} & F_{n-1} \\   F_{n-1} & F_{n-2}\end{bmatrix}\begin{bmatrix}    1 & 1 \\    1 & 0\end{bmatrix}=\begin{bmatrix}    F_n+F_{n-1} & F_n \\    F_{n-1}+F_{n-2} & F_{n-1}\end{bmatrix}=\begin{bmatrix}    F_{n+1} & F_n \\    F_n & F_{n-1}\end{bmatrix}</script><p>所以，$F_{n+1}=Q^n[0,0]$。</p><p>至此，完成了这个方法的证明。</p><p>用这个方法解决爬楼梯问题所要做的唯一的改动就是，修改初始值为2和1（斐波那契数列的初始值是1和0）。或者，另一个方法是不修改初始值，而是使用相同的矩阵，但是用结果$result=Q^n[0,0]$来得到爬楼梯问题的第$n$层最终解。做这种调整的原因是因为爬楼梯问题使用的是斐波那契数列列的第2、3项做基本情况。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] res = pow(q, n);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] pow(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(\log(n))$。</li><li>空间复杂度：$O(1)$。使用固定的空间。</li></ul><p>时间复杂度证明：</p><p>假设有一个$n$次幂的矩阵$M$，假设$n$是2的幂，那么$n=2^i , i \in \mathbb{N} $，其中$\mathbb {N}$表示自然数集合（包括0）。我们可以用如下形式的树来表示：</p><p><img src="/2019/03/21/leetcode_explore_recursion/70_Climbing_Stairs.PNG"></p><p>图中内容表示：$M^n=M^{n/2}=…=\prod_1^n{M^1}​$。</p><p>所以，为了计算矩阵$M^n$，我们需要计算$M^{n/2}$并且和自己相乘。为了计算$M^{n/2}$需要计算$M^{n/4}$，等等等等。</p><p>显然，树的高度为$\log_2{n}$。</p><p>下面来估计$M^n$的计算时间。矩阵$M$在任意次幂的大小都一样，所以我们可以在$O(1)$的时间内计算任意次幂的两个矩阵相乘。这样的计算需要执行$\log_2{n}$次。所以$M^n$的计算复杂度为$O(\log_2{n})$。</p><p>如果$n$不是2的幂，那么我们可以通过其二进制表示将其分解为用2的次幂表示：</p><script type="math/tex; mode=display">n=\sum_{p\in{P}}2^p\ ,\ \text{where}\ P\subset\mathbb{N}</script><p>这样我们可以通过如下公式来得到最终结果：</p><script type="math/tex; mode=display">M^n=\prod_{p\in P}M^{2^p}</script><p>这就是在实现中使用的方法？由于乘法的计算次数已经限制在$O(\log_2n)​$，所以总的复杂度就是$O(\log_2n)​$。</p><h3 id="方法6、斐波那契公式"><a href="#方法6、斐波那契公式" class="headerlink" title="方法6、斐波那契公式"></a>方法6、斐波那契公式</h3><blockquote><p>没太仔细理解这个方法。。。</p></blockquote><p>我们可以用如下公式计算得到第$n$个斐波那契数：</p><script type="math/tex; mode=display">F_n=\cfrac{1}{\sqrt{5}}\left[\left(\cfrac{1+\sqrt5}{2}\right)^n-\left(\cfrac{1-\sqrt5}{2}\right)^n\right]</script><p>对于给定的问题，斐波那契数列定义为：$F_0=1,F_1=1,F_2=2,F_{n+2}=F_{n+1}+F_n$。解决这种递归公式的一种标准方法是假设$F_n$的形式为$F_n=a^n$。这样的话，显然$F_{n+1}=a^{n+1}$并且$F_{n+2}=a^{n+2}$，所以等式就变为$a^{n+2}=a^{n+1}+a^n$。如果我们将整个等式除以$a^n$，就得到$a^2=a+1$，也就是二次方程$a^2-a-1=0$。</p><p>对这个二次方程求解，可以得到：</p><script type="math/tex; mode=display">a=1/\sqrt5\left(\left( \cfrac{1\pm \sqrt5}{2} \right)\right)</script><p>对于一般情况，可以得到等式：</p><script type="math/tex; mode=display">F_n=A\left( \cfrac{1+\sqrt 5}{2} \right)^n+B\left( \cfrac{1-\sqrt 5}{2} \right)^n</script><p>对于$n=0$的情况，有$A+B=1$，</p><p>对于$n=1$的情况，有$A\left( \cfrac{1+\sqrt 5}{2} \right)+B\left( \cfrac{1-\sqrt 5}{2} \right)=1$，</p><p>对上述等式求解，可以得到：</p><script type="math/tex; mode=display">A=\left( \cfrac{1+\sqrt 5}{2\sqrt 5} \right)\ ,\ B=\left( \cfrac{1-\sqrt 5}{2\sqrt 5} \right)</script><p>将$A$和$B$的值代入到上述的通用等式中，可以得到：</p><script type="math/tex; mode=display">F_n=\cfrac{1}{\sqrt{5}}\left[\left(\cfrac{1+\sqrt5}{2}\right)^{n+1}-\left(\cfrac{1-\sqrt5}{2}\right)^{n+1}\right]</script><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5=Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibn=Math.pow((<span class="number">1</span>+sqrt5)/<span class="number">2</span>,n+<span class="number">1</span>)-Math.pow((<span class="number">1</span>-sqrt5)/<span class="number">2</span>,n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(fibn/sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(\log(n))$。$pow$计算需要$\log(n)$的时间。</li><li>空间复杂度：$O(1)​$。使用固定空间。</li></ul><h1 id="四、Complexity-Analysis-复杂度分析"><a href="#四、Complexity-Analysis-复杂度分析" class="headerlink" title="四、Complexity Analysis 复杂度分析"></a>四、Complexity Analysis 复杂度分析</h1><p>在这一章，我们将讨论如何计算递归算法中的时间和空间复杂度。</p><p>特别的是，本章将展示一个非常有用的叫做<code>尾递归</code>的技术，可以用来优化递归问题中的空间复杂度，更重要的是可以避免栈溢出的问题。</p><h2 id="时间复杂度——递归"><a href="#时间复杂度——递归" class="headerlink" title="时间复杂度——递归"></a>时间复杂度——递归</h2><p>这一部分，我们主要讨论如何计算递归问题中的时间复杂度。</p><blockquote><p>给定一个递归问题，其时间复杂度$O(T)$主要是由递归调用的次数（用$R$表示）和每次递归中所需的计算时间（用$O(s)$表示）共同决定的：</p><script type="math/tex; mode=display">O(T)=R*O(s)</script></blockquote><p>来看一些例子。</p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>在反转字符串问题中，我们需要将一个字符串逆序输出。解决这个问题的一个递归关系可以表示如下：</p><script type="math/tex; mode=display">printReverse(str)=printReverse(str[1...n])+print(str[0])</script><p>其中$str[1…n]$是输入字符串$str$的子串，$str[0]$是首字符。</p><p>可以看到，函数递归调用$n$次，$n$是输入字符串的长度。在每一次递归中，只是简单的输出首字符，所以该操作的时间复杂度是常数级，即$O(1)$。</p><p>所以，递归函数$printReverse(str)$的总时间复杂度就是$O(printReverse)=n*O(1)=O(n)$。</p><h3 id="执行树"><a href="#执行树" class="headerlink" title="执行树"></a>执行树</h3><p>对于递归函数，调用次数刚好和输入成线性关系的情况是很少见的。例如，在上一章讨论过的斐波那契数列问题，递归函数定义为$f(n)=f(n-1)+f(n-2)$。乍一看，斐波那契函数的调用次数并不能够很直观的得到。</p><blockquote><p>在这种情况，最好是采用<code>execution tree 执行树</code>的方式，这种树是用来详细表示递归函数执行过程的。树上的每个节点表示递归函数的一次调用，所以总的节点数就是整个执行过程中递归调用的总次数了。</p></blockquote><p>执行树用一个$n$叉树来表示，其中$n$表示递归关系中出现递归调用的次数。例如，斐波那契数列问题的执行树是一颗二叉树，下图表示了计算斐波那契数$f(4)$的执行树：</p><p><img src="/2019/03/21/leetcode_explore_recursion/fibonacci.png"></p><p>对于一个$n$层的二叉树，其节点总数是$2^n-1$。所以，$f(n)$递归调用次数的上限（虽然不是很严格）就是$2^n-1$。所以，可以得到斐波那契数列问题$f(n)$的时间复杂度是$O(2^n)$。</p><h3 id="缓存计算-1"><a href="#缓存计算-1" class="headerlink" title="缓存计算"></a>缓存计算</h3><p>在上一章，讨论过递归算法中用于优化时间复杂度的方法——缓存计算。通过将中间结果进行缓存和重复使用，缓存计算可以大幅减少递归调用的次数，也就是减少执行树的分支数。所以应该考虑到使用缓存计算的递归算法时间复杂度。</p><p>回到斐波那契数列问题，使用缓存计算的话，可以将每个斐波那契数的结果进行保存。保证对每个斐波那契数的计算只执行一次。由递归关系可以知道，对于斐波那契数$f(n)$，依赖于前$n-1$个斐波那契数，所以，$f(n)$的递归计算过程将会调用$n-1$次，来计算其所依赖的所以前序数值。</p><p>现在可以直接使用本章开始时候给出的公式来计算时间复杂度，即$O(1)*n=O(n)$。缓存计算不仅优化了算法的时间复杂度，也简化了时间复杂度的分析过程。</p><p>接下来，我们讨论如何分析递归算法的空间复杂度。</p><h2 id="空间复杂度——递归"><a href="#空间复杂度——递归" class="headerlink" title="空间复杂度——递归"></a>空间复杂度——递归</h2><p>这一部分，将讨论如何分析递归算法中的空间复杂度。</p><blockquote><p>当讨论递归算法的空间复杂度时，应该考虑两部分的空间消耗：递归相关的空间和非递归相关的空间。</p></blockquote><h3 id="递归相关的空间"><a href="#递归相关的空间" class="headerlink" title="递归相关的空间"></a>递归相关的空间</h3><p>递归相关的空间指的是由递归调用所直接产生内存消耗，即保存递归函数调用所需的栈空间。为了完成一个典型的递归调用，系统需要分配一些空间来保存三部分重要的信息：</p><ol><li>函数的返回地址：一旦函数调用完成，程序应该知道返回到哪里，即函数调用之前的位置；</li><li>函数传递的参数；</li><li>函数的局部变量；</li></ol><p>这个栈空间是函数调用过程中所产生的最小开销，一旦函数执行结束，空间就会被释放。</p><p>对于递归算法，函数调用会链式累积，直到到达基本情况。这意味着每个函数调用所需的空间也会累积。</p><blockquote><p>对于递归算法，如果没有其他内存消耗，那么这个由递归行为本身所引起的空间消耗将会是整个算法的空间上限。</p></blockquote><p>例如，在逆序输出字符串的练习中，由于只是单纯的输出字符，所以在递归调用本身之外没有额外的空间消耗。对于每一个递归调用，我们假设需要一个常数级的空间。递归调用将持续$n$次，$n$是输入字符串的长度。所以这个递归算法的空间复杂度是$O(n)$。</p><p>为了说明这一点，以递归调用$f(x_1)\rightarrow f(x_2)\rightarrow f(x_3)$为例，展示了执行步骤的顺序和堆栈布局。</p><p><img src="/2019/03/21/leetcode_explore_recursion/card_recursion_stack.png"></p><p>为了调用$f(x_2)$，会给$f(x_1)$分配一个栈空间。同理，在$f(x_2)$中也会为了调用$f(x_3)$而分配另一个栈空间。最终在$f(x_3)$中，程序到达基本情况，因此没有在$f(x_3)$中进一步递归。</p><p>由于这些递归相关的空间消耗，有时会导致栈溢出的情况，就是分配给一个程序的栈空间超出了其最大空间限制，导致程序失败。因此，当设计递归算法时，要仔细考虑当输入规模比较大的时候是否可能导致栈溢出。</p><h3 id="非递归相关的空间"><a href="#非递归相关的空间" class="headerlink" title="非递归相关的空间"></a>非递归相关的空间</h3><p>如标题所示，非递归相关的空间主要是指和递归没有直接关系的内存空间，通常包括分配给全局变量的空间（通常为堆）。</p><p>不论是否递归，在任何后续函数调用前都需要将问题的输入作为全局变量保存。同时还需要存储递归调用的中间结果。后者就是我们在前面章节讨论过缓存计算。例如，对于使用缓存计算实现的计算斐波那契数列的递归算法，我们使用一个<code>map</code>来记录递归调用过程中出现的所有斐波那契数。因此，在分析空间复杂度的时候，我们应该考虑到缓存计算的空间成本。</p><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>在之前的页面，讨论过递归调用过程中系统分配栈空间所产生的隐藏空间开销。但是，我们应该学会识别一种递归的特殊情况——尾递归，尾递归避免了这部分空间开销。</p><blockquote><p>尾递归是指在递归函数执行的最后命令是递归调用，并且应该只有一个递归调用。</p></blockquote><p>在反转字符串的问题中我们已经看到了一个尾递归的例子。这里用另一个例子展示非尾递归和尾递归的区别。注意，非尾递归的例子在最后一个递归调用之后有一个额外的计算步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_non_tail_recursion</span><span class="params">(ls)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type ls: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int, the sum of the input list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(ls) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># not a tail recursion because it does some computation after the recursive call returned.</span></span><br><span class="line">    <span class="keyword">return</span> ls[<span class="number">0</span>] + sum_non_tail_recursion(ls[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_tail_recursion</span><span class="params">(ls)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type ls: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int, the sum of the input list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(ls, acc)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(ls) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> acc</span><br><span class="line">        <span class="comment"># this is a tail recursion because the final instruction is a recursive call.</span></span><br><span class="line">        <span class="keyword">return</span> helper(ls[<span class="number">1</span>:], ls[<span class="number">0</span>] + acc)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(ls, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>尾递归的好处是可以避免递归调用过程中的堆栈开销累积，因为系统在每次递归调用的时候可以重复利用一部分栈空间。</p><p>以递归调用$f(x_1)\rightarrow f(x_2)\rightarrow f(x_3)$为例，其中函数$f(x)$是使用尾递归实现的，如下展示了执行步骤的顺序和堆栈布局。</p><p><img src="/2019/03/21/leetcode_explore_recursion/card_recursion_tail.png"></p><p>注意在尾递归中，一旦递归调用结束，我们就会理解知道返回值，所以图中跳过了递归返回的完整链路，直接返回到原始调用的地方。这意味着，我们不再需要对所有递归调用都分配栈，从而节省了空间。</p><p>例如，在步骤1中，为了调用$f(x_2)$而在$f(x_1)$中分配了栈空间。在步骤2中，$f(x_2)$会递归调用$f(x_3)$，但是系统可以直接重复使用之前为第二次递归调用分配的空间，而不是分配新的空间。最终，在函数$f(x_3)$中，我们到达了基本情况，函数可以直接返回到原始调用的地方，而不需要逐步返回到上一个调用的函数。</p><p>尾递归函数可以当做非尾递归函数执行，也就是调用成堆的栈，而不影响结果。通常，编译器会识别尾递归并优化执行过程。但是，并不是所有语言都支持这种优化。例如，C、C++支持尾递归优化，而Java和Python不支持尾递归优化。</p><h2 id="练习：二叉树的最大深度"><a href="#练习：二叉树的最大深度" class="headerlink" title="练习：二叉树的最大深度"></a>练习：二叉树的最大深度</h2><p>详见<a href="/2019/03/25/leetcode_104/" title="【LeetCode】104、二叉树的最大深度">【LeetCode】104、二叉树的最大深度</a></p><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example:</strong></p><p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its depth = 3.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (leftDepth &gt; rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：二叉树的最大深度"><a href="#解答：二叉树的最大深度" class="headerlink" title="解答：二叉树的最大深度"></a>解答：二叉树的最大深度</h2><p>要花钱才能解锁，没有看:joy:。</p><h2 id="练习：Pow-x-n"><a href="#练习：Pow-x-n" class="headerlink" title="练习：Pow(x, n)"></a>练习：Pow(x, n)</h2><p>详见<a href="/2019/03/25/leetcode_50/" title="【LeetCode】50、Pow(x,n)">【LeetCode】50、Pow(x,n)</a></p><p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a>, which calculates <em>x</em> raised to the power <em>n</em> (xn).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> is a 32-bit signed integer, within the range $[-2^{31},2^{31}-1]​$</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> half = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) <span class="keyword">return</span> half * half * x;</span><br><span class="line">        <span class="keyword">return</span> half * half / x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：Pow-x-n"><a href="#解答：Pow-x-n" class="headerlink" title="解答：Pow(x, n)"></a>解答：Pow(x, n)</h2><p>要花钱才能解锁，没有看:joy:。</p><h1 id="五、Conclusion-总结"><a href="#五、Conclusion-总结" class="headerlink" title="五、Conclusion 总结"></a>五、Conclusion 总结</h1><p>在之前的章节，我们了解了递归的概念的原则。</p><p>作为提醒，以下是解决递归问题的共用工作流程：</p><ol><li>定义递归函数；</li><li>总结递归关系和基本情况；</li><li>如果有重复计算问题的话，使用缓存计算来消除；</li><li>如果可能，使用尾递归来优化空间复杂度；</li></ol><p>在本章，将对递归算法做一些总结，并且提供一些在利用递归解决问题的过程中可能用到的tips。</p><h2 id="总结——递归-1"><a href="#总结——递归-1" class="headerlink" title="总结——递归-1"></a>总结——递归-1</h2><p>现在，我们了解到递归确实是一个可以用来解决很多问题的有效方法。但是，由于时间和空间的限制，并不是所有问题都能用递归解决。递归可能会有一些负面效果，如栈溢出问题。</p><p>在这章，将分享一些可以更好的利用递归来解决实际问题的tips：</p><blockquote><p><strong>疑惑的时候，把递归关系写下来。</strong></p></blockquote><p>有时，乍一看，问题能够用递归算法解决并不明显。但是，由于递归算法和我们所熟悉的数学非常接近，所以利用数学公式推导出一些关系式总是有帮助的。通常，可以帮助澄清问题概念并揭示隐藏的递归关系。在本章后面，可以通过一个例子（Unique Binary Search Trees II）来了解在数学公式的辅助下利用递归方法解决问题。</p><blockquote><p><strong>如果可能，使用缓存计算。</strong></p></blockquote><p>在起草递归算法的时候，可以从最简单的策略开始。有时，在递归过程中会存在重复计算，如斐波那契数问题。在这种情况下，应该尝试使用缓存计算技术，将中间结果缓存以后后续重复使用。缓存计算利用空间上的一些折中来换取时间复杂度的大幅提升。</p><blockquote><p><strong>当出现栈溢出问题时，尾递归可能会有帮助。</strong></p></blockquote><p>使用递归算法通常有几种不同的实现。尾递归是其中一个特定的实现形式。和缓存计算不同，尾递归可以通过消除递归算法带来的堆栈开销来优化算法的空间复杂度。更重要的是，使用尾递归可以避免递归算法常出现的栈溢出问题。尾递归的另一个优点是比非尾递归更容易阅读和理解。因为和非尾递归不同，尾递归中不存在递归后调用的问题（即递归操作是函数的最后操作）。所以，只要可能，应该尽量使用尾递归。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>现在，利用目前为止所了解到的递归知识，可以在LeetCode上解决更多问题。在本章中，还提供了几个练习。</p><h2 id="练习：合并两个有序链表"><a href="#练习：合并两个有序链表" class="headerlink" title="练习：合并两个有序链表"></a>练习：合并两个有序链表</h2><p>详见<a href="/2019/03/26/leetcode_21/" title="【LeetCode】21、合并两个有序链表">【LeetCode】21、合并两个有序链表</a></p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val&lt;l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：合并两个有序链表"><a href="#解答：合并两个有序链表" class="headerlink" title="解答：合并两个有序链表"></a>解答：合并两个有序链表</h2><p>要花钱才能解锁，没有看:joy:。</p><h2 id="练习：第k个语法符号"><a href="#练习：第k个语法符号" class="headerlink" title="练习：第k个语法符号"></a>练习：第k个语法符号</h2><p>详见<a href="/2019/03/26/leetcode_779/" title="【LeetCode】779、第k个语法符号">【LeetCode】779、第k个语法符号</a></p><p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code>with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p><p>Given row <code>N</code> and index <code>K</code>, return the <code>K</code>-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">Input: N = 1, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: N = 4, K = 5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row 1: 0</span><br><span class="line">row 2: 01</span><br><span class="line">row 3: 0110</span><br><span class="line">row 4: 01101001</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>N</code> will be an integer in the range <code>[1, 30]</code>.</li><li><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (K%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthGrammar(N<span class="number">-1</span>, K/<span class="number">2</span>)==<span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> kthGrammar(N<span class="number">-1</span>, (K+<span class="number">1</span>)/<span class="number">2</span>)==<span class="number">0</span> ? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：第k个语法符号"><a href="#解答：第k个语法符号" class="headerlink" title="解答：第k个语法符号"></a>解答：第k个语法符号</h2><p>要花钱才能解锁，没有看:joy:。</p><h2 id="练习：不同的二叉搜索树II"><a href="#练习：不同的二叉搜索树II" class="headerlink" title="练习：不同的二叉搜索树II"></a>练习：不同的二叉搜索树II</h2><p>Given an integer <em>n</em>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&apos;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><blockquote><p>等复习了二叉树再后续补充，，，</p></blockquote><h2 id="解答：不同的二叉搜索树II"><a href="#解答：不同的二叉搜索树II" class="headerlink" title="解答：不同的二叉搜索树II"></a>解答：不同的二叉搜索树II</h2><p>要花钱才能解锁，没有看:joy:。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要翻译自LeetCode上Explore模块的&lt;a href=&quot;https://leetcode.com/explore/learn/card/recursion-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Recursion I&lt;/a&gt;，有直译，也有非直译的个人理解。&lt;/p&gt;
&lt;p&gt;其中涉及的题目附有相应的解答。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Overview-综述&quot;&gt;&lt;a href=&quot;#Overview-综述&quot; class=&quot;headerlink&quot; title=&quot;Overview 综述&quot;&gt;&lt;/a&gt;Overview 综述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Recursion&lt;/code&gt;（递归）是计算机科学中一个重要的概念，是很多算法和数据结构的基础。但是对于很多初学者都比较难把握。&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="https://lesley0416.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>Python中list的一些小技巧</title>
    <link href="https://lesley0416.github.io/2019/03/20/python_list_tips/"/>
    <id>https://lesley0416.github.io/2019/03/20/python_list_tips/</id>
    <published>2019-03-20T03:38:50.000Z</published>
    <updated>2019-03-20T03:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="列表展开"><a href="#列表展开" class="headerlink" title="列表展开"></a>列表展开</h3><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment">################ case 1</span></span><br><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="keyword">print</span> list(itertools.chain.from_iterable(a))</span><br><span class="line">%timeit -n <span class="number">10000</span> list(itertools.chain.from_iterable(a))</span><br><span class="line"><span class="keyword">print</span> sum(a, [])</span><br><span class="line">%timeit -n <span class="number">10000</span> sum(a, [])</span><br><span class="line"><span class="keyword">print</span> [x <span class="keyword">for</span> l <span class="keyword">in</span> a <span class="keyword">for</span> x <span class="keyword">in</span> l]</span><br><span class="line">%timeit -n <span class="number">10000</span> [x <span class="keyword">for</span> l <span class="keyword">in</span> a <span class="keyword">for</span> x <span class="keyword">in</span> l]</span><br><span class="line"></span><br><span class="line"><span class="comment"># result:</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># 10000 loops, best of 3: 801 ns per loop</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># 10000 loops, best of 3: 359 ns per loop</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># 10000 loops, best of 3: 371 ns per loop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################ case 2</span></span><br><span class="line">b = [[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line">[x <span class="keyword">for</span> l1 <span class="keyword">in</span> b <span class="keyword">for</span> l2 <span class="keyword">in</span> l1 <span class="keyword">for</span> x <span class="keyword">in</span> l2]</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################ case 3</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line">flatten = <span class="keyword">lambda</span> x: [y <span class="keyword">for</span> l <span class="keyword">in</span> x <span class="keyword">for</span> y <span class="keyword">in</span> flatten(l)] <span class="keyword">if</span> type(x) <span class="keyword">is</span> list <span class="keyword">else</span> [x]</span><br><span class="line">flatten(a)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="相邻元素压缩-amp-依次相连"><a href="#相邻元素压缩-amp-依次相连" class="headerlink" title="相邻元素压缩&amp;依次相连"></a>相邻元素压缩&amp;依次相连</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">list(zip(*([iter(a)] * <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># [(1, 2), (3, 4), (5, 6)]</span></span><br><span class="line">list(zip(*([iter(a)] * <span class="number">3</span>)))</span><br><span class="line"><span class="comment"># [(1, 2, 3), (4, 5, 6)]</span></span><br><span class="line"></span><br><span class="line">temp = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>,<span class="string">'f'</span>]</span><br><span class="line">list(zip(temp[:<span class="number">-1</span>],temp[<span class="number">1</span>:]))</span><br><span class="line"><span class="comment"># [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')]</span></span><br><span class="line">list(zip(temp[:<span class="number">-2</span>],temp[<span class="number">1</span>:<span class="number">-1</span>],temp[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment"># [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;列表展开&quot;&gt;&lt;a href=&quot;#列表展开&quot; class=&quot;headerlink&quot; title=&quot;列表展开&quot;&gt;&lt;/a&gt;列表展开&lt;/h3&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lesley0416.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lesley0416.github.io/tags/Python/"/>
    
      <category term="list" scheme="https://lesley0416.github.io/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>Python中zip的一些内容</title>
    <link href="https://lesley0416.github.io/2019/03/19/python_zip/"/>
    <id>https://lesley0416.github.io/2019/03/19/python_zip/</id>
    <published>2019-03-19T06:45:50.000Z</published>
    <updated>2019-03-20T14:30:00.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、zip基本说明"><a href="#1、zip基本说明" class="headerlink" title="1、zip基本说明"></a>1、zip基本说明</h2><p><code>zip</code>函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，返回由这些元组组成的列表。在Python3.x中为了减少内存，返回的是一个对象，可以用<code>list()</code>转换来输出列表。</p><p>如果各个迭代器的元素个数不一样，则返回列表长度与最短的对象相同，利用<code>*</code>号操作符，可以将元组解压为列表。</p><a id="more"></a><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([iterable, ...])</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>iterable：一个或多个迭代器；</li></ul></li><li>返回值：<ul><li>返回一个对象；</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">zipped = zip(a,b) <span class="comment"># 返回一个对象</span></span><br><span class="line">zipped</span><br><span class="line"><span class="comment"># &lt;zip object at 0x103abc288&gt;</span></span><br><span class="line">list(zipped) <span class="comment"># list() 转换为列表</span></span><br><span class="line"><span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">list(zip(a,c)) <span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line"><span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"></span><br><span class="line">a1, a2 = zip(*zip(a,b)) <span class="comment"># 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式，*是Python函数可变参数的一种表示形式，加*的表示传入一个元组对象进行解包</span></span><br><span class="line">list(a1)</span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br><span class="line">list(a2)</span><br><span class="line"><span class="comment"># [4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="2、一些使用"><a href="#2、一些使用" class="headerlink" title="2、一些使用"></a>2、一些使用</h2><h3 id="相邻元素压缩器"><a href="#相邻元素压缩器" class="headerlink" title="相邻元素压缩器"></a>相邻元素压缩器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">list(zip(*([iter(a)] * <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># [(1, 2), (3, 4), (5, 6)]</span></span><br><span class="line">list(zip(*([iter(a)] * <span class="number">3</span>)))</span><br><span class="line"><span class="comment"># [(1, 2, 3), (4, 5, 6)]</span></span><br></pre></td></tr></table></figure><ul><li><p>首先理解迭代器，<code>iter()</code>可以将一个序列生成为一个迭代器，迭代器的特点是可以用<code>for in</code>语句迭代。原理是迭代器对象有一个<code>next</code>方法，可以每次移动迭代的指针，一旦迭代完，没有下一个元素的时候，会触发一个<code>StopIteration</code>异常。<strong>迭代器的特点是，迭代了一次以后，指针就移动了，不会自动回溯。</strong>例如，可以用<code>for in</code>迭代列表无数次，但只能迭代一次迭代器，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line"><span class="meta">... </span>    print(i) <span class="comment"># 因为x已经被迭代过了，迭代的指针不会回溯，所以没有值了</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>而在上述相邻元素压缩器的使用过程中，可以发现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[iter(a)] * <span class="number">3</span></span><br><span class="line"><span class="comment"># [&lt;listiterator at 0x7fa6c00ec1d0&gt;,</span></span><br><span class="line"><span class="comment"># &lt;listiterator at 0x7fa6c00ec1d0&gt;,</span></span><br><span class="line"><span class="comment"># &lt;listiterator at 0x7fa6c00ec1d0&gt;]</span></span><br></pre></td></tr></table></figure><p>三个迭代器实际上是同一个迭代器。</p></li><li><p>再来理解<code>zip</code>，如前文所述，<code>zip</code>将两个序列对应打包，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(a1, a2))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>而<code>*</code>则表示传入一个对象进行解包，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (a1, a2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(t)) <span class="comment"># 不加*号，zip 只有一个参数 t</span></span><br><span class="line">[([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>],), ([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>],)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*t)) <span class="comment"># 加*号的作用就是将元祖t，解包成a1,a2为zip的两个函数参数</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure></li><li><p>最后理解为什么使用迭代器，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = [a, a]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*t))                 <span class="comment"># case 1，不使用迭代器</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">5</span>), (<span class="number">6</span>, <span class="number">6</span>)]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tx = [x, x]                                   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*tx))                <span class="comment"># case 2，使用迭代器</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>在case 1中，<code>zip</code>传入的两个参数<code>a</code>，等于打包了两个列表，并在<code>zip(*)</code>中进行解包，等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>在case 2中，<code>x</code>是迭代器对象，迭代过程会调用<code>next</code>方法，迭代过一次后会自动移动且不会回溯。也就是说<code>zip</code>执行过程中先调用第一个参数<code>x</code>的<code>next</code>方法得到参数1，再调用第二个参数<code>x</code>的<code>next</code>方法，上文我们已知这两个迭代器其实是同一个迭代器对象，所以第二次调用<code>x</code>的<code>next</code>方法时，迭代器指针已经移动，所以得到参数2，整个过程类似如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x.next -&gt; 1</span><br><span class="line">x.next -&gt; 2</span><br><span class="line">zip(x.next(), x.next()) ---&gt; zip(1, 2)</span><br><span class="line">x.next -&gt; 3</span><br><span class="line">x.next -&gt; 4</span><br><span class="line">zip(x.next(), x.next()) ---&gt; zip(3, 4)</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure></li></ul><p>基于此，就可以理解使用<code>zip</code>做相邻元素压缩器的完整执行过程了。</p><h3 id="列表元素依次相连"><a href="#列表元素依次相连" class="headerlink" title="列表元素依次相连"></a>列表元素依次相连</h3><blockquote><p>注意与<code>相邻元素压缩器</code>的效果区别。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>,<span class="string">'f'</span>]</span><br><span class="line">print(temp)</span><br><span class="line"><span class="comment"># ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class="line">list(zip(temp[:<span class="number">-1</span>],temp[<span class="number">1</span>:]))</span><br><span class="line"><span class="comment"># [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')]</span></span><br></pre></td></tr></table></figure><p>这个用法比较好理解，<code>temp[:-1]</code>去除列表最后一个元素，<code>temp[1:]</code>去除列表第一个元素，则上述过程等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>], [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br></pre></td></tr></table></figure><p>基于该用法可衍生出多个元素依次相连的用法，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(zip(temp[:<span class="number">-2</span>],temp[<span class="number">1</span>:<span class="number">-1</span>],temp[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment"># [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')]</span></span><br></pre></td></tr></table></figure><p>也可以用这种方法实现列表相邻元素压缩器的效果，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">list(zip(a[::<span class="number">3</span>], a[<span class="number">1</span>::<span class="number">3</span>], a[<span class="number">2</span>::<span class="number">3</span>]))</span><br><span class="line"><span class="comment"># [(1, 2, 3), (4, 5, 6)]</span></span><br></pre></td></tr></table></figure><h3 id="取列表相同位置元素"><a href="#取列表相同位置元素" class="headerlink" title="取列表相同位置元素"></a>取列表相同位置元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="string">'flower'</span>,<span class="string">'flow'</span>,<span class="string">'flight'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip(*nums):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('f', 'f', 'f')</span></span><br><span class="line"><span class="comment"># ('l', 'l', 'l')</span></span><br><span class="line"><span class="comment"># ('o', 'o', 'i')</span></span><br><span class="line"><span class="comment"># ('w', 'w', 'g')</span></span><br></pre></td></tr></table></figure><h3 id="反转字典"><a href="#反转字典" class="headerlink" title="反转字典"></a>反转字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>&#125;</span><br><span class="line">dict(zip(m.values(), m.keys()))</span><br><span class="line"><span class="comment"># &#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、zip基本说明&quot;&gt;&lt;a href=&quot;#1、zip基本说明&quot; class=&quot;headerlink&quot; title=&quot;1、zip基本说明&quot;&gt;&lt;/a&gt;1、zip基本说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;zip&lt;/code&gt;函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，返回由这些元组组成的列表。在Python3.x中为了减少内存，返回的是一个对象，可以用&lt;code&gt;list()&lt;/code&gt;转换来输出列表。&lt;/p&gt;
&lt;p&gt;如果各个迭代器的元素个数不一样，则返回列表长度与最短的对象相同，利用&lt;code&gt;*&lt;/code&gt;号操作符，可以将元组解压为列表。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lesley0416.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lesley0416.github.io/tags/Python/"/>
    
      <category term="zip" scheme="https://lesley0416.github.io/tags/zip/"/>
    
      <category term="Python3" scheme="https://lesley0416.github.io/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】5、最长回文子串</title>
    <link href="https://lesley0416.github.io/2019/03/19/leetcode_5/"/>
    <id>https://lesley0416.github.io/2019/03/19/leetcode_5/</id>
    <published>2019-03-19T03:23:50.000Z</published>
    <updated>2019-03-20T14:06:09.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>5、<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Longest Palindromic Substring</a>最长回文子串</p><p>难度：中等</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p></li><li><p>中文：</p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>动态规划方法，维护一个二维数组$tags$，其中$tags[i][j]$表示字符串区间$[i,j]$是否为回文串，当$i=j$时，字符串只有一个字符，肯定是回文串，当$j=i+1$时，字符串为相邻的两个字符，需要判断$s[i]$是否等于$s[j]$，如果$i$和$j$不相邻，即$j-i\ge2$时，除了判断$s[i]$和$s[j]$是否相等，还要判断$tags[i+1][j-1]$是否为真，则有如下递推式：</p><script type="math/tex; mode=display">tags[i][j]=    \begin{cases}        1, & \text{if $i==j$}\\        s[i]==s[j],&\text{if $j=i+1$}\\        s[i]==s[j]\ \&\&\ tags[i+1][j-1],& \text{if $j>i+1$}    \end{cases}</script><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时6708ms，内存21.9M</p><p>时间复杂度：$O(n^2)$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        length = len(s)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化二维数组 tags</span></span><br><span class="line">        <span class="comment"># 不可以用 tags = [[False]*length]*length 的方式，深浅拷贝</span></span><br><span class="line">        tags = [[<span class="literal">False</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(length)] <span class="keyword">for</span> row <span class="keyword">in</span> range(length)]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        templen = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="comment"># if i==j</span></span><br><span class="line">            tags[j][j] = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># j &gt; i</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j):</span><br><span class="line">                tags[i][j] = (s[i] == s[j] <span class="keyword">and</span> (j-i &lt; <span class="number">2</span> <span class="keyword">or</span> tags[i+<span class="number">1</span>][j<span class="number">-1</span>]))</span><br><span class="line">                <span class="comment"># 更新当前记录的最长回文子串信息</span></span><br><span class="line">                <span class="keyword">if</span> tags[i][j] <span class="keyword">and</span> templen &lt; j-i+<span class="number">1</span>:</span><br><span class="line">                    left = i</span><br><span class="line">                    right = j</span><br><span class="line">                    templen = j-i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[left:right+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p><a href="https://blog.csdn.net/chenhua1125/article/details/80395873" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>弱鸡的讲说，这个思路是一致的，但是代码没太看明白。。。</p></blockquote><p>根据回文的特性，一个大回文按比例缩小后的字符串也必定是回文，比如ABCCBA，那BCCB肯定也是回文。所以我们可以根据动态规划的两个特点：<br>（1）把大问题拆解为小问题<br>（2）重复利用之前的计算结果<br>这道题。如何划分小问题，我们可以先把所有长度最短为1的子字符串计算出来，根据起始位置从左向右，这些必定是回文。然后计算所有长度为2的子字符串，再根据起始位置从左向右。到长度为3的时候，我们就可以利用上次的计算结果：如果中心对称的短字符串不是回文，那长字符串也不是，如果短字符串是回文，那就要看长字符串两头是否一样。这样，一直到长度最大的子字符串，我们就把整个字符串集穷举完了。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时160ms，内存13M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># 使用动态规划，用空间换时间，把问题拆分</span></span><br><span class="line">        <span class="comment"># 获取字符串s的长度</span></span><br><span class="line">        str_length = len(s)</span><br><span class="line">        <span class="comment"># 记录最大字符串长度</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 记录位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 循环遍历字符串的每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(str_length):</span><br><span class="line">            <span class="comment"># 如果当前循环次数-当前最大长度大于等于1  并  字符串[当前循环次数-当前最大长度-1:当前循环次数+1]  == 取反后字符串</span></span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">1</span> <span class="keyword">and</span> s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>] == s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># 记录当前开始位置</span></span><br><span class="line">                start = i - max_length - <span class="number">1</span></span><br><span class="line">                <span class="comment"># 取字符串最小长度为2，所以+=2，s[i-max_length-1: i+1]</span></span><br><span class="line">                max_length += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果当前循环次数-当前最大长度大于等于0  并  字符串[当前循环次数-当前最大长度:当前循环次数+1]  == 取反后字符串</span></span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i-max_length: i+<span class="number">1</span>] == s[i-max_length: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                start = i - max_length</span><br><span class="line">                <span class="comment"># 取字符串最小长度为1，所以+=1，s[i-max_length: i+1]</span></span><br><span class="line">                max_length += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回最长回文子串</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_length]</span><br></pre></td></tr></table></figure><h3 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h3><p>解决最长回文子串的一个时间复杂度为$O (n)$的算法——Manacher算法。</p><p>还没有仔细看，应该是针对该问题的一个比较巧妙的算法。</p><p>可参考：<a href="https://segmentfault.com/a/1190000003914228" target="_blank" rel="noopener">最长回文子串——Manacher 算法</a>，<a href="https://segmentfault.com/a/1190000016239464" target="_blank" rel="noopener">LeetCode]最长回文子串（Longest Palindromic Substring）</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;5、&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Longest Palindromic Substring&lt;/a&gt;最长回文子串&lt;/p&gt;
&lt;p&gt;难度：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://lesley0416.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="字符串" scheme="https://lesley0416.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】213、打家劫舍II</title>
    <link href="https://lesley0416.github.io/2019/03/15/leetcode_213/"/>
    <id>https://lesley0416.github.io/2019/03/15/leetcode_213/</id>
    <published>2019-03-15T05:16:50.000Z</published>
    <updated>2019-03-20T14:06:13.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>213、<a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">House Robber II</a>打家劫舍II</p><p>难度：中等</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p></li><li><p>中文：</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈，</strong>这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),</span><br><span class="line">             because they are adjacent houses.</span><br><span class="line"></span><br><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>相比“打家劫舍I”多了首尾不能相连的限制，可以通过对<code>1~n-1</code>和<code>2~n</code>两个序列分别按“打家劫舍I”的思路计算一遍，最后取最大值返回即可。</p><p>顺序遍历整个数组，当遍历到第<code>i</code>个值时，有两种情况：</p><ol><li><p>之前遍历过程中的<code>curSum</code>始终大于0，假设当前子序列为<code>a,a+1,a+2,...,b-2,b-1,b</code>，此时考虑所有可能：</p><ul><li>以当前子序列开头为开头，以中间任一处结尾的序列，如<code>a,a+1,a+2,...b-2</code>：这种情况一致在遍历过程中保存更新；</li><li>以当前子序列结尾为结尾，以中间任一处开头的序列，如<code>a+2,...,b-2,b-1,b</code>：这种情况一定小于当前的完整子序列的和，因为前面缺失的部分的和一定是大于0的（讨论的前提就是遍历过程加和始终大于0）；</li><li>以中间元素为开头和结尾的序列，如<code>a+2,...,b-2</code>：这种情况，首先按照前一条讨论，补全前面缺失的部分，之后就变成了第一条讨论的情况；</li></ul><p>也就是说，<code>i</code>前面的所有可能序列情况都已经考虑到了；</p></li><li><p><code>curSum</code>出现小于0的情况，此时由于已遍历过的连续子序列加和<code>&lt;0</code>，则遍历过的这个连续子序列不能完整的被包含到新形成的序列中了；而是否要全部放弃，还是保留末尾的部分元素？参考之前的讨论，以当前子序列结尾为结尾，以中间任一处开头的序列的加和是小于完整子序列的，也就是说是<code>&lt;0</code>的，因为此时遍历过的连续子序列需要全部放弃，即<code>curSum</code>置0，并重新开始累加。</p></li></ol><p>其中，每次<code>curSum&lt;0</code>时的下一位置即为和最大的子序列的开始，每次<code>curSum&gt;maxSum</code>时的位置即为和最大的子序列的结尾。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时56ms，内存13.2M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob1</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        temp = [nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            temp.extend([max(temp[i<span class="number">-1</span>], temp[i<span class="number">-2</span>]+nums[i])])</span><br><span class="line">        <span class="keyword">return</span> temp[<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> max(self.rob1(nums[<span class="number">1</span>:]), self.rob1(nums[:<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;213、&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;House Robber II&lt;/a&gt;打家劫舍II&lt;/p&gt;
&lt;p&gt;难度：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://lesley0416.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】198、打家劫舍</title>
    <link href="https://lesley0416.github.io/2019/03/15/leetcode_198/"/>
    <id>https://lesley0416.github.io/2019/03/15/leetcode_198/</id>
    <published>2019-03-15T04:46:50.000Z</published>
    <updated>2019-03-20T14:06:00.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>198、<a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">House Robber</a>打家劫舍</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p></li><li><p>中文：</p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).</span><br><span class="line">             Total amount you can rob = 2 + 9 + 1 = 12.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>动态规划，根据题意，不能窃取相邻的房屋，那么第$n$天的最高金额，要么等于第$n-1$天的最高金额，要么等于$n-2$天的最高金额加上第$n$天可获得的金额。</p><p>用$f (n)$表示第$n$天的最高金额，$p_n$表示第$n$天可获得的金额，则$f (n) = \max (f(n-1) , f(n-2)+p_n)$，其中，$f(1) = p_1 , f(2)=\max (p_1, p_2)​$。</p><p><strong>Ps.</strong> 开始简单的以为，就是奇数位求和，偶数位求和，然后取最大值，后来发现不对，只要求有间隔，但间隔不一定为1，如测试用例<code>[2,1,1,2]</code>，则间隔为2，取首尾两个元素时为最大值。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时64ms，内存13.1M</p><p>时间复杂度：$O (n) ​$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        temp = [nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            temp.append(max(temp[i<span class="number">-1</span>], temp[i<span class="number">-2</span>]+nums[i]))</span><br><span class="line">        <span class="keyword">return</span> temp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>在Python中，list添加元素的方法，<code>expend</code>效率要高于<code>append</code>，调整后，用时52ms，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        temp = [nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            temp.extend([max(temp[i<span class="number">-1</span>], temp[i<span class="number">-2</span>]+nums[i])])</span><br><span class="line">        <span class="keyword">return</span> temp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;198、&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;House Robber&lt;/a&gt;打家劫舍&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://lesley0416.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】121、买卖股票的最佳时机</title>
    <link href="https://lesley0416.github.io/2019/03/14/leetcode_121/"/>
    <id>https://lesley0416.github.io/2019/03/14/leetcode_121/</id>
    <published>2019-03-14T07:11:00.000Z</published>
    <updated>2019-03-20T14:07:28.187Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>121、<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a>买卖股票的最佳时机</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Note that you cannot sell a stock before you buy one.</p></li><li><p>中文：</p><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">             Not 7-1 = 6, as selling price needs to be larger than buying price.</span><br><span class="line">             </span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>动态规划问题，第$i$天的最高利润，要么等于前$i-1$天的最高利润，要么等于第$i$天的卖出价减去前$i-1$天的最低买入价。</p><p>用$f (i)$表示第$i$天的最高利润，$p_i$表示第$i$天的价格，则$f (i) = \max ( f(i-1) , p_i - \min (p_1,p_2,…,p_{i-1}) )$。</p><p>要注意卖出价高于买入价的限制。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时6040ms，内存14.2M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        length = len(prices)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        temp = [prices[<span class="number">1</span>]-prices[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            temp.append(max(temp[i<span class="number">-1</span>], prices[i]-min(prices[:i]), <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>每次都会判断前$i-1$天的最低价，可以将最低价进行保存。</p><blockquote><p>Python3，用时104ms，内存14M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        length = len(prices)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        temp = [prices[<span class="number">1</span>]-prices[<span class="number">0</span>]]</span><br><span class="line">        tempMin = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; tempMin:</span><br><span class="line">                tempMin = prices[i]</span><br><span class="line">            temp.append(max(temp[i<span class="number">-1</span>], prices[i]-tempMin))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>遍历数组，寻找最低价之后的最高收益。</p><p>判断第$i$天的价格，是否是当前最低价，不是最低价则判断是否可获得当前最大收益（获得当前最大收益的节点不一定是当前最高价的节点，当前最高价可能出现在最低价之前，所以无法更新最低价的时候，判断收益而不是试图更新最高价）。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时80ms，内存13.8M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        length = len(prices)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        tempMin = sys.maxsize</span><br><span class="line">        tempMax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> i &lt; tempMin:</span><br><span class="line">                tempMin = i</span><br><span class="line">            <span class="keyword">elif</span> i-tempMin &gt; tempMax:</span><br><span class="line">                tempMax = i-tempMin</span><br><span class="line">        <span class="keyword">return</span> tempMax</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;121、&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Best Time to Buy and Sell Stock&lt;/a&gt;买卖股票的最佳时机&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划" scheme="https://lesley0416.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】70、爬楼梯</title>
    <link href="https://lesley0416.github.io/2019/03/14/leetcode_70/"/>
    <id>https://lesley0416.github.io/2019/03/14/leetcode_70/</id>
    <published>2019-03-14T03:27:00.000Z</published>
    <updated>2019-03-20T14:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>70、<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs</a>爬楼梯</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p></li><li><p>中文：</p><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>动态规划问题，直接<strong>递归</strong>，用$f (n)$表示到达第$n$阶时的方法数，共有两种爬楼方式（一次一阶，一次两阶），那么到达第$n$阶可以通过“到达第$n-1$阶后再走一次一阶”和“到达第$n-2$阶后再走一次两阶”两种方式，那么只需要考虑到达$n-1$阶和$n-2$阶各有多少种方法即可，即$f(n) = f(n-1) + f(n-2)$，终止条件为$f(1) = 1 , f(2)=2$。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，超时</p><p>时间复杂度：<strong>T(n) = O(1.618 ^ n)</strong>（1.618就是黄金分割，(1+5–√)/2(1+5)/2）。</p><p>空间复杂度取决于递归的深度，显然是<strong>O(n)</strong>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>) + self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>直接递归的方法重复计算太多，直接超时，将计算过的结果进行缓存，使用<strong>递归</strong>的方式，如下：</p><blockquote><p>Python3，用时80ms，内存13.2M</p><p>时间复杂度是<strong>O(n)</strong></p><p>空间复杂度是<strong>O(1)</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        tempNum = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            tempNum.append(tempNum[i<span class="number">-1</span>] + tempNum[i<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> tempNum[n]</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>递归表达式及终止条件值符合斐波那契数列。其实跟上面的方法差不多。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时52ms，内存13.1M</p><p>时间复杂性：$O (n)​$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            a, b = a + b, a</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;70、&lt;a href=&quot;https://leetcode-cn.com/problems/climbing-stairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Climbing Stairs&lt;/a&gt;爬楼梯&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="https://lesley0416.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="斐波那契数列" scheme="https://lesley0416.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】53、最大子序和</title>
    <link href="https://lesley0416.github.io/2019/03/13/leetcode_53/"/>
    <id>https://lesley0416.github.io/2019/03/13/leetcode_53/</id>
    <published>2019-03-13T13:30:50.000Z</published>
    <updated>2019-03-20T14:05:10.355Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>53、<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">Maximum Subarray</a>最大子序和</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p></li><li><p>中文：</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure></li><li><p>进阶</p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>遍历数组，用<code>curSum</code>维护当前位置累加的和，当<code>curSum&lt;0</code>时，将其置为0，重新开始累加，每次都更新全局最大值。</p><p>顺序遍历整个数组，当遍历到第<code>i</code>个值时，有两种情况：</p><ol><li><p>之前遍历过程中的<code>curSum</code>始终大于0，假设当前子序列为<code>a,a+1,a+2,...,b-2,b-1,b</code>，此时考虑所有可能：</p><ul><li>以当前子序列开头为开头，以中间任一处结尾的序列，如<code>a,a+1,a+2,...b-2</code>：这种情况一致在遍历过程中保存更新；</li><li>以当前子序列结尾为结尾，以中间任一处开头的序列，如<code>a+2,...,b-2,b-1,b</code>：这种情况一定小于当前的完整子序列的和，因为前面缺失的部分的和一定是大于0的（讨论的前提就是遍历过程加和始终大于0）；</li><li>以中间元素为开头和结尾的序列，如<code>a+2,...,b-2</code>：这种情况，首先按照前一条讨论，补全前面缺失的部分，之后就变成了第一条讨论的情况；</li></ul><p>也就是说，<code>i</code>前面的所有可能序列情况都已经考虑到了；</p></li><li><p><code>curSum</code>出现小于0的情况，此时由于已遍历过的连续子序列加和<code>&lt;0</code>，则遍历过的这个连续子序列不能完整的被包含到新形成的序列中了；而是否要全部放弃，还是保留末尾的部分元素？参考之前的讨论，以当前子序列结尾为结尾，以中间任一处开头的序列的加和是小于完整子序列的，也就是说是<code>&lt;0</code>的，因为此时遍历过的连续子序列需要全部放弃，即<code>curSum</code>置0，并重新开始累加。</p></li></ol><p>其中，每次<code>curSum&lt;0</code>时的下一位置即为和最大的子序列的开始，每次<code>curSum&gt;maxSum</code>时的位置即为和最大的子序列的结尾。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时96ms，内存13.6M</p><p>时间复杂度：$O (n) $</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        curSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            curSum += nums[i]</span><br><span class="line">            maxSum = max(maxSum, curSum)</span><br><span class="line">            <span class="keyword">if</span> curSum &lt; <span class="number">0</span>:</span><br><span class="line">                curSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>动态规划，用<code>tempSum</code>保存以第<code>i</code>个元素结尾的最大连续子序列的和，假设对于元素<code>i</code>，其前面的所有元素结尾的序列和都已经得到，则以第<code>i</code>个元素结尾的子序列的和要么是以第<code>i-1</code>个元素结尾的和最大的子序列加上当前元素，要么就是当前元素本身，即<code>tempSum[i] = max(tempSum[i-1]+nums[i], nums[i])</code>。（实际等价于看以<code>i-1</code>个元素结尾的和最大的子序列的和是否小于0，等价于思路一了）当<code>i=0</code>时，最大子序列和即为<code>tempSum[0] = nums[0]</code>。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时104ms，内存14.2M</p><p>时间复杂度：$O (n) ​$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        tempSum = []</span><br><span class="line">        tempSum.append(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            tempSum.append(max(tempSum[i<span class="number">-1</span>]+nums[i], nums[i]))</span><br><span class="line">        <span class="keyword">return</span> max(tempSum)</span><br></pre></td></tr></table></figure><p>可以直接用<code>nums</code>来保存子序列最大和，能节约一点内存，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            nums[i] = max(nums[i<span class="number">-1</span>]+nums[i], nums[i])</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br></pre></td></tr></table></figure><h3 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h3><p>提示说可以尝试用分治法，那么就将整个数组不断切分成子数组，最后选最大值返回。</p><p>用二分法切分数组，最大子序和要么在左半部分，要么在右半部分，要么横跨左右两部分（既包含左侧的最后一个元素，也包含右侧的第一个元素），返回这三种情况的最大值即可。</p><p>横跨左右两部分的情况，可以从中间位置逐次向左右两侧遍历，并更新最大值。</p><h4 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python3，用时272ms，内存13.7M</p><p>时间复杂度：$O(n\log n)$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        maxSum = self.divide(nums, left, right)</span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        <span class="comment"># 切分到只有一个元素时，返回</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确立中心点</span></span><br><span class="line">        center = (left + right)//<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 子序列完全在左侧的最大和</span></span><br><span class="line">        leftMax = self.divide(nums, left, center)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 子序列完全在右侧的最大和</span></span><br><span class="line">        rightMax = self.divide(nums, center+<span class="number">1</span>, right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 子序列横跨左右两侧的最大和</span></span><br><span class="line">        <span class="comment"># 从中间点逐次向左边界靠近</span></span><br><span class="line">        leftSum = <span class="number">0</span></span><br><span class="line">        leftBorderSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(center<span class="number">-1</span>, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            leftSum += nums[i]</span><br><span class="line">            leftBorderSum = max(leftSum, leftBorderSum)</span><br><span class="line">        <span class="comment"># 从中间点逐次向右边界靠近</span></span><br><span class="line">        rightSum = <span class="number">0</span></span><br><span class="line">        rightBorderSum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(center+<span class="number">1</span>, right+<span class="number">1</span>):</span><br><span class="line">            rightSum += nums[i]</span><br><span class="line">            rightBorderSum = max(rightSum, rightBorderSum)</span><br><span class="line">        centerMax = leftBorderSum + nums[center] + rightBorderSum</span><br><span class="line">        <span class="keyword">return</span> max(leftMax, centerMax, rightMax)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;53、&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maximum Subarray&lt;/a&gt;最大子序和&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="动态规划" scheme="https://lesley0416.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="分治算法" scheme="https://lesley0416.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
