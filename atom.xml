<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lesley&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lesley0416.github.io/"/>
  <updated>2019-05-30T09:34:58.000Z</updated>
  <id>https://lesley0416.github.io/</id>
  
  <author>
    <name>Lesley Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拼音输入法实现&amp;文本服务框架TSF相关知识点记录</title>
    <link href="https://lesley0416.github.io/2019/05/29/TSF/"/>
    <id>https://lesley0416.github.io/2019/05/29/TSF/</id>
    <published>2019-05-29T06:48:50.000Z</published>
    <updated>2019-05-30T09:34:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近一直在做一个拼音输入法的项目，需要使用微软的文本服务框架（Text Service Framework，简称TSF），第一次使用TSF，记录其中的一些知识点。</p></blockquote><a id="more"></a><h1 id="TSF技术"><a href="#TSF技术" class="headerlink" title="TSF技术"></a>TSF技术</h1><h2 id="TSF工作原理"><a href="#TSF工作原理" class="headerlink" title="TSF工作原理"></a>TSF工作原理</h2><p>TSF是一个与输入设备无关、与输入语言无关的可扩展系统，可以向文本输入和语言处理提供相关服务。TSF以一组COM接口的方式向应用程序和文本服务公开其框架。</p><p>TSF基本体系结构如下图（图源网络）所示：</p><p><img src="/2019/05/29/TSF/tsf.jpg" style="zoom:80%"></p><p>一般应用程序会包括显示、直接编辑、文本存储几个主要功能，通过实现一个COM服务来提供文本访问能力。</p><p>文本服务的功能是向应用程序提供文本，文本服务也是以COM来实现的，系统中允许同时注册多个文本服务。（像通常见到的拼音输入、语音输入、手写输入，就是几种不同的文本服务）</p><p>TSF管理器的功能由操作系统实现，不能被任何形式的应用程序代替。允许一个应用程序和一个或多个文本服务共享文本内容。</p><h2 id="TSF主要概念"><a href="#TSF主要概念" class="headerlink" title="TSF主要概念"></a>TSF主要概念</h2><blockquote><p>概念主要参考网上的一些资料，感觉有些不是很确切的明白，，，</p></blockquote><ul><li><p>文本存储</p><p>文本存储是由应用程序提供来源，通过TSF管理器实现的一种在应用程序和文本服务之间共享文本流的机制，将文档看作是包含Unicode字符和控制代码的文本流，使用字符的应用程序字符位置（ACP）来定位和操作文本流。</p></li><li><p>片段</p><p>应该就是指<strong>ITfRange</strong>，所有文本都存储在被称为<code>片段</code>的对象中，片段是描述文本流中的某一小段文本的对象，不与文本流上的字符位置相关联，与特定的文本段相关联。所以这段文本在文本流中位置变化时也不用重新定义片段，也就是说，片段是可游移的。</p><p>range由两个锚点来界定，一个<code>start anchors</code>，一个<code>end anchors</code>。</p></li><li><p>属性</p><p><strong>ITfProperty</strong>，属性用来关联文本片段和元数据。</p><p>获取特定属性时，使用<strong>ITfContext::GetProperty</strong>方法，调用该方法时，必须指定一个特定的属性类型。</p></li><li><p>公共缓冲池</p><p>客户端程序之间通过公共缓冲池来实现数据共享，为数据共享提供一个数据存储和消息处理的机制。缓冲池通过GUID标识，客户端通过发布GUID来实现公共缓冲池的共享，只有注册为TSF客户端的程序才能修改公共缓冲池的数据。</p></li><li><p>文档锁</p><p>文档锁的作用是允许TSF管理器对文本内容进行互斥访问。</p></li></ul><h2 id="TSF主要接口"><a href="#TSF主要接口" class="headerlink" title="TSF主要接口"></a>TSF主要接口</h2><ul><li><p>线程管理器（<strong>ITfThreadMgr</strong>）</p><p>完成有关应用程序和文本服务（客户端）之间进行联系的公共任务，包括激活或挂起TSF文本服务、文档管理器的创建、维护文档和输入焦点之间的正确关联等各种任务。</p></li><li><p>客户端标识符（<strong>ITfClientId</strong>）</p><p>应用程序和文本服务被定义为客户端，需要维护一个客户端标识符。</p></li><li><p>编辑内容（<strong>ITfContext</strong>）</p><p>基本的文本输入模型，可以理解为一个通过ITfContext接口创建的连续的文本流。</p></li><li><p>文档管理器（<strong>ITfDocumentMgr</strong>）</p><p>通过ITfDocumentMgr接口创建并用来管理编辑内容的。</p></li><li><p>输入组合（<strong>ITfComposition</strong>）</p><p>输入组合是一个临时输入状态，应用程序需要获取ITfComposition的显示属性信息，通过判断输入组合是否存在，来将其状态显示给用户。</p></li><li><p>编辑会话（<strong>ITfEditSession</strong>）</p><p>编辑会话由文本服务实现，并由TSF管理器调用来读取或修改文本和属性的上下文。</p></li></ul><h1 id="其他一些点"><a href="#其他一些点" class="headerlink" title="其他一些点"></a>其他一些点</h1><ul><li>获取某个文本片段所有者的CLSID（类标识符）时，应该先用<strong>ITfContext::GetProperty</strong>方法获取属性对象，然后用<strong>ITfProperty::FindRange</strong>方法得到覆盖该属性的文本片段，最后用<strong>ITfReadOnlyProperty::GetValue</strong>方法得到一个<strong>TfGuidAtom</strong>类型数据，表示拥有这个片段的文本服务的CLSID。</li><li>通过<a href="http://msdn.microsoft.com/library/en-us/tsf/tsf/itfcontext_enumproperties.asp" target="_blank" rel="noopener">ITfContext::EnumProperties</a>方法返回的<a href="http://msdn.microsoft.com/library/en-us/tsf/tsf/ienumtfproperties.asp" target="_blank" rel="noopener">IEnumTfProperties</a>接口，可以列举出所有的属性对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近一直在做一个拼音输入法的项目，需要使用微软的文本服务框架（Text Service Framework，简称TSF），第一次使用TSF，记录其中的一些知识点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他" scheme="https://lesley0416.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="TSF" scheme="https://lesley0416.github.io/tags/TSF/"/>
    
      <category term="文本服务框架" scheme="https://lesley0416.github.io/tags/%E6%96%87%E6%9C%AC%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"/>
    
      <category term="输入法" scheme="https://lesley0416.github.io/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>cs224n-2017笔记：第一讲 Introduction to NLP and Deep Learning</title>
    <link href="https://lesley0416.github.io/2019/05/29/cs224n_2017_1/"/>
    <id>https://lesley0416.github.io/2019/05/29/cs224n_2017_1/</id>
    <published>2019-05-29T01:30:50.000Z</published>
    <updated>2019-05-30T15:18:00.807Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>斯坦福cs224n-2017 winter笔记</p><p><a href="https://web.stanford.edu/class/archive/cs/cs224n/cs224n.1174/syllabus.html" target="_blank" rel="noopener">课程链接</a></p><p>难度：简单</p></blockquote><a id="more"></a><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p><img src="/2019/05/29/cs224n_2017_1/plan.jpg"></p><h1 id="什么是NLP"><a href="#什么是NLP" class="headerlink" title="什么是NLP"></a>什么是NLP</h1><p>自然语言处理（NLP）是一门计算机科学、人工智能和语言学的交叉学科。</p><p>NLP的目的是处理或者“理解”自然语言，从而完成一些有意义的任务，如订票、购物、QA等等。</p><p>完全理解和表达语言的意思是非常困难的，perfect language understanding is AI-complete。</p><h2 id="NLP涉及的层次"><a href="#NLP涉及的层次" class="headerlink" title="NLP涉及的层次"></a>NLP涉及的层次</h2><p><img src="/2019/05/29/cs224n_2017_1/levels.jpg"></p><p>输入主要有两个来源：语音和文本。所以第一级是语音识别和OCR或分词，接下来是形态学，再下面是句法分析和语义分析，最后是discourse processing，需要根据上文语境理解下文。</p><p>这门课主要集中在画圈的三个部分，中间的两个最为重要。</p><h2 id="NLP应用"><a href="#NLP应用" class="headerlink" title="NLP应用"></a>NLP应用</h2><p>一个小子集：拼写检查、关键词检索、文本挖掘、文本分类、机器翻译、复杂对话系统等。</p><p>在工业界的应用，包括搜索、广告投放、自动/辅助翻译、情感/舆情分析、语音识别、聊天机器人等等。</p><h2 id="人类语言的特殊之处"><a href="#人类语言的特殊之处" class="headerlink" title="人类语言的特殊之处"></a>人类语言的特殊之处</h2><p>人类语言是离散的、明确的符号系统，但又允许出现各种变种（如颜文字、随意的拼写错误等）。</p><p>语言符号有多种形式，但不同的形式中意义保持不变。</p><p>虽然人类语言是明确的符号系统，但是大脑编码似乎是连续的激活值上的模式，符号传输到大脑的过程是通过连续的声光信号。另外，巨大的词表会导致数据稀疏（sparsity），不利于机器学习，所以我们希望去探索一种连续编码的模式。</p><h1 id="什么是DL"><a href="#什么是DL" class="headerlink" title="什么是DL"></a>什么是DL</h1><p>深度学习（DL）是机器学习的一个子集。</p><p>传统的机器学习方法，大多是人类对专业问题理解很透彻，然后人工设计输入特征，比如地名和机构名识别的特征模板（Finkel et al., 2010）。之后将特征交给某个机器学习算法，比如线性分类器等，算法为这些特征找到合适的权重，将误差优化到最小。</p><p><img src="/2019/05/29/cs224n_2017_1/ml.jpg"></p><p>在这个过程中，是人类一直在学习，而机器只是进行了数值优化的工作。</p><p>而<strong>深度学习是表示学习的一部分，试图自动的学习原始输入的多层特征表示。</strong></p><h2 id="DL的历史"><a href="#DL的历史" class="headerlink" title="DL的历史"></a>DL的历史</h2><p><img src="/2019/05/29/cs224n_2017_1/history.jpg"></p><h2 id="为啥研究DL"><a href="#为啥研究DL" class="headerlink" title="为啥研究DL"></a>为啥研究DL</h2><h2 id="语音识别中的DL"><a href="#语音识别中的DL" class="headerlink" title="语音识别中的DL"></a>语音识别中的DL</h2><p>突破性研究参考 <a href="https://s3.amazonaws.com/academia.edu.documents/34691735/dbn4lvcsr-transaslp.pdf?AWSAccessKeyId=AKIAIWOWYYGZ2Y53UL3A&amp;Expires=1559198118&amp;Signature=8zpJsrWYA5L5Dtp8zFN2DQAXnB0%3D&amp;response-content-disposition=inline%3B%20filename%3DContext-Dependent_Pre-Trained_Deep_Neura.pdf" target="_blank" rel="noopener">Context-Dependent Pre-Trained Deep Neural Networks for Large-Vocabulary Speech Recognition</a></p><h2 id="计算机视觉中的DL"><a href="#计算机视觉中的DL" class="headerlink" title="计算机视觉中的DL"></a>计算机视觉中的DL</h2><p>突破性研究参考 <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">ImageNet Classification with Deep Convolutional Neural Networks</a></p><h1 id="为什么NLP很难"><a href="#为什么NLP很难" class="headerlink" title="为什么NLP很难"></a>为什么NLP很难</h1><p>人类语言充满歧义，人类语言的解读依赖于现实世界、常识以及上下文等。</p><h1 id="Deep-NLP-Deep-Learning-NLP"><a href="#Deep-NLP-Deep-Learning-NLP" class="headerlink" title="Deep NLP = Deep Learning + NLP"></a>Deep NLP = Deep Learning + NLP</h1><p>用深度学习的方法解决NLP问题，提高了很多方面的效果：</p><ul><li>层次：语音、词汇、语法、语义</li><li>工具：词性标注、命名实体识别、句法分析</li><li>应用：机器翻译、情感分析、对话系统、问答系统</li></ul><h2 id="NLP表示层级：形态级别"><a href="#NLP表示层级：形态级别" class="headerlink" title="NLP表示层级：形态级别"></a>NLP表示层级：形态级别</h2><p>传统方法在形态级别的表示是词素：</p><p><img src="/2019/05/29/cs224n_2017_1/morphemes_ml.jpg"></p><p>深度学习中把词素用向量表示，多个词素向量构成相同维度、语义更丰富的词向量：</p><p><img src="/2019/05/29/cs224n_2017_1/morphemes_dl.jpg" style="zoom:60%"></p><h2 id="NLP工具：句法分析"><a href="#NLP工具：句法分析" class="headerlink" title="NLP工具：句法分析"></a>NLP工具：句法分析</h2><p><img src="/2019/05/29/cs224n_2017_1/parsing.jpg"></p><p>神经网络能够准确的进行句法分析，判断句子结构，参考 <a href="https://www.aclweb.org/anthology/D14-1082" target="_blank" rel="noopener">A Fast and Accurate Dependency Parser using Neural Networks</a> </p><h2 id="NLP表示层级：语义级别"><a href="#NLP表示层级：语义级别" class="headerlink" title="NLP表示层级：语义级别"></a>NLP表示层级：语义级别</h2><p>传统方法是手写的大量规则函数，称为<code>Lambda calculus</code>，没有语言的相似性或模糊性的概念：</p><p><img src="/2019/05/29/cs224n_2017_1/lambda_calculus.jpg" style="zoom:50%"></p><p>深度学习中，每个词、短语和逻辑表达都是向量，神经网络进行向量合并：</p><p><img src="/2019/05/29/cs224n_2017_1/semantics_dl.jpg" style="zoom:60%"></p><h2 id="NLP应用：情感分析"><a href="#NLP应用：情感分析" class="headerlink" title="NLP应用：情感分析"></a>NLP应用：情感分析</h2><p>传统方法是通过大量的人工搜集情感极性词典，在词袋模型上做分类器。</p><p>深度学习使用RNN解决这个问题（同样可用于形态学、语法、逻辑语义问题）：</p><p><img src="/2019/05/29/cs224n_2017_1/sentiment_analysis.jpg"></p><p>上图并不是RNN的工作流程，仅是为了方便理解。</p><h2 id="NLP应用：QA系统"><a href="#NLP应用：QA系统" class="headerlink" title="NLP应用：QA系统"></a>NLP应用：QA系统</h2><p>传统方法是通过总结大量的特征工程，编写大量逻辑规则，如正则表达式之类：</p><p><img src="/2019/05/29/cs224n_2017_1/qa_ml.jpg"></p><p>深度学习方法仍然采用和前面提到的类似的深度学习框架，将事实存储在向量中：</p><p><img src="/2019/05/29/cs224n_2017_1/qa_dl.jpg"></p><h2 id="NLP应用：对话系统"><a href="#NLP应用：对话系统" class="headerlink" title="NLP应用：对话系统"></a>NLP应用：对话系统</h2><p>一个成功的案例是Gmail的自动回复系统。</p><p>这是神经语言模型（Neural Language Models）的一次成功应用，神经语言模型是基于RNN的：</p><p><img src="/2019/05/29/cs224n_2017_1/nlm.jpg" style="zoom:50%"></p><h2 id="NLP应用：机器翻译"><a href="#NLP应用：机器翻译" class="headerlink" title="NLP应用：机器翻译"></a>NLP应用：机器翻译</h2><p>传统方法在很多层级上都做过尝试，传统的MT系统是非常庞大复杂的，并且有试图寻找一种通用的中介语来作为源语和目标语之间的桥梁。</p><p>而深度学习方法，即神经机器翻译（Neural Machine Translation，NMT），将源语映射为向量，然后由向量构造目标语（参考<a href="https://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sutskever et al. 2014</a>，<a href="https://arxiv.org/abs/1409.0473" target="_blank" rel="noopener">Bahdanau et al. 2014</a>，<a href="https://arxiv.org/abs/1604.00788" target="_blank" rel="noopener">Luong and Manning 2016</a>）：</p><p><img src="/2019/05/29/cs224n_2017_1/nmt.jpg"></p><h2 id="总结：所有层级表示都是向量"><a href="#总结：所有层级表示都是向量" class="headerlink" title="总结：所有层级表示都是向量"></a>总结：所有层级表示都是向量</h2><p>深度学习的根本强项在于，将所有的语言形式用向量表达，通过一些变形操作又可以将向量变成矩阵或更高阶的阵列（即张量tensor），所以向量是一种具有强大表达能力的灵活的数据结构。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>词向量，一般想正经做点儿东西的话，怎么也得300维、1000维或者更多维这样的级别。</p><p>试图将词向量按照高维空间表示的含义映射到二维空间上的常用方法：PCA（主成分分析），t-SNE（一种非线性降维），但低维投影还是会遗漏大量信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;斯坦福cs224n-2017 winter笔记&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://web.stanford.edu/class/archive/cs/cs224n/cs224n.1174/syllabus.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;课程链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://lesley0416.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="cs224n-2017" scheme="https://lesley0416.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/cs224n-2017/"/>
    
    
      <category term="cs224n" scheme="https://lesley0416.github.io/tags/cs224n/"/>
    
      <category term="深度学习" scheme="https://lesley0416.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【译】Understanding LSTM Networks</title>
    <link href="https://lesley0416.github.io/2019/05/21/UnderstandingLSTM/"/>
    <id>https://lesley0416.github.io/2019/05/21/UnderstandingLSTM/</id>
    <published>2019-05-21T06:27:50.000Z</published>
    <updated>2019-05-21T07:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自 <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></p><p>部分内容有点直译，领会精神，，，</p></blockquote><a id="more"></a><h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p>人类不会每秒都从头开始新的想法。正如阅读这篇文章时，我们会基于对上文的理解，去理解当前的文字。我们不会抛开所有去重新开始理解。也就是说，我们的思考是具有连续性的。</p><p>传统的神经网络的一个主要缺点就是做不到“具有持续性”这一点。例如，假设我们想要对电影中某个时间点所发生的事件进行分类，目前，我们尚不清楚如何使用传统的神经网络，来完成“利用该时间点的前续内容进行推导并得到后续时间点发生的事情”这一过程。</p><p>循环神经网络（RNN，Recurrent Neural Networks）解决了这个问题。RNN是带有循环的网络，允许信息的持久化。</p><p><img src="/2019/05/21/UnderstandingLSTM/RNN-rolled.png" style="zoom:50%"></p><p>图示为带有循环的RNN。</p><p>在上图中，神经网络的一个chunk, $A$，接受输入$x_t$，并输出$h_t$。循环允许信息从网络中的一个步骤传递到下一个步骤。</p><p>这些循环使得RNN看起来有点神秘。但事实上，RNN并不是完全不同于普通的神经网络。RNN可以认为是同一个网络的多个副本，每一个副本都将信息传递给下一个。想象，如果将RNN的循环展开，如下图：</p><p><img src="/2019/05/21/UnderstandingLSTM/RNN-unrolled.png" style="zoom:50%"></p><p>图示为展开的RNN。</p><p>这种链式结构表明，RNN和序列及列表密切相关，是用于序列及列表结构数据的神经网络的一种自然结构。</p><p>在过去几年里，RNN在很多问题上都有令人难以置信的成功应用，如语音识别、语言模型、机器翻译、图像字幕等等。关于RNN效果的讨论可以参考Andrej Karpathy的文章，<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">The Unreasonable Effectiveness of Recurrent Neural Networks</a> 。</p><p>RNN取得上述成功的关键在于LSTM的使用，LSTM是RNN中的一个特殊结构，在很多任务上，都优于普通的RNN。RNN上几乎所有难以置信的效果有是基于LSTM实现的。本文将对LSTM进行探讨。</p><h1 id="长期依赖问题"><a href="#长期依赖问题" class="headerlink" title="长期依赖问题"></a>长期依赖问题</h1><p>RNN的诉求之一就是能够将先前的信息连接到当前任务，如通过先前的视频片段可以理解当前的视频片段。如果RNN可以做到这一点，那网络将会非常有效。RNN是否可以呢？视情况而定。</p><p>有时，我们只需要通过最近的信息就可以完成当前的任务。例如，对于一个通过前一个词来预测下一个词的语言模型。如果我们希望预测<code>the clouds are in the sky</code>这句话的最后一个单词<code>sky</code>，我们不需要更多的上下文，很明显最后一个单词就应该是<code>sky</code>。在这种情况下，相关信息之间的距离很小，RNN可以学到过去的信息并加以使用。</p><p><img src="/2019/05/21/UnderstandingLSTM/RNN-shorttermdepdencies.png" style="zoom:30%"></p><p>但是也有一些需要更多上下文的情况。假设我们希望预测片段<code>I grew up in France… I speak fluent French.</code>的最后一个单词。通过距离最近的信息我们可以推测最后一个词可能是一种语言的名称，但如果我们想确定到底是哪一种语言，就需要距离更远的关于<code>France</code>的上文信息。可见，相关信息之间的距离以及所需的信息点跨度是完全有可能非常大的。</p><p>不幸的是，随着跨度的增大，RNN对于先前信息的感知能力会下降。</p><p><img src="/2019/05/21/UnderstandingLSTM/RNN-longtermdependencies.png" style="zoom:30%"></p><p>理论上，RNN绝对可以处理这种长期依赖问题。我们可以通过仔细的调整相应参数来解决这种形式的小问题。但很不幸，在实践中，RNN似乎不能很好的处理这类情况。关于这个问题，<a href="http://people.idsia.ch/~juergen/SeppHochreiter1991ThesisAdvisorSchmidhuber.pdf" target="_blank" rel="noopener">Hochreiter(1991)[German]</a> 和 <a href="http://ai.dinfo.unifi.it/paolo/ps/tnn-94-gradient.pdf" target="_blank" rel="noopener">Bengio, et al. (1994)</a> 已经进行了深入的探讨，并发现了RNN之所以难以解决该类问题的一些很根本的原因。</p><p>好在，LSTM并没有上述问题。</p><h1 id="LSTM网络"><a href="#LSTM网络" class="headerlink" title="LSTM网络"></a>LSTM网络</h1><p>长短时记忆网络（Long Short Term Memory networks，LSTM）是RNN的一种特例，能够解决长期依赖的问题。LSTM由 <a href="http://www.bioinf.jku.at/publications/older/2604.pdf" target="_blank" rel="noopener">Hochreiter &amp; Schmidhuber (1997)</a> 提出，并在之后的工作中被大家扩展及推广。LSTM在很多问题上表现都非常好，因此被广泛使用。</p><p>LSTM是明确为了避免长期依赖的问题而设计的。对信息的长时间记录是LSTM的默认行为，而不需要进行努力的学习来获取。</p><p>所有的RNN都有链式的形式来重复神经网络的某个模块。在标准的RNN中，这个重复的模块可能结构非常简单，例如只是一个$tanh​$层。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-SimpleRNN.png" style="zoom:30%"></p><p>图示：标准RNN中的重复模块包含一个单一的tanh层</p><p>LSTM也有这种链式结构，但是其中重复模块的结构相对复杂。不再是一个单一的神经网络层，而是四个，以一种非常特殊的形式进行交互。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-chain.png" style="zoom:30%"></p><p>图示：LSTM的重复模块包含四个交互层</p><p>不用担心细节是如何进行的。我们后面会一步一步了解LSTM。现在，先熟悉接下来即将使用到的一些符号。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM2-notation.png" style="zoom:50%"></p><p>在上图中，从一个节点的输出到另一个节点的输入，每一行都有一个完整的向量。粉色圆圈表示点态操作（点态指向量计算后得到的向量），如向量加法，黄色方框表示神经网络层。箭头合并表示向量合并，箭头分叉表示向量复制到不同位置。</p><h1 id="LSTMs背后的核心思想"><a href="#LSTMs背后的核心思想" class="headerlink" title="LSTMs背后的核心思想"></a>LSTMs背后的核心思想</h1><p>LSTMs的关键在于<code>cell state</code>（细胞状态？），即下图横穿顶部的水平线。</p><p><strong>Cell state</strong>像传送带一样，横穿整个链路，但只有很少的线性交互。所以信息可以很容易的传递并且不被改变。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-C-line.png" style="zoom:50%"></p><p>LSTM可以从cell state上添加或删除信息，这种功能是由一种叫<code>gates</code>的结构仔细调控的。</p><p><strong>Gates</strong>是一种选择性让信息通过的方法，由一个sigmoid神经网络层和一个点态乘法操作组成。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-gate.png" style="zoom:50%"></p><p><strong>sigmoid层</strong>输出值在0~1之间，描述了每个组件可以通过多少。0表示全部不许通过，1表示全部可以通过。</p><p>一个LSTM有三个这样的gates，来保护和控制cell state。</p><h1 id="LSTM的详细原理"><a href="#LSTM的详细原理" class="headerlink" title="LSTM的详细原理"></a>LSTM的详细原理</h1><p>LSTM的第一步是<strong>决定要哪些信息可以继续通过cell state（就是决定丢掉哪些信息）</strong>。这个决定是由一个叫做<strong>遗忘门，forget gate layer</strong>的sigmoid层决定的。遗忘门的输入是$h_{t-1}$和$x_t $，输出一个0~1之间的值（输出内容是一个和$C_{t-1}$同维度的0/1向量），表示在cell state $C_{t-1}$ 中每部分内容通过的比重。1表示全部保留，0表示全部放弃。</p><p>回到上文我们提到的基于<strong>所有</strong>前文来预测接下来内容的语言模型的例子。在这个问题中，cell state 可以包含当前主语的性别信息（<strong>保留信息</strong>），所以可以使用正确的代词。当我们开始一个新的主语时，我们会想要忘掉前一个主语的性别信息（<strong>遗忘信息</strong>）。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-focus-f.png" style="zoom:40%"></p><p>接下来的一步是决定<strong>要在cell state中新增哪些信息</strong>。主要包括两部分。首先，由一个叫做<strong>input gate layer</strong>的sigmoid层决定要更新哪些维度的信息。还有一个<strong>tanh层</strong>生成一个新的可以被新增到state中的候选向量$\tilde{C}_t​$。之后，我们将这两层进行合并，从而对state进行更新。</p><p>在我们的语言模型的例子中，我们将新主语的性别信息加入到cell state中，替代遗忘掉的旧的性别信息。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-focus-i.png" style="zoom:40%"></p><p>现在，我们将旧的cell state，更新到新的 cell state，即把$C_{t-1}$ 更新为$C_t$。上述步骤已经描述了具体要做的内容，只需要实际实现即可。</p><p>我们将<strong>旧的state乘以 $f_t$ </strong>，来遗忘掉决定忘掉的内容。然后<strong>再加上 $i_t\times \tilde{C}_t$ </strong>，这是新的候选向量，取决于我们决定对state值更新多少。</p><p>在语言模型的例子中，就是我们要丢掉旧主语的性别信息，并且按照上述步骤所描述的，添加新的性别信息。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-focus-temp.png" style="zoom:40%"></p><p>最后，我们需要决定将要输出什么。输出取决于cell state，但是是一个过滤后的版本。首先，我们通过一个sigmoid层（<strong>output gate</strong>）决定要输出cell state的哪些部分，以及对应的比例。然后，将cell state通过一个tanh层（将值映射到-1~1之间）后，和sigmoid层的输出相乘，从而得到我们想要的输出。</p><p>对于语言模型的例子中，当刚刚看到一个主语的时候，接下来想要输出一个动词的时候，这个动词就和主语的信息相关了。例如，根据主语是单数还是复数形式，来决定动词应该采用什么格式来加入到后续内容中。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-focus-temp2.png" style="zoom:40%"></p><h1 id="LSTM的变种"><a href="#LSTM的变种" class="headerlink" title="LSTM的变种"></a>LSTM的变种</h1><p>到目前为止所描述的都是普通的LSTM。但是，不是所有的LSTMs都和上文描述的一样。实际上，每篇涉及到LSTMs的论文，都会有一些轻微的改动。通常改动都很小，但也有必要了解一些。</p><p>一个流行的LSTM变种，是由<a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf" target="_blank" rel="noopener">Gers &amp; Schmidhuber (2000)</a> 提出的，加入了一个<code>peephole connections</code>。意味着，每一个gate层，都可以用cell state做输入。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-var-peepholes.png" style="zoom:40%"></p><p>上图对所有的gates都增加了peepholes，但是在很多论文中，是对有些门加peepholes，有些门不加。</p><p>另一个变种是将遗忘门和输入门组合使用。不同于单独决定要遗忘和要新增的信息，而是将两个信息放在一起决定。只有当某个维度有新信息加入时，才需要遗忘掉旧的信息。只有当遗忘掉旧的信息时，才新增新的信息。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-var-tied.png" style="zoom:40%"></p><p>LSTM另一个更厉害的变种是<strong>门控循环单元GRU（Gated Recurrent Unit）</strong>，由<a href="https://arxiv.org/pdf/1406.1078v3.pdf" target="_blank" rel="noopener">Cho, et al. (2014)</a> 提出。GRU将遗忘门和输入门组合成一个单独的更新门<strong>update gate</strong>。同时，将cell state和隐藏状态hidden state进行合并，并做了一些其他修改。最终得到的模型要比标准的LSTM模型更简单，并且广受欢迎。</p><p>在GRU中，只有两个门：<strong>重置门“reset gate”和更新门“update gate”</strong>。</p><p><img src="/2019/05/21/UnderstandingLSTM/LSTM3-var-GRU.png" style="zoom:40%"></p><p>上图中，$r_t$  表示重置门，$z_t$ 表示更新门。重置门决定是否将之前的state遗忘。当 $r_t$ 趋于0的时候，前一个时刻的state信息 $h_{t-1}$ 会被遗忘，隐藏状态 $\tilde{h}_t$ 会被重置为当前的输入信息。更新门决定是否要将隐藏状态更新为新的状态 $\tilde{h}_t$ ，作用相当于合并了LSTM中的遗忘门和输入门。</p><p><strong>GRU和LSTM简单比较一下：</strong></p><ol><li>GRU少一个门，同时也少了cell state  $C_t$ ；</li><li>在LSTM中，通过遗忘门和输入门控制信息的遗忘和输入；GRU则通过重置门来控制是否要保留原来hidden state的信息，但是不再限制当前信息的输入；</li><li>在LSTM中，虽然得到了新的cell state  $C_t$ ，但是不能直接输出，而是要经过一个过滤处理；同样，在GRU中，虽然也得到了新的hidden state  $\tilde{h}_t$ ，但是不能直接输出，而是通过更新门来控制最后的输出。</li></ol><p>这些只是LSTM的几个有名的变种。还有很多其他变种，如<a href="https://arxiv.org/pdf/1508.03790v2.pdf" target="_blank" rel="noopener">Depth Gated RNNs by Yao, et al. (2015)</a> 。也有一些完全不同的处理长期依赖问题的方法，如<a href="https://arxiv.org/pdf/1402.3511v1.pdf" target="_blank" rel="noopener">Clockwork RNNs by Koutnik, et al. (2014)</a> 。</p><p>哪种变种更好呢？这些不同有什么影响呢？<a href="https://arxiv.org/pdf/1503.04069.pdf" target="_blank" rel="noopener">Greff, et al. (2015)</a> 对这些流行的变种进行了非常好的对比，发现他们都是一致的。<a href="http://proceedings.mlr.press/v37/jozefowicz15.pdf" target="_blank" rel="noopener">Jozefowicz, et al. (2015)</a> 在测试了一万多种RNN结构后，发现其中一些在特定任务上效果要好于LSTMs（该论文值得推荐）。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在上文提到的一些使用RNN达到的非常显著的成果。本质上都是通过LSTMs实现的。在很多任务上，LSTM确实表现非常好。</p><p>LSTM的一系列公式看起来很吓人，希望通过本文的逐步解释能使其便于理解一些。</p><p>LSTMs是RNNs的一个巨大进步。很自然的想到，是否有另一个巨大进步？研究者的普遍共识是：有，确实有下一步，就是 <strong>attention</strong>。<strong>Attention的思想是让RNN的每一步都从一些更大的信息集合中采集信息</strong>。例如，如果你使用RNN来为图片创造标题时，可能会选择部分图片来查找其输出的每一个词。实际上，<a href="https://arxiv.org/pdf/1502.03044v2.pdf" target="_blank" rel="noopener">Xu, et al. (2015)</a> 做了这部分工作，如果想要了解attention的话，这篇论文可以作为一个很好的起点。已经有很多使用attention得到很好效果的应用，但大部分似乎是比较偏僻的方向。</p><p>Attention并不是RNN研究的唯一兴奋点。例如，<a href="https://arxiv.org/pdf/1507.01526v1.pdf" target="_blank" rel="noopener">Kalchbrenner, et al. (2015)</a> 提出的Grid LSTMs似乎也很有前途。另外，在生成式模型中使用RNN，如 <a href="https://arxiv.org/pdf/1502.04623.pdf" target="_blank" rel="noopener">Gregor, et al. (2015)</a> 、<a href="https://arxiv.org/pdf/1506.02216v3.pdf" target="_blank" rel="noopener">Chung, et al. (2015)</a> 或者 <a href="https://arxiv.org/pdf/1411.7610v3.pdf" target="_blank" rel="noopener">Bayer &amp; Osendorfer (2015)</a> ，看起来也很有趣。过去几年是RNN令人兴奋的时期，接下来几年相信会更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译自 &lt;a href=&quot;http://colah.github.io/posts/2015-08-Understanding-LSTMs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Understanding LSTM Networks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部分内容有点直译，领会精神，，，&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lesley0416.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LSTM" scheme="https://lesley0416.github.io/tags/LSTM/"/>
    
      <category term="RNN" scheme="https://lesley0416.github.io/tags/RNN/"/>
    
      <category term="循环神经网络" scheme="https://lesley0416.github.io/tags/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】Explore：Array &amp; String 数组 &amp; 字符串</title>
    <link href="https://lesley0416.github.io/2019/05/04/leetcode_explore_array_string/"/>
    <id>https://lesley0416.github.io/2019/05/04/leetcode_explore_array_string/</id>
    <published>2019-05-04T11:55:50.000Z</published>
    <updated>2019-05-30T15:12:24.358Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考自LeetCode上Explore模块的<a href="https://leetcode.com/explore/learn/card/array-and-string/" target="_blank" rel="noopener">Array &amp; String</a>，作为笔记记录。</p></blockquote><h1 id="Overview-综述"><a href="#Overview-综述" class="headerlink" title="Overview 综述"></a>Overview 综述</h1><p>字符串是字符数组，主要了解数组和动态数组之间的区别以及基本操作。理解多维数组的使用，以及双指针技巧的使用。</p><a id="more"></a><p>主要内容：</p><ol><li>了解<code>数组</code>和<code>动态数组</code>之间的区别；</li><li>熟悉数组和动态数组中的<code>基本操作</code>；</li><li>理解<code>多维数组</code>并能够掌握<code>二维数组</code>的使用；</li><li>明白<code>字符串</code>的概念以及字符串所具有的不同特性；</li><li>能够运用<code>双指针技巧</code>解决实际问题。</li></ol><h1 id="Introduction-to-Array-数组简介"><a href="#Introduction-to-Array-数组简介" class="headerlink" title="Introduction to Array 数组简介"></a>Introduction to Array 数组简介</h1><p>主要了解数组和动态数组。</p><h2 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h2><p><img src="/2019/05/04/leetcode_explore_array_string/array.png" style="zoom:50%"></p><p>数组用于按顺序存储元素的集合。图示是一位数组的例子。数组中的元素可以随机存取，通过数组索引来识别。</p><p>数组的用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. Initialize</span></span><br><span class="line">    <span class="keyword">int</span> a0[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> a1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// other element will be set as the default value</span></span><br><span class="line">    <span class="comment">// 2. Get Length</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(a1) / <span class="keyword">sizeof</span>(*a1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of a1 is: "</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 3. Access Element</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first element is: "</span> &lt;&lt; a1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 4. Iterate all Elements</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[Version 1] The contents of a1 are:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; a1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[Version 2] The contents of a1 are:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; item: a1) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 5. Modify Element</span></span><br><span class="line">    a1[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 6. Sort</span></span><br><span class="line">    sort(a1, a1 + size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态数组简介"><a href="#动态数组简介" class="headerlink" title="动态数组简介"></a>动态数组简介</h2><p>多数编程语言提供内置的动态数组，例如C++中的vector，Java中的ArrayList。</p><p>动态数组用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. initialize</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v0;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 2. make a copy</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(v1.begin(), v1.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(v2);</span><br><span class="line">    <span class="comment">// 2. cast an array to a vector</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4(a, *(&amp;a + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 3. get length</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of v4 is: "</span> &lt;&lt; v4.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 4. access element</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first element in v4 is: "</span> &lt;&lt; v4[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 5. iterate the vector</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[Version 1] The contents of v4 are:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v4.size(); ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; v4[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[Version 2] The contents of v4 are:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; item : v4) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"[Version 3] The contents of v4 are:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item = v4.begin(); item != v4.end(); ++item) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; *item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 6. modify element</span></span><br><span class="line">    v4[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 7. sort</span></span><br><span class="line">    sort(v4.begin(), v4.end());</span><br><span class="line">    <span class="comment">// 8. add new element at the end of the vector</span></span><br><span class="line">    v4.push_back(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 9. delete the last element</span></span><br><span class="line">    v4.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习：寻找数组的中心索引"><a href="#练习：寻找数组的中心索引" class="headerlink" title="练习：寻找数组的中心索引"></a>练习：寻找数组的中心索引</h2><p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组<strong>“中心索引”</strong>的方法。</p><p>我们是这样定义数组<strong>中心索引</strong>的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">输出: -1</span><br><span class="line">解释: </span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li><li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li></ul><p><strong>解题思路</strong></p><p>首先计算数组元素总和，之后顺序遍历数组，如果当前位置左侧的和，乘以2加上当前位置的值等于数组总和，则当前位置为中心索引。</p><p>需要注意的是边界值的判断。</p><p>用到的测试用例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">[]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span> || nums.size() == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp * <span class="number">2</span> + nums[i] == sum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，C++中对vector元素求和，可使用<code>accumulate</code>函数，头文件<code>#include &lt;numeric&gt;</code>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span> || nums.size() == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// int sum = 0;</span></span><br><span class="line">        <span class="comment">// for (int i: nums) &#123;</span></span><br><span class="line">        <span class="comment">//     sum += i;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp * <span class="number">2</span> + nums[i] == sum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考自LeetCode上Explore模块的&lt;a href=&quot;https://leetcode.com/explore/learn/card/array-and-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Array &amp;amp; String&lt;/a&gt;，作为笔记记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Overview-综述&quot;&gt;&lt;a href=&quot;#Overview-综述&quot; class=&quot;headerlink&quot; title=&quot;Overview 综述&quot;&gt;&lt;/a&gt;Overview 综述&lt;/h1&gt;&lt;p&gt;字符串是字符数组，主要了解数组和动态数组之间的区别以及基本操作。理解多维数组的使用，以及双指针技巧的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="https://lesley0416.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://lesley0416.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="字符串" scheme="https://lesley0416.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Array" scheme="https://lesley0416.github.io/tags/Array/"/>
    
      <category term="String" scheme="https://lesley0416.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】Explore：Queue &amp; Stack 队列 &amp; 栈</title>
    <link href="https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/"/>
    <id>https://lesley0416.github.io/2019/04/15/leetcode_explore_queue_stack/</id>
    <published>2019-04-15T01:58:50.000Z</published>
    <updated>2019-05-02T08:37:33.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考自LeetCode上Explore模块的<a href="https://leetcode.com/explore/learn/card/queue-stack/" target="_blank" rel="noopener">Queue &amp; Stack</a>，作为笔记记录。</p></blockquote><h1 id="Overview-综述"><a href="#Overview-综述" class="headerlink" title="Overview 综述"></a>Overview 综述</h1><p>主要了解两种不同的元素处理顺序：先入先出（FIFO）和后入先出（LIFO）；以及两个相应的线性数据结构：队列（Queue）和栈（Stack）。</p><a id="more"></a><p>主要内容：</p><ol><li>了解 FIFO 和 LIFO 处理顺序的原理；</li><li>实现这两个数据结构；</li><li>熟悉内置的队列和栈结构；</li><li>解决基本的队列相关问题，尤其是 <code>BFS</code>；</li><li>解决基本的栈相关问题；</li><li>理解当你使用 <code>DFS</code> 和其他<code>递归</code>算法来解决问题时，系统栈是如何帮助你的。</li></ol><h1 id="Queue-First-in-first-out-Data-Structure-队列：先入先出的数据结构"><a href="#Queue-First-in-first-out-Data-Structure-队列：先入先出的数据结构" class="headerlink" title="Queue: First-in-first-out Data Structure 队列：先入先出的数据结构"></a>Queue: First-in-first-out Data Structure 队列：先入先出的数据结构</h1><h2 id="先入先出的数据结构"><a href="#先入先出的数据结构" class="headerlink" title="先入先出的数据结构"></a>先入先出的数据结构</h2><p><img src="/2019/04/15/leetcode_explore_queue_stack/fifo_queue.png" style="zoom:50%"></p><p>FIFO数据结构：<font color="red">首先处理添加到队列中的第一个元素</font>。</p><p><font color="red">队列</font>是典型的FIFO数据结构，插入删除操作被称为入队出队，新元素始终添加在<code>队列末尾</code>，只能移除<code>第一个元素</code>。</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>简单的使用动态数组和指向队列头部的索引来实现队列，会导致空间的浪费。</p><p>更有效的方法是使用循环队列，即使用<code>固定大小的数组</code>和<code>两个指针</code>来指示起始位置和结束位置，目的是<strong>重用被浪费的存储空间</strong>。</p><p>示例如图：</p><p><img src="/2019/04/15/leetcode_explore_queue_stack/circular_queue.gif"></p><h2 id="练习：设计循环队列"><a href="#练习：设计循环队列" class="headerlink" title="练习：设计循环队列"></a>练习：设计循环队列</h2><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p>你的实现应该支持如下操作：</p><ul><li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li><li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li><li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li><li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li><li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li><li><code>isEmpty()</code>: 检查循环队列是否为空。</li><li><code>isFull()</code>: 检查循环队列是否已满。</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue circularQueue = new MycircularQueue(3); // 设置长度为 3</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(1);  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(2);  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(3);  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(4);  // 返回 false，队列已满</span><br><span class="line"></span><br><span class="line">circularQueue.Rear();  // 返回 3</span><br><span class="line"></span><br><span class="line">circularQueue.isFull();  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.deQueue();  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(4);  // 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.Rear();  // 返回 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有的值都在 0 至 1000 的范围内；</li><li>操作数将在 1 至 1000 的范围内；</li><li>请不要使用内置的队列库。</li></ul><h2 id="解答：设计循环队列"><a href="#解答：设计循环队列" class="headerlink" title="解答：设计循环队列"></a>解答：设计循环队列</h2><p>使用一个数组和两个指针（<code>tail</code>和<code>head</code>）表示队列的结束和起始位置。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    MyCircularQueue(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        data.resize(k);</span><br><span class="line">        size = k;</span><br><span class="line">        head = <span class="number">-1</span>;</span><br><span class="line">        tail = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = (tail+<span class="number">1</span>) % size;</span><br><span class="line">        data[tail] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = <span class="number">-1</span>;</span><br><span class="line">            tail = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = (head+<span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[head];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[tail];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (tail+<span class="number">1</span>) % size == head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue* obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;enQueue(value);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;Rear();</span></span><br><span class="line"><span class="comment"> * bool param_5 = obj-&gt;isEmpty();</span></span><br><span class="line"><span class="comment"> * bool param_6 = obj-&gt;isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="队列：用法"><a href="#队列：用法" class="headerlink" title="队列：用法"></a>队列：用法</h2><p>大多数语言都提供内置的队列库，无需重复造轮子。</p><p>以C++内置队列库使用为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. Initialize a queue.</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 2. Push new element.</span></span><br><span class="line">    q.push(<span class="number">5</span>);</span><br><span class="line">    q.push(<span class="number">13</span>);</span><br><span class="line">    q.push(<span class="number">8</span>);</span><br><span class="line">    q.push(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 3. Check if queue is empty.</span></span><br><span class="line">    <span class="keyword">if</span> (q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Queue is empty!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. Pop an element.</span></span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="comment">// 5. Get the first element.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first element is: "</span> &lt;&lt; q.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 6. Get the last element.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The last element is: "</span> &lt;&lt; q.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 7. Get the size of the queue.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size is: "</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当想要按顺序处理元素时，使用队列可能是一个很好的选择。</strong></p><h2 id="练习：Moving-Average-from-Data-Stream"><a href="#练习：Moving-Average-from-Data-Stream" class="headerlink" title="练习：Moving Average from Data Stream"></a>练习：<a href="https://leetcode.com/problems/moving-average-from-data-stream" target="_blank" rel="noopener">Moving Average from Data Stream</a></h2><blockquote><p>【LeetCode】346</p></blockquote><p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p><p>For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MovingAverage m = new MovingAverage(3);</span><br><span class="line">m.next(1) = 1</span><br><span class="line">m.next(10) = (1 + 10) / 2</span><br><span class="line">m.next(3) = (1 + 10 + 3) / 3</span><br><span class="line">m.next(5) = (10 + 3 + 5) / 3</span><br></pre></td></tr></table></figure><p>计算滑动窗口中数字的平均数。</p><p>用队列模拟窗口，队列长度为窗口大小，超过时则将首元素移出队列，返回当前队列的平均数即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MovingAverage(<span class="keyword">int</span> size): size(size), sum(<span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.size() &gt;= size)</span><br><span class="line">        &#123;</span><br><span class="line">            sum -= que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += val;</span><br><span class="line">        que.push(val);</span><br><span class="line">        <span class="keyword">return</span> sum/que.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj.next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="Queue-and-BFS-队列和广度优先搜索"><a href="#Queue-and-BFS-队列和广度优先搜索" class="headerlink" title="Queue and BFS 队列和广度优先搜索"></a>Queue and BFS 队列和广度优先搜索</h1><p>广度优先搜索（BFS）是一种<strong>遍历或搜索</strong>数据结构的算法。</p><p>可以用BFS执行树的层序遍历，可以遍历图并找到从起始节点到目标节点的路径（特别是最短路径）。</p><h2 id="队列和BFS"><a href="#队列和BFS" class="headerlink" title="队列和BFS"></a>队列和BFS</h2><p><strong>BFS的一个常见应用是找从根节点到目标节点的最短路径。</strong></p><p>下图展示用BFS找出节点A到目标节点G的最短路径。</p><p><img src="/2019/04/15/leetcode_explore_queue_stack/bfs.gif" style="zoom: 80%"></p><p>上述过程中：</p><p>节点处理顺序：越是接近根节点的节点将越早被遍历，所以第一次找到目标节点时，即为最短路径。</p><p>入队出队顺序：首先根节点入队，之后每轮处理已经在队列中的点，并将所有邻居入队，新加入的节点将在下轮处理，节点处理顺序与入队的顺序相同，即<strong>FIFO</strong>，所以BFS过程中可以使用队列处理问题。</p><h2 id="广度优先搜索——模板"><a href="#广度优先搜索——模板" class="headerlink" title="广度优先搜索——模板"></a>广度优先搜索——模板</h2><p>使用BFS的两个主要场景：<strong>遍历</strong>或<strong>找出最短路径</strong>。</p><blockquote><p>BFS也可以用于更抽象的场景中，在特定问题中执行BFS之前确定节点和边缘非常重要。通常，节点是实际节点或状态，而边缘是实际边缘或可能的转换。</p></blockquote><p>伪代码模板（Java）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> * 返回root和target之间的最短路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed，存储所有待处理的节点</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node，根节点到正在访问的当前节点的距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="comment">// 每循环一层，距离根节点更远一步</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="comment">// 每轮中，队列中的节点是等待处理的节点</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                add next to queue;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要确保<strong>不会访问一个节点两次</strong>，可以在上述代码中加入一个set来记录访问过的节点，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; used;     <span class="comment">// store all the used nodes</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to used;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to used;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习：walls-and-gates"><a href="#练习：walls-and-gates" class="headerlink" title="练习：walls and gates"></a>练习：walls and gates</h2><blockquote><p>【LeetCode】286</p></blockquote><p>You are given a $m*n$ 2D grid initialized with these three possible values.</p><p>给定一个的用如下三个可能值初始化的$m*n$的2D网格。</p><ol><li><code>-1</code> - A wall or an obstacle. 墙壁或障碍物。</li><li><code>0</code> - A gate. 门。</li><li><code>INF</code> - Infinity means an empty room. We use the value $2^{31}-1=2147483647$ to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>. Infinity是一个空房间，使用值$2^{31}-1=2147483647$来表示<code>INF</code>，可以假设到门的距离小于<code>2147483647</code>。</li></ol><p>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with <code>INF</code>. 在每个代表空房间的网格中填充其距离最进门的距离，如果不可能到达门，则填充<code>INF</code>。</p><p>For example, given the 2D grid:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INF  -1  0  INF</span><br><span class="line">INF INF INF  -1</span><br><span class="line">INF  -1 INF  -1</span><br><span class="line">  0  -1 INF INF</span><br></pre></td></tr></table></figure><p>After running your function, the 2D grid should be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3  -1   0   1</span><br><span class="line">2   2   1  -1</span><br><span class="line">1  -1   2  -1</span><br><span class="line">0  -1   3   4</span><br></pre></td></tr></table></figure><p>代码如下：</p><blockquote><p>要注意节点的判断；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; room)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (room.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = room.size();</span><br><span class="line">        <span class="keyword">int</span> col = room[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历输入，将所有门的位置入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (room[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push([i, j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="comment">// 首元素出队，并获取其坐标</span></span><br><span class="line">            <span class="keyword">auto</span> head = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> ox = head.first;</span><br><span class="line">            <span class="keyword">int</span> oy = head.second;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历门的四个相邻点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = ox + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny = oy + dy[i];</span><br><span class="line">                <span class="comment">// 如果该位置在矩阵范围内，且该位置为INF，则进行填充及入队操作，这样，等queue中所有元素都遍历完了，则矩阵所有非墙的位置就都被正确更新了</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; room[nx][ny] == INF) &#123;</span><br><span class="line">                    q.push(&#123;nx, ny&#125;);</span><br><span class="line">                    room[nx][ny] = room[ox][oy] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习：岛屿的个数"><a href="#练习：岛屿的个数" class="headerlink" title="练习：岛屿的个数"></a>练习：岛屿的个数</h2><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>采用广度优先遍历的方法还是很容易解决这个问题的，我们尝试遍历所有的点，如果一个点是陆地且从未遍历过，则认为发现了新岛屿，在发现了新岛屿后使用广度优先的方式扩展该岛屿以防止重复计数．</p><p>代码如下（含完整测试代码）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = row &gt; <span class="number">0</span> ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录访问过的节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(row, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 遍历与当前节点相连的所有节点</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 查看周围上下左右的节点</span></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 遍历所有为1的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    <span class="comment">// 节点为1，且没有被访问过，即为发现新的小岛</span></span><br><span class="line">                    count++; <span class="comment">// 小岛数加1</span></span><br><span class="line">                    q.push(&#123;i, j&#125;); <span class="comment">// 节点入队</span></span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>; <span class="comment">// 修改节点访问标记</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 遍历与当前节点相连的其他节点</span></span><br><span class="line">                    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> head = q.front(); <span class="comment">// 获取首元素及其坐标</span></span><br><span class="line">                        q.pop();</span><br><span class="line">                        <span class="keyword">int</span> ox = head.first;</span><br><span class="line">                        <span class="keyword">int</span> oy = head.second;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 遍历上下左右的四个节点</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="keyword">int</span> nx = ox + dx[k];</span><br><span class="line">                            <span class="keyword">int</span> ny = oy + dy[k];</span><br><span class="line">                            <span class="comment">// 如果该节点在矩阵范围内，且值为1，则入队，并修改节点访问标记，这样等队列元素遍历结束后，则当前相连区域内的节点已遍历结束，可继续寻找下一个不相连的值为1的节点，即新的岛屿</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; grid[nx][ny] == <span class="string">'1'</span> &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">                                visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                                q.push(&#123;nx, ny&#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = grid.size(), cols = rows &gt; <span class="number">0</span> ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rows == <span class="number">0</span> || cols == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Empty datas."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; grid[i][j];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="keyword">int</span> count = s.numIslands(grid);</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is "</span> &lt;&lt; count &lt;&lt; <span class="string">" island."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; count &lt;&lt; <span class="string">" islands."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; grid;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; tmp;</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    test(grid);</span><br><span class="line"></span><br><span class="line">    grid.clear();</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    tmp.clear();</span><br><span class="line">    tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'0'</span>); tmp.push_back(<span class="string">'1'</span>); tmp.push_back(<span class="string">'1'</span>);</span><br><span class="line">    grid.push_back(tmp);</span><br><span class="line">    test(grid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习：打开转盘锁"><a href="#练习：打开转盘锁" class="headerlink" title="练习：打开转盘锁"></a>练习：打开转盘锁</h2><blockquote><p>【LeetCode】752</p></blockquote><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code> 。每个拨轮可以自由旋转：例如把 <code>&#39;9&#39;</code> 变为  <code>&#39;0&#39;</code>，<code>&#39;0&#39;</code> 变为 <code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 <code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p><p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">无法旋转到目标数字且不被锁定。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends = [&quot;0000&quot;], target = &quot;8888&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>死亡列表 <code>deadends</code> 的长度范围为 <code>[1, 500]</code>。</li><li>目标数字 <code>target</code> 不会在 <code>deadends</code> 之中。</li><li>每个 <code>deadends</code> 和 <code>target</code> 中的字符串的数字会在 10,000 个可能的情况 <code>&#39;0000&#39;</code> 到 <code>&#39;9999&#39;</code> 中产生。</li></ol><p><strong>解题思路</strong></p><p><strong>找最短路径问题，考虑用BFS，将问题建图。</strong></p><p>每个字符串对应一个状态，可以转换到相邻的8个状态（每位加1减1，共4位），从“0000”开始进行BFS，最后得到总步骤数。</p><p>类似用BFS遍历图，找最短路径，所以第一次到达目标节点时的路径一定是最短路径（之一）。</p><ul><li>注意向相邻节点转换时的操作，“0”-&gt;“9”，“9”-&gt;“0”，加1，减1；</li><li>用unordered_set存储访问标记和死亡节点，节省查找过程的时间消耗；</li><li>首先对deadends进行去重，看讨论区有说会有重复的情况；</li><li>BFS：从头结点”0000”开始，遍历所有子节点，初次访问且不在deadends中的则入队；已访问过或在deadends中的则跳过；遍历到下一层时，层数step加1，且更新size为下一层的节点数量；</li><li>每访问一个节点，先判断是否target，若是则返回当前的step；如果队列已空但仍未返回，则说明无路可通。</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (find(deadends.begin(), deadends.end(), <span class="string">"0000"</span>) != deadends.end()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deadends去重</span></span><br><span class="line">sort(deadends.begin(), deadends.end());</span><br><span class="line">deadends.erase(unique(deadends.begin(), deadends.end()), deadends.end());</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; deadset(deadends.begin(), deadends.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储当前节点及其可转换的其他节点，以及对应的步数</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 存储当前队列中可访问元素数量（每层的数量）</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        </span><br><span class="line">visited.insert(<span class="string">"0000"</span>);</span><br><span class="line">q.push(<span class="string">"0000"</span>);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">size = q.size();</span><br><span class="line">            <span class="comment">// 层数加1</span></span><br><span class="line">step++;</span><br><span class="line">            <span class="comment">// 遍历当前层所有节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> cur = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">                <span class="comment">// 逐个遍历可转换的节点（共8个，每位加1减1）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cur.size(); j++) &#123;</span><br><span class="line"><span class="built_in">string</span> temp = cur;</span><br><span class="line"><span class="keyword">if</span> (temp[j] == <span class="string">'9'</span>)</span><br><span class="line">temp[j] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp[j] += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 找到target，返回层数</span></span><br><span class="line"><span class="keyword">if</span> (temp == target)</span><br><span class="line"><span class="keyword">return</span> step;</span><br><span class="line">                    <span class="comment">// 没找到target，且不是死亡数字也没有访问过，则入队</span></span><br><span class="line"><span class="keyword">if</span> (!deadset.count(temp) &amp;&amp; !visited.count(temp)) &#123;</span><br><span class="line">q.push(temp);</span><br><span class="line">visited.insert(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temp = cur;</span><br><span class="line"><span class="keyword">if</span> (temp[j] == <span class="string">'0'</span>)</span><br><span class="line">temp[j] = <span class="string">'9'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">temp[j] -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (temp == target)</span><br><span class="line"><span class="keyword">return</span> step;</span><br><span class="line"><span class="keyword">if</span> (!deadset.count(temp) &amp;&amp; !visited.count(temp)) &#123;</span><br><span class="line">q.push(temp);</span><br><span class="line">visited.insert(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：完全平方数"><a href="#练习：完全平方数" class="headerlink" title="练习：完全平方数"></a>练习：完全平方数</h2><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 = 4 + 9.</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>参考<a href="https://blog.csdn.net/dst111188/article/details/69950493" target="_blank" rel="noopener">网上的思路</a>，转换为最短路径问题。</p><p>从$0$到$n$共有$n+1$个节点，如果从$i , i\in[0,n]$到$j , j\in[0,n]$相差一个完全平方数，就可以将两个节点连接起来，这样所有的点就转化成无向图，问题转化为求从$0$到$n$的最短路径。</p><p>如图所示：</p><p><img src="/2019/04/15/leetcode_explore_queue_stack/perfect_squeres.jpg" style="zoom: 80%"></p><p><strong>无权最短路径问题，可以采用BFS求解。</strong></p><p>也就是说，先遍历从$[1,i<em>i],i</em>i\leq n$，每一步将$n$缩为$n-i*i$，广度优先搜索，直至找到第一条将$n$缩为$0$的路径，即为最短路径。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将num不断用完全平方数代表，直至其成为0，其中1是完全平方数所以总会有解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i*i&lt;=num;i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> temp = num - i*i;</span><br><span class="line">     <span class="keyword">if</span>(visit[temp] == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//将其中没有访问过的点标记，以及将改点所到达的路径录入</span></span><br><span class="line">         queue.add(<span class="keyword">new</span> numpairs(temp,step+<span class="number">1</span>));</span><br><span class="line">         visit[temp] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span> || n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从大到小初始化路径序列，如16、9、4、1</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; square;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i*i&lt;=n; i++) &#123;</span><br><span class="line">            square.insert(square.begin(), i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉某个平方数后剩余的n，步骤数</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(make_pair(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> step = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it: square) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it == num)</span><br><span class="line">                    <span class="keyword">return</span> step+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (it &lt; num) &#123;</span><br><span class="line">                    q.push(make_pair(num-it, step+<span class="number">1</span>)); <span class="comment">// num-it&gt;0,入队</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// it&lt;num/2,重新从头遍历（从最大的开始）</span></span><br><span class="line">                <span class="keyword">if</span> (it &lt; num/<span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Stack-Last-in-first-out-Data-Structure-栈：后入先出的数据结构"><a href="#Stack-Last-in-first-out-Data-Structure-栈：后入先出的数据结构" class="headerlink" title="Stack: Last-in-first-out Data Structure 栈：后入先出的数据结构"></a>Stack: Last-in-first-out Data Structure 栈：后入先出的数据结构</h1><h2 id="后入先出的数据结构"><a href="#后入先出的数据结构" class="headerlink" title="后入先出的数据结构"></a>后入先出的数据结构</h2><p><img src="/2019/04/15/leetcode_explore_queue_stack/lifo_stack.png" style="zoom:50%"></p><p>LIFO数据结构：<font color="red">首先处理添加到队列中的最新元素</font>。</p><p><font color="red">栈</font>是典型的LIFO数据结构，插入删除操作称为入栈(push)出栈(pop)，新元素始终添加在<code>堆栈的末尾</code>，只能移除堆栈中的<code>最后一个元素</code>。</p><p><code>动态数组</code>可用来实现堆栈结构。</p><h2 id="栈：用法"><a href="#栈：用法" class="headerlink" title="栈：用法"></a>栈：用法</h2><p>大部分语言都有内置的栈库，无需重复造轮子。</p><p>以C++内置库的使用为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. Initialize a stack.</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 2. Push new element.</span></span><br><span class="line">    s.push(<span class="number">5</span>);</span><br><span class="line">    s.push(<span class="number">13</span>);</span><br><span class="line">    s.push(<span class="number">8</span>);</span><br><span class="line">    s.push(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 3. Check if stack is empty.</span></span><br><span class="line">    <span class="keyword">if</span> (s.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is empty!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. Pop an element.</span></span><br><span class="line">    s.pop();</span><br><span class="line">    <span class="comment">// 5. Get the top element.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The top element is: "</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 6. Get the size of the stack.</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size is: "</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当想要首先处理最后一个元素时，栈将是最合适的数据结构。</strong></p><h2 id="练习：最小栈"><a href="#练习：最小栈" class="headerlink" title="练习：最小栈"></a>练习：最小栈</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) — 将元素 x 推入栈中。</li><li>pop() — 删除栈顶的元素。</li><li>top() — 获取栈顶元素。</li><li>getMin() — 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>方法一，可以用两个栈，一个是题意要求的栈，另一个用来存储每次push后的当前最小值，push或pop时，同时修改两个栈的内容，存最小值的栈的top即为当前全栈最小值。</p><p>方法二，只用一个栈，再用一个额外的变量存储当前最小值。每次push时，如果要入栈的值比当前最小值小，则将当前最小值和要入栈的值同时入栈（注意先后顺序），每次pop时，要比较即将出栈的值和当前最小值是否相同，如果相同，则意味着当前最小值要更改为下一个栈顶元素（当前最小值和更新的最小值在栈内相邻）。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> minVal;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        minVal = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= minVal) <span class="comment">// 需要更新最小值，并将之前的最小值先入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            minStack.push(minVal);</span><br><span class="line">            minVal = x;</span><br><span class="line">        &#125;</span><br><span class="line">        minStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.top() == minVal) <span class="comment">// 需要更新最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">            minVal = minStack.top();</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="练习：有效的括号"><a href="#练习：有效的括号" class="headerlink" title="练习：有效的括号"></a>练习：有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>用栈结构，遍历字符串，如果是左括号就入栈，如果是右括号就看是否和栈顶元素是一对，如果是则出栈并继续，如果不是一对则返回false，如果遍历结束时栈为空则返回true，如果遍历结束时栈不为空则返回false（如”((“的情况）。</p><p>需要判断一些特殊情况，如s长度为0则直接返回true，如果s长度为奇数则直接返回false，同时top时要先确认栈非空。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.size() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>)</span><br><span class="line">                temp.push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span> &amp;&amp; !temp.empty() &amp;&amp; temp.top() == <span class="string">'('</span>)</span><br><span class="line">                temp.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span> &amp;&amp; !temp.empty() &amp;&amp; temp.top() == <span class="string">'['</span>)</span><br><span class="line">                temp.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#125;'</span> &amp;&amp; !temp.empty() &amp;&amp; temp.top() == <span class="string">'&#123;'</span>)</span><br><span class="line">                temp.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：每日温度"><a href="#练习：每日温度" class="headerlink" title="练习：每日温度"></a>练习：每日温度</h2><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p><strong>提示：</strong><code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的都是 <code>[30, 100]</code> 范围内的整数。</p><p><strong>解题思路</strong></p><p>维护一个递减栈，<strong>存储元素下标</strong>。</p><p>遍历温度列表，如果栈为空则直接入栈，如果栈非空，则比较栈顶元素与当前温度，如果当前元素小于等于栈顶元素则直接入栈，如果当前元素大于栈顶元素，则表明已经找到第一次升温的位置，则直接计算下标差并修改result，之后将栈顶元素出栈，并继续比较下一个栈顶元素与当前温度值，直至当前元素小于等于栈顶元素，将当前值入栈，继续上述流程直至遍历结束。</p><p>实际做的时候，result直接初始化全0，所以遍历结束直接返回result即可。否则需要将栈内剩余元素对应result中的位置全部置0（没有找到升温的点）。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(T.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (T.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; indexStack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;T.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!indexStack.empty() &amp;&amp; T[i] &gt; T[indexStack.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                result[indexStack.top()] = i-indexStack.top();</span><br><span class="line">                indexStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            indexStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// result初始化全为0，所以不用再看栈中剩余元素去更新result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：逆波兰表达式求值"><a href="#练习：逆波兰表达式求值" class="headerlink" title="练习：逆波兰表达式求值"></a>练习：逆波兰表达式求值</h2><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>典型用栈解决问题，计算的中间结果需要入栈。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> stoi(tokens[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; tag&#123;<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item: tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag.find(item) == tag.end()) <span class="comment">// 是数字</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.push(stoi(item));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="keyword">int</span> a = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">int</span> b = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span> (item == <span class="string">"+"</span>)</span><br><span class="line">                    temp = a+b;</span><br><span class="line">                <span class="keyword">if</span> (item == <span class="string">"-"</span>)</span><br><span class="line">                    temp = b-a;</span><br><span class="line">                <span class="keyword">if</span> (item == <span class="string">"*"</span>)</span><br><span class="line">                    temp = a*b;</span><br><span class="line">                <span class="keyword">if</span> (item == <span class="string">"/"</span>)</span><br><span class="line">                    temp = b/a;</span><br><span class="line">                s.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Stack-and-DFS-栈和深度优先搜索"><a href="#Stack-and-DFS-栈和深度优先搜索" class="headerlink" title="Stack and DFS 栈和深度优先搜索"></a>Stack and DFS 栈和深度优先搜索</h1><p>深度优先搜索（DFS）是用于在<code>树/图</code>中进行<code>遍历/搜索</code>的另一种算法。</p><p>在树的遍历中，可以用DFS进行<code>前序遍历、中序遍历和后序遍历</code>，这三种遍历的共同特点是<strong>除非到达最深的节点，否则不会回溯</strong>。</p><p>DFS和BFS的区别：BFS永远不会深入探索，除非已经遍历过当前层级的所有节点。</p><p>通常使用<code>递归</code>来实现DFS。</p><h2 id="栈和DFS"><a href="#栈和DFS" class="headerlink" title="栈和DFS"></a>栈和DFS</h2><p>DFS也可以用于查找从根节点到目标节点的路径。</p><p>（BFS是可以直接找到最短路径。）</p><p>如图所示：</p><p><img src="/2019/04/15/leetcode_explore_queue_stack/dfs.gif"></p><p>在上述例子中：</p><p>首先选择节点B的路径，到达E后无法深入，故回溯到A；再次选择节点C的路径，从C开始首先到达E，但E访问过，故回到C，并尝试F，最后找到了G。</p><p><strong>DFS中找到的第一条路径不一定是最短的路径。</strong></p><p>节点的处理和回溯过程是后进先出的处理顺序，和栈相同，故在DFS中多用栈来实现。</p><h2 id="DFS-模板1"><a href="#DFS-模板1" class="headerlink" title="DFS-模板1"></a>DFS-模板1</h2><p>大多可以使用BFS的情况也可以使用DFS，区别主要在遍历顺序。</p><p><strong>BFS找到的第一条路径为最短路径，而DFS不一定。</strong></p><p>有两种实现DFS的方法，第一种为递归。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">    <span class="keyword">for</span> (next : each neighbor of cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">true</span> <span class="keyword">if</span> <span class="title">DFS</span><span class="params">(next, target, visited)</span> </span>== <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用递归实现DFS时，使用的是系统提供的隐式栈，也称为call stack。</p><p>在每个堆栈元素中，都有一个当前值，一个目标值，一个访问过的数组的引用，和一个对数组边界的引用，这些就是DFS函数中的参数。栈的大小是DFS的深度，所以最坏情况下，维护系统占需要$O(h)$，其中$h$是DFS的最大深度。</p><p><strong>在计算空间复杂度时，要记得考虑系统栈。</strong></p></blockquote><h2 id="练习：岛屿的个数-1"><a href="#练习：岛屿的个数-1" class="headerlink" title="练习：岛屿的个数"></a>练习：岛屿的个数</h2><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>之前用BFS方法做过该题，主要是先遍历当前节点相邻的所有节点，之后继续查找下一个为’1’的点，重复上述过程。</p><p>此处用DFS方法递归遍历。</p><p>首先建立visited数组来记录某个位置是否访问过，对于为’1’且未曾访问过的位置，递归进入其上下左右位置上为’1’且未访问过的点，将其visited置为true，并继续进入其相连的相邻位置，直至周围没有为’1’的点，如此可将整个连通区域中所有的数都找到，将count数加一。之后再寻找下一个为’1’且未访问过的点，重复上述过程，直至遍历完整个grid数组。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid.size() == <span class="number">0</span> || grid[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录访问过的节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(grid.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(grid[<span class="number">0</span>].size(), <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 遍历grid中所有节点，遇到为1且为访问过的点，则递归遍历其所有相邻点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span> &amp;&amp; !visited[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    helper(grid, visited, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历x,y所有相邻的点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; grid.size() &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; grid[<span class="number">0</span>].size() &amp;&amp; grid[x][y] == <span class="string">'1'</span> &amp;&amp; !visited[x][y]) &#123;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            helper(grid, visited, x<span class="number">-1</span>, y);</span><br><span class="line">            helper(grid, visited, x+<span class="number">1</span>, y);</span><br><span class="line">            helper(grid, visited, x, y<span class="number">-1</span>);</span><br><span class="line">            helper(grid, visited, x, y+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：克隆图"><a href="#练习：克隆图" class="headerlink" title="练习：克隆图"></a>练习：克隆图</h2><p>给定无向<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin" target="_blank" rel="noopener"><strong>连通</strong></a>图中一个节点的引用，返回该图的<a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。图中的每个节点都包含它的值 <code>val</code>（<code>Int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><p><strong>示例：</strong></p><p><img src="/2019/04/15/leetcode_explore_queue_stack/113_sample.png" style="zoom: 80%"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>节点数介于 1 到 100 之间。</li><li>无向图是一个<a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%9B%BE/1680528?fr=aladdin" target="_blank" rel="noopener">简单图</a>，这意味着图中没有重复的边，也没有自环。</li><li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li><li>必须将<strong>给定节点的拷贝</strong>作为对克隆图的引用返回。</li></ol><p><strong>解题思路</strong></p><p>基本是图的遍历问题，使用DFS方法解答，要注意深度拷贝每个节点后，还要将其neighbors放到一个vector中，要注意避免重复拷贝。题意明确所有节点值不同，所以可使用map来存储已经拷贝过的节点（原节点和新的克隆节点一一对应）。</p><p>在递归函数中，首先判断节点是否为空，再看当前节点是否已经克隆过，若在map中存在则已经克隆过，直接返回其映射节点。否则就克隆当前节点，并在map中建立映射，并遍历该节点的所有neighbor节点，递归调用并实时更新map即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于存储原节点和新的克隆节点的对应，避免重复拷贝</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">        <span class="keyword">return</span> helper(node, m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">helper</span><span class="params">(Node* node, <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 当前节点已经克隆过，则返回其对应的克隆节点</span></span><br><span class="line">        <span class="keyword">if</span> (m.count(node))</span><br><span class="line">            <span class="keyword">return</span> m[node];</span><br><span class="line">        <span class="comment">// 当前节点没有克隆过：</span></span><br><span class="line">        <span class="comment">// 首先克隆当前节点，更新map</span></span><br><span class="line">        Node* clone = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">        m[node] = clone;</span><br><span class="line">        <span class="comment">// 克隆当前节点的所有neighbor节点，并实时更新map</span></span><br><span class="line">        <span class="keyword">for</span> (Node* neighbor : node-&gt;neighbors) &#123;</span><br><span class="line">            clone-&gt;neighbors.push_back(helper(neighbor, m));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回克隆后的节点</span></span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：目标和"><a href="#练习：目标和" class="headerlink" title="练习：目标和"></a>练习：目标和</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 <code>+</code> 和 <code>-</code>。对于数组中的任意一个整数，你都可以从 <code>+</code> 或 <code>-</code>中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数组的长度不会超过20，并且数组中的值全为正数。</li><li>初始的数组的和不会超过1000。</li><li>保证返回的最终结果为32位整数。</li></ol><p><strong>解题思路</strong></p><p>从第一个数字开始，调用递归函数，分别计算加当前值和减当前值之后的和，到数组结束时，比较当前和和目标值是否相等。（开始看网上的方法用目标和加/减当前值做递归的目标值来计算，结果在某个测试用例时提示超过int范围，，，）</p><p>参考测试用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1,1,1,1,1]</span><br><span class="line">3</span><br><span class="line">[2,107,109,113,127,131,137,3,2,3,5,7,11,13,17,19,23,29,47,53]</span><br><span class="line">2147483647</span><br><span class="line">[5,40,23,47,43,19,36,10,28,46,14,11,5,0,5,22,39,30,50,41]</span><br><span class="line">48</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S, <span class="keyword">int</span> index, <span class="keyword">int</span> curSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(index == size)</span><br><span class="line">            <span class="keyword">return</span> curSum==S ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        res += dfs(nums, S, index+<span class="number">1</span>, curSum+nums[index]);</span><br><span class="line">        res += dfs(nums, S, index+<span class="number">1</span>, curSum-nums[index]);</span><br><span class="line">        <span class="keyword">return</span> res;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中文版LeetCode提交上述代码时提示在上面第三个测试用例下超时，，，</p><p>使用数组记录中间值以减少重复计算。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="comment">// 记录中间值，map内容  当前可得到的中间结果，得到该结果的方法数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 初始dp的首值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 修改加减当前值之后可得到的中间结果及其方法数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : dp[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = a.first, cnt = a.second;</span><br><span class="line">                dp[i + <span class="number">1</span>][sum + nums[i]] += cnt;</span><br><span class="line">                dp[i + <span class="number">1</span>][sum - nums[i]] += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从最终的总方法数中，找到目标值对应的方法数</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][S];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="DFS-模板2"><a href="#DFS-模板2" class="headerlink" title="DFS-模板2"></a>DFS-模板2</h2><p>递归虽然容易实现，但如果深度太高，容易栈溢出。这时可能希望使用BFS，或者用显式栈来实现DFS。</p><p>显式栈模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    Stack&lt;Node&gt; s;</span><br><span class="line">    add root to s;</span><br><span class="line">    <span class="keyword">while</span> (s is not empty) &#123;</span><br><span class="line">        Node cur = the top element in s;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">        <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">                add next to s;</span><br><span class="line">                add next to visited;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        remove cur from s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法使用<code>while</code>和<code>栈</code>来模拟递归时的<code>系统调用栈</code>。</p><h2 id="练习：二叉树的中序遍历"><a href="#练习：二叉树的中序遍历" class="headerlink" title="练习：二叉树的中序遍历"></a>练习：二叉树的中序遍历</h2><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p><strong>解题思路</strong></p><p>中序遍历：先遍历左子树，然后访问值，再遍历右子树。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !temp.empty()) &#123;</span><br><span class="line">            <span class="comment">// 递归直至最左，将所有左节点入栈</span></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                temp.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 栈顶节点是最左节点</span></span><br><span class="line">            <span class="comment">// 开始出栈，且输出栈顶节点</span></span><br><span class="line">            <span class="keyword">if</span> (!temp.empty()) &#123;</span><br><span class="line">                root = temp.top();</span><br><span class="line">                result.push_back(root-&gt;val);</span><br><span class="line">                temp.pop();</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>队列</p><p><strong>队列</strong>是<strong>FIFO</strong>的数据结构，首先处理第一个元素；</p><p>队列两个重要操作：入队和出队；</p><p>可以用带有两个指针的动态数组来实现队列；</p><p><strong>BFS</strong>方法常使用队列结构；</p></li><li><p>栈</p><p><strong>栈</strong>是<strong>LIFO</strong>的数据结构，首先处理最后一个元素；</p><p>栈两个重要操作：push和pop；</p><p>使用动态数组可以实现栈；</p><p><strong>DFS</strong>是栈的一个重要应用。</p></li></ul><h2 id="练习：用栈实现队列"><a href="#练习：用栈实现队列" class="headerlink" title="练习：用栈实现队列"></a>练习：用栈实现队列</h2><p>使用栈实现队列的下列操作：</p><ul><li>push(x) — 将一个元素放入队列的尾部。</li><li>pop() — 从队列首部移除元素。</li><li>peek() — 返回队列首部的元素。</li><li>empty() — 返回队列是否为空。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // 返回 1</span><br><span class="line">queue.pop();   // 返回 1</span><br><span class="line">queue.empty(); // 返回 false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>你只能使用标准的栈操作 — 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><p><strong>解题思路</strong></p><p>栈后进先出，队列先进先出。所以，在push的时候，借用一个额外的临时栈，首先将队列内原有元素挨个pop到临时栈（临时栈的顺序和构造的队列内顺序相反），再将新值push到临时栈，此时临时栈和要构造的队列元素顺序相反，新值在尾端。最后将临时栈再挨个pop到要构造的队列（实际也是用栈实现的）中，达到元素逆序的目的。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; _stk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span>(!_stk.empty()) &#123;</span><br><span class="line">            temp.push(_stk.top());</span><br><span class="line">            _stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        temp.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!temp.empty()) &#123;</span><br><span class="line">            _stk.push(temp.top());</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = _stk.top();</span><br><span class="line">        _stk.pop();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="练习：用队列实现栈"><a href="#练习：用队列实现栈" class="headerlink" title="练习：用队列实现栈"></a>练习：用队列实现栈</h2><p>使用队列实现栈的下列操作：</p><ul><li>push(x) — 元素 x 入栈</li><li>pop() — 移除栈顶元素</li><li>top() — 获取栈顶元素</li><li>empty() — 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作— 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><p><strong>解题思路</strong></p><p>和用栈实现队列的思路类似，push过程借用一个临时队列。需要注意的是，队列先入先出，所以此处要实现栈后入先出的目的，push的新值需要先插入临时队列，以保证pop时后插入的值可以先出去。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _que;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        temp.push(x); <span class="comment">// 新值先插入到临时队列中</span></span><br><span class="line">        <span class="keyword">while</span>(!_que.empty()) &#123;</span><br><span class="line">            temp.push(_que.front());</span><br><span class="line">            _que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!temp.empty()) &#123;</span><br><span class="line">            _que.push(temp.front());</span><br><span class="line">            temp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = _que.front();</span><br><span class="line">        _que.pop();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _que.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _que.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="练习：字符串解码"><a href="#练习：字符串解码" class="headerlink" title="练习：字符串解码"></a>练习：字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>用栈，类似括号匹配，发现右括号时，开始出栈直至发现左括号，获取括号中要重复的内容，再出栈一次获取重复次数，之后将该字段重复指定次数后再入栈，直至遍历结束。将栈内容出栈，并按照指定顺序拼接成结果字符串返回即可。</p><p>注意的是，重复次数可能不是一位数字，所以在入栈时，对于连续的数字要拼接到一起再入栈。</p><p>使用的几个测试用例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"3[a]2[bc]"</span></span><br><span class="line"><span class="string">"100[leetcode]"</span></span><br><span class="line"><span class="string">"3[a2[c]]"</span></span><br><span class="line"><span class="string">"2[abc]3[cd]ef"</span></span><br><span class="line"><span class="string">"2[abc]30[cd]ef"</span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; s.size(); idx++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[idx] != <span class="string">']'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[idx])) &#123; <span class="comment">// 发现数字</span></span><br><span class="line"><span class="keyword">int</span> begin = idx;</span><br><span class="line">idx++;</span><br><span class="line">                    <span class="comment">// 找到下一个不为数字的位置</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[idx])) &#123;</span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">// 插入多位数字</span></span><br><span class="line">stk.push(s.substr(begin, idx - begin));</span><br><span class="line">&#125;</span><br><span class="line">stk.push(<span class="built_in">string</span>(<span class="number">1</span>, s[idx]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">// 获取要重复的内容</span></span><br><span class="line"><span class="built_in">string</span> temp = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (stk.top() != <span class="string">"["</span>) &#123;</span><br><span class="line">temp = stk.top() + temp;</span><br><span class="line">stk.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "[" 出栈</span></span><br><span class="line">stk.pop();</span><br><span class="line">                <span class="comment">// 获取重复次数</span></span><br><span class="line"><span class="keyword">int</span> num = stoi(stk.top());</span><br><span class="line">stk.pop();</span><br><span class="line">                <span class="comment">// 重复内容，并将结果再次入栈</span></span><br><span class="line"><span class="built_in">string</span> cur = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">cur += temp;</span><br><span class="line">&#125;</span><br><span class="line">stk.push(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">result = stk.top() + result;</span><br><span class="line">stk.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：图像渲染"><a href="#练习：图像渲染" class="headerlink" title="练习：图像渲染"></a>练习：图像渲染</h2><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">image = [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr = 1, sc = 1, newColor = 2</span><br><span class="line">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)=(1,1)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class="line">注意，右下角的像素没有更改为2，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li><li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li><li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li></ul><p><strong>解题思路</strong></p><p>和前面<code>岛屿的个数</code>类似，主要找到与初始点颜色相同且相连的节点，将其着色返回即可。</p><p>采用BFS或DFS递归均可，此处使用BFS，首先初始点标记访问、修改颜色、入队，后遍历其相邻节点，将颜色相同的相邻点标记访问、修改颜色、入队。直至队列为空，说明与初始点相连接的所有点均遍历结束，则返回。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="comment">// int row = image.size();</span></span><br><span class="line">        <span class="comment">// int col = row &gt; 0 ? image[0].size() : 0;</span></span><br><span class="line">        <span class="comment">// if (row == 0 || col == 0)</span></span><br><span class="line">        <span class="comment">//     return image;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 题设row col长度范围在[1,50]，所以省掉额外判断</span></span><br><span class="line">        <span class="keyword">int</span> row = image.size();</span><br><span class="line">        <span class="keyword">int</span> col = image[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录访问过的节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(row, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 记录相邻且相连的节点</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 查看上下左右的节点用</span></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 记录初始点颜色</span></span><br><span class="line">        <span class="keyword">int</span> tag = image[sr][sc];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始点入队，标记访问，修改初始点颜色</span></span><br><span class="line">        q.push(&#123;sr, sc&#125;);</span><br><span class="line">        visited[sr][sc] = <span class="literal">true</span>;</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历相邻且颜色相同的点</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> head = q.front(); <span class="comment">// 获取首元素及坐标</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> ox = head.first;</span><br><span class="line">            <span class="keyword">int</span> oy = head.second;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历上下左右的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = ox + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny = oy + dy[i];</span><br><span class="line">                <span class="comment">// 如果该节点在矩阵范围内，且颜色和初始点相同，则修改其颜色为newcolor，并标记访问，入队</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny &lt; col &amp;&amp; image[nx][ny] == tag &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">                    image[nx][ny] = newColor;</span><br><span class="line">                    visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：01矩阵"><a href="#练习：01矩阵" class="headerlink" title="练习：01矩阵"></a>练习：01矩阵</h2><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p><strong>示例 1:</strong><br>输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong><br>输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>给定矩阵的元素个数不超过 10000。</li><li>给定矩阵中至少有一个元素是 0。</li><li>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</li></ol><p><strong>解题思路</strong></p><p>找到最近的0的距离，是最短路径问题，用BFS。</p><p>类比前面 walls and gates ，首先将原矩阵中所有值为0的点入队，值为1的点设为无限大INT_MAX（为了后续比较最小距离）。</p><p>遍历queue中节点的相邻节点，若该相邻节点的值大于当前节点值加1，则将其修改为当前值加1，且将该相邻节点入队，否则跳过（当相邻节点距离更小的时候，不需要更新），直至队列为空结束。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line"><span class="keyword">int</span> row = matrix.size();</span><br><span class="line"><span class="keyword">int</span> col = row &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历当前节点相邻的节点</span></span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">// 上下左右节点</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原矩阵，值为0的入队，值为1的将距离设为无限大INT_MAX</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">q.push(&#123; i,j &#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">matrix[i][j] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历队列内值，即所有为0的点，从相邻节点中找非零点，如果值比当前点值加一大，则修改为当前值加一，且该相邻节点入队</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">auto</span> head = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="comment">// 遍历周围节点</span></span><br><span class="line"><span class="keyword">int</span> ox = head.first;</span><br><span class="line"><span class="keyword">int</span> oy = head.second;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> nx = ox + dx[k];</span><br><span class="line"><span class="keyword">int</span> ny = oy + dy[k];</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; <span class="number">0</span> &lt;= ny &amp;&amp; ny&lt;col &amp;&amp; matrix[nx][ny]&gt;matrix[ox][oy] + <span class="number">1</span>) &#123;</span><br><span class="line">matrix[nx][ny] = matrix[ox][oy] + <span class="number">1</span>;</span><br><span class="line">q.push(&#123; nx, ny &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：钥匙和房间"><a href="#练习：钥匙和房间" class="headerlink" title="练习：钥匙和房间"></a>练习：钥匙和房间</h2><p>有 <code>N</code> 个房间，开始时你位于 <code>0</code> 号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p><p>在形式上，对于每个房间 <code>i</code> 都有一个钥匙列表 <code>rooms[i]</code>，每个钥匙 <code>rooms[i][j]</code> 由 <code>[0,1，...，N-1]</code> 中的一个整数表示，其中 <code>N = rooms.length</code>。 钥匙 <code>rooms[i][j] = v</code> 可以打开编号为 <code>v</code> 的房间。</p><p>最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。</p><p>你可以自由地在房间之间来回走动。</p><p>如果能进入每个房间返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1],[2],[3],[]]</span><br><span class="line">输出: true</span><br><span class="line">解释:  </span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,3],[3,0,1],[2],[0]]</span><br><span class="line">输出：false</span><br><span class="line">解释：我们不能进入 2 号房间。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= rooms.length &lt;= 1000</code></li><li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li><li>所有房间中的钥匙数量总计不超过 <code>3000</code>。</li></ol><p><strong>解题思路</strong></p><p>用栈实现，并且维护一个长度N的数组标记房间是否能够打开。</p><p>首先将0号房间的钥匙全部入栈，之后挨个出栈，并且判断当前的钥匙对应的房间是否已经打开，如果已经打开就跳过，如果是第一次打开，就将该房间的钥匙入栈，并标记该房间。</p><p>到栈为空时，如果标记房间的数组值全为true，则返回true，否则返回false。</p><p>同样的思路，用队列也可以，队列是BFS，栈的话就是DFS。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(rooms.size(), <span class="number">0</span>);</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; keys;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 0号房间的钥匙入栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> key : rooms[<span class="number">0</span>]) &#123;</span><br><span class="line">            keys.push(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历栈中所有钥匙，标记可打开的房间</span></span><br><span class="line">        <span class="keyword">while</span> (!keys.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = keys.top();</span><br><span class="line">            keys.pop();</span><br><span class="line">            <span class="keyword">if</span> (visited[key] == <span class="number">0</span>) &#123; <span class="comment">// 该房间之前没有打开过</span></span><br><span class="line">                visited[key] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> temp : rooms[key]) &#123;</span><br><span class="line">                    keys.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有钥匙遍历结束，看visited中是否有没有打开的房间</span></span><br><span class="line">        <span class="keyword">return</span> find(visited.begin(), visited.end(), <span class="number">0</span>) == visited.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考自LeetCode上Explore模块的&lt;a href=&quot;https://leetcode.com/explore/learn/card/queue-stack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Queue &amp;amp; Stack&lt;/a&gt;，作为笔记记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Overview-综述&quot;&gt;&lt;a href=&quot;#Overview-综述&quot; class=&quot;headerlink&quot; title=&quot;Overview 综述&quot;&gt;&lt;/a&gt;Overview 综述&lt;/h1&gt;&lt;p&gt;主要了解两种不同的元素处理顺序：先入先出（FIFO）和后入先出（LIFO）；以及两个相应的线性数据结构：队列（Queue）和栈（Stack）。&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="https://lesley0416.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="深度优先搜索" scheme="https://lesley0416.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="队列" scheme="https://lesley0416.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="栈" scheme="https://lesley0416.github.io/tags/%E6%A0%88/"/>
    
      <category term="Queue" scheme="https://lesley0416.github.io/tags/Queue/"/>
    
      <category term="Stack" scheme="https://lesley0416.github.io/tags/Stack/"/>
    
      <category term="广度优先搜索" scheme="https://lesley0416.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="BFS" scheme="https://lesley0416.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="https://lesley0416.github.io/tags/DFS/"/>
    
      <category term="FIFO" scheme="https://lesley0416.github.io/tags/FIFO/"/>
    
      <category term="LIFO" scheme="https://lesley0416.github.io/tags/LIFO/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】Explore：Binary Tree 二叉树</title>
    <link href="https://lesley0416.github.io/2019/04/02/leetcode_explore_binary_tree/"/>
    <id>https://lesley0416.github.io/2019/04/02/leetcode_explore_binary_tree/</id>
    <published>2019-04-02T01:44:50.000Z</published>
    <updated>2019-04-09T07:28:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考自LeetCode上Explore模块的<a href="https://leetcode.com/explore/learn/card/data-structure-tree/" target="_blank" rel="noopener">Binary Tree</a>，作为笔记记录。</p></blockquote><h1 id="Overview-综述"><a href="#Overview-综述" class="headerlink" title="Overview 综述"></a>Overview 综述</h1><p><code>树</code>可以视为包含N个节点和N-1条边的有向无环图。</p><p><code>二叉树</code>是每个节点最多有两个子树的树结构，子树称为左子树和右子树。</p><a id="more"></a><h1 id="Traverse-A-Tree-树的遍历"><a href="#Traverse-A-Tree-树的遍历" class="headerlink" title="Traverse A Tree 树的遍历"></a>Traverse A Tree 树的遍历</h1><p>主要内容：</p><ol><li>理解和区分树的遍历方法</li><li>能够运用<code>递归</code>方法解决树的为前序遍历、中序遍历和后序遍历问题</li><li>能用运用<code>迭代</code>方法解决树的为前序遍历、中序遍历和后序遍历问题</li><li>能用运用<code>广度优先</code>搜索解决树的<code>层序遍历</code>问题</li></ol><h2 id="树的遍历介绍"><a href="#树的遍历介绍" class="headerlink" title="树的遍历介绍"></a>树的遍历介绍</h2><blockquote><p>前中后序主要是看根节点什么时候访问。</p></blockquote><h3 id="前序遍历（Pre-order-Traversal）"><a href="#前序遍历（Pre-order-Traversal）" class="headerlink" title="前序遍历（Pre-order Traversal）"></a>前序遍历（Pre-order Traversal）</h3><p><strong>前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。</strong></p><p><img src="/2019/04/02/leetcode_explore_binary_tree/pre_order_traversal.gif"></p><h3 id="中序遍历（In-order-Traversal）"><a href="#中序遍历（In-order-Traversal）" class="headerlink" title="中序遍历（In-order Traversal）"></a>中序遍历（In-order Traversal）</h3><p><strong>中序遍历首先遍历左子树，然后访问根节点，最后遍历右子树。</strong></p><p><img src="/2019/04/02/leetcode_explore_binary_tree/in_order_traversal.gif"></p><p>一般，对于二叉搜索树，可以通过中序遍历得到一个递增的有序序列。</p><h3 id="后序遍历（Post-order-Traversal）"><a href="#后序遍历（Post-order-Traversal）" class="headerlink" title="后序遍历（Post-order Traversal）"></a>后序遍历（Post-order Traversal）</h3><p><strong>后序遍历首先遍历左子树，然后遍历右子树，最后访问根节点。</strong></p><p><img src="/2019/04/02/leetcode_explore_binary_tree/post_order_traversal.gif"></p><p><strong>删除树中的节点的时候</strong>，删除过程将按照后序遍历的顺序进行。即，删除一个节点时，将首先删除其左节点和右节点，然后再删除节点本身。</p><p><strong>数学表达式中</strong>，可以用中序遍历找出原始表达式，但是解析处理的时候，使用后序遍历更容易，每遇到一个操作符就从栈中弹出栈顶的两个元素进行计算，将计算结果返回栈中。</p><h2 id="递归和迭代实现树的遍历"><a href="#递归和迭代实现树的遍历" class="headerlink" title="递归和迭代实现树的遍历"></a>递归和迭代实现树的遍历</h2><p>递归：程序返回一个函数，这个函数继续返回一个函数，直至达到最初的递归终止条件，然后一步步返回，最终得到结果；</p><p>迭代：在给定条件下直接循环计算，从小到大直至返回最终结果；</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p> <strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure><h4 id="递归实现："><a href="#递归实现：" class="headerlink" title="递归实现："></a>递归实现：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        result.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = preorderTraversal(root-&gt;left);</span><br><span class="line">        result.insert(result.end(),temp.begin(),temp.end());</span><br><span class="line">        </span><br><span class="line">        temp = preorderTraversal(root-&gt;right);</span><br><span class="line">        result.insert(result.end(),temp.begin(),temp.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代实现："><a href="#迭代实现：" class="headerlink" title="迭代实现："></a>迭代实现：</h4><p>前序遍历先访问根节点，之后访问左子树和右子树。</p><p>对于任一节点，可以看做是根节点直接访问，访问结束后，如果左子树非空，则同样规则访问左子树，到达最左后，再访问右子树。</p><ul><li>从根节点开始遍历，同时输出根节点；</li><li>递归输出直至最左；</li><li>到达最左后，访问右节点；</li></ul><p>因此处理过程如下：</p><p>对于任一节点P：</p><ul><li>访问节点P，并将节点P入栈；</li><li>判断节点P的左子树是否为空，为空则取栈顶节点，并进行出栈操作，并将栈顶节点的右孩子置为当前的节点P，循环至1；若不为空，则将P的左孩子置为当前的节点P；</li><li>直至P为NULL且栈为空，则遍历结束；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">            <span class="comment">// 输出当前子树的根节点，然后递归直至最左</span></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                result.push_back(root-&gt;val);</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环结束时，栈顶节点已经是最左节点</span></span><br><span class="line">            <span class="comment">// 开始出栈，并输出节点的右节点</span></span><br><span class="line">            <span class="keyword">if</span>(!s.empty()) &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><h4 id="递归实现：-1"><a href="#递归实现：-1" class="headerlink" title="递归实现："></a>递归实现：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = inorderTraversal(root-&gt;left);</span><br><span class="line">        result.insert(result.end(), temp.begin(), temp.end());</span><br><span class="line">        </span><br><span class="line">        result.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        temp = inorderTraversal(root-&gt;right);</span><br><span class="line">        result.insert(result.end(), temp.begin(), temp.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代实现：-1"><a href="#迭代实现：-1" class="headerlink" title="迭代实现："></a>迭代实现：</h4><p>中序遍历先访问左子树，再访问根节点和右子树。</p><p>对于任一节点，优先访问左节点，左节点可视为又一根节点，继续访问其左子树，直至到最左节点，之后按相同规则访问右子树。</p><ul><li>从根节点开始遍历；</li><li>递归直至最左，然后输出（中序遍历首先输出的是最左叶子节点）；</li><li>到达最左后，访问右节点。</li></ul><p>处理过程如下：</p><p>对于任一节点P：</p><ul><li>若左子树不空，则将P入栈并将P的左孩子置为当前节点P，再对当前节点P进行相同处理；</li><li>若左子树为空，则取栈顶元素并进行出栈操作，访问栈顶节点，并将当前节点P置为栈顶节点的右孩子；</li><li>直至P为NULL或栈为空则结束遍历。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">            <span class="comment">// 不输出当前根节点，递归直至最左</span></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 栈顶节点是最左节点</span></span><br><span class="line">            <span class="comment">// 开始出栈，且输出栈顶节点</span></span><br><span class="line">            <span class="keyword">if</span>(!s.empty()) &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                result.push_back(root-&gt;val);</span><br><span class="line">                s.pop();</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><h4 id="递归实现：-2"><a href="#递归实现：-2" class="headerlink" title="递归实现："></a>递归实现：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = postorderTraversal(root-&gt;left);</span><br><span class="line">        result.insert(result.end(), temp.begin(), temp.end());</span><br><span class="line">        </span><br><span class="line">        temp = postorderTraversal(root-&gt;right);</span><br><span class="line">        result.insert(result.end(), temp.begin(), temp.end());</span><br><span class="line">        </span><br><span class="line">        result.push_back(root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代实现：-2"><a href="#迭代实现：-2" class="headerlink" title="迭代实现："></a>迭代实现：</h4><p>后序遍历是先访问左子树和右子树，最后访问根节点。</p><p>后序遍历比前序和中序要相对复杂，因为要保证左子树和右子树都已经被访问，并且左子树在右子树之前被访问，之后才能访问根节点。</p><p>所以按照之前前序和中序的思路，在流程控制上需要做一定调整。</p><p>处理过程如下：</p><ul><li>对于任一节点P，将其入栈，并沿左子树遍历到最左节点，此时该节点在栈顶，但不能出栈访问，因为还没有访问右子树。</li><li>按照相同规则访问右子树，当访问完右子树后，这个节点又出现在栈顶，此时可以将其出栈并访问，从而保证正确的访问顺序。</li><li>由上可知，每个节点会两次出现在栈顶，只有第二次出现在栈顶的时候才可以访问并出栈，因此需要多设置一个变量来标识节点是否第一次出现在栈顶。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">bool</span>&gt; visited; <span class="comment">// 用于标记访问过的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">            <span class="comment">// 递归直至最左</span></span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">                visited[root] = <span class="literal">true</span>; <span class="comment">// 当前节点首次被访问</span></span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 栈顶节点是最左节点</span></span><br><span class="line">            <span class="keyword">if</span>(!s.empty()) &#123;</span><br><span class="line">                root = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(visited[root]) <span class="comment">// 第一次出现在栈顶</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 再重新入栈，访问右子树</span></span><br><span class="line">                    s.push(root);</span><br><span class="line">                    visited[root] = <span class="literal">false</span>;</span><br><span class="line">                    root = root-&gt;right; <span class="comment">// 改变当前节点P的操作要在visited[root]修改之后</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 第二次出现在栈顶</span></span><br><span class="line">                &#123;</span><br><span class="line">                    result.push_back(root-&gt;val);</span><br><span class="line">                    root = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p><strong>层序遍历就是逐层遍历树结构。</strong></p><p>使用广度优先搜索遍历树时，就是按照层序遍历顺序进行的：从一个根节点开始，首先访问节点本身，之后遍历其相邻节点，其次遍历其二级邻节点、三级邻节点，以此类推。</p><p>过程如下图所示：</p><p><img src="/2019/04/02/leetcode_explore_binary_tree/level_order_traversal.gif"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>使用<strong>队列</strong>来辅助实现。用队列记录当前一层的节点，从根节点开始。每次遍历完一层时，先计算队列中的元素数量size，用size控制之后要处理的节点数量（因为每次处理一个节点的时候，会将其左右子节点压入队列，所以队列中会加入下一层的节点，所以需要通过size来控制当前层要处理的节点数量）。所有节点处理结束后，队列为空，则遍历结束。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root); <span class="comment">// 从根节点开始处理</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp; <span class="comment">// 临时记录当前层的节点</span></span><br><span class="line">            <span class="keyword">auto</span> size=q.size(); <span class="comment">// 用size控制队列中要处理的当前层节点数量</span></span><br><span class="line">            <span class="keyword">while</span>(size--) &#123;</span><br><span class="line">                TreeNode* node = q.front(); <span class="comment">// 从先入队列的节点开始处理</span></span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) <span class="comment">// 将该节点的左孩子压入队列</span></span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) <span class="comment">// 将该节点的右孩子压入队列</span></span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                temp.push_back(node-&gt;val); <span class="comment">// 记录当前节点值</span></span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(temp); <span class="comment">// 当前层处理结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Solve-Problems-Recursively-运用递归解决问题"><a href="#Solve-Problems-Recursively-运用递归解决问题" class="headerlink" title="Solve Problems Recursively 运用递归解决问题"></a>Solve Problems Recursively 运用递归解决问题</h1><p>主要内容：</p><p>介绍两种典型的递归方法，练习使用基础的递归方法解决二叉树相关问题。</p><h2 id="运用递归解决树的问题"><a href="#运用递归解决树的问题" class="headerlink" title="运用递归解决树的问题"></a>运用递归解决树的问题</h2><p>递归是树的特性之一，许多树的问题可以通过递归的方式来解决。</p><h3 id="自顶向下的解决方案"><a href="#自顶向下的解决方案" class="headerlink" title="自顶向下的解决方案"></a>自顶向下的解决方案</h3><p>自顶向下可以认为是一种前序遍历，在每个递归层级，先访问节点进行计算，然后递归调用的时候将值传递到子节点。</p><p>原理如下：</p><blockquote><ol><li>return specific value for null node</li><li>update the answer if needed                                 // anwer &lt;— params</li><li>left_ans = top_down(root.left, left_params)         // left_params &lt;— root.val, params</li><li>right_ans = top_down(root.right, right_params) // right_params &lt;— root.val, params</li><li>return the answer if needed                                  // answer &lt;— left_ans, right_ans</li></ol></blockquote><p>例如，给定二叉树，寻找其最大深度。</p><p>用递归函数<code>maximun_depth(root, depth)</code>自顶向下解决该问题，每向下一层深度就加1，最终比较所有叶子节点处的最大深度即可，伪代码如下：</p><blockquote><ol><li><p>return if root is null</p></li><li><p>if root is a leaf node:</p><p>​    answer = max(answer, depth)            // update the answer if needed</p></li><li><p>maximum_depth(root.left, depth + 1)       // call the function recursively for left child</p></li><li><p>maximum_depth(root.right, depth + 1)     // call the function recursively for right child</p></li></ol></blockquote><p>如图所示：</p><p><img src="/2019/04/02/leetcode_explore_binary_tree/find_max_depth.gif"></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> answer;<span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        answer = max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自底向上的解决方案"><a href="#自底向上的解决方案" class="headerlink" title="自底向上的解决方案"></a>自底向上的解决方案</h3><p>自底向上可以看过是后序遍历的一种，在每个递归层次上，首先对所有子节点做递归调用，然后根据返回值和根节点本身的值得到最终答案。</p><p>原理如下：</p><blockquote><ol><li>return specific value for null node</li><li>left_ans = bottom_up(root.left)                           // call function recursively for left child</li><li>right_ans = bottom_up(root.right)                      // call function recursively for right child</li><li>return answers</li></ol></blockquote><p>同样以二叉树最大深度为例。</p><p>用递归函数<code>maximun_depth(root)</code>自底向上的解决该问题，对于树的某个节点，比较其左节点和右节点的最大深度，再加1即可，也就是对于每个节点，都可以在解决其子节点问题之后得到答案，伪代码如下：</p><blockquote><ol><li>return 0 if root is null                                        // return 0 for null node</li><li>left_depth = maximum_depth(root.left)</li><li>right_depth = maximum_depth(root.right)</li><li>return max(left_depth, right_depth) + 1        // return depth of the subtree rooted at root</li></ol></blockquote><p>如图所示：</p><p><img src="/2019/04/02/leetcode_explore_binary_tree/find_max_depth_bottom_up.gif"></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                                 <span class="comment">// return 0 for null node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left_depth = maximum_depth(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> right_depth = maximum_depth(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> max(left_depth, right_depth) + <span class="number">1</span>;  <span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当遇到树问题时，请先思考一下两个问题：</p><ol><li>你能确定一些参数，从该节点自身解决出发寻找答案吗？</li><li>你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？</li></ol><p>如果答案都是肯定的，那么请尝试使用 “<code>自顶向下</code>” 的递归来解决此问题。</p><p>或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “<code>自底向上</code>” 的递归可能是一个不错的解决方法。</p><h2 id="练习：二叉树最大深度"><a href="#练习：二叉树最大深度" class="headerlink" title="练习：二叉树最大深度"></a>练习：二叉树最大深度</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p>代码如下（自底向上递归实现）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (leftDepth &gt; rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：对称二叉树"><a href="#练习：对称二叉树" class="headerlink" title="练习：对称二叉树"></a>练习：对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><blockquote><p>官方给出的两种题解思路</p></blockquote><p><strong>递归方法</strong></p><p>如果一个树的左右子树互为镜像，则这棵树是对称的。</p><p>当两棵树满足如下条件时，互为镜像：</p><ol><li>两个根节点有相同的值；</li><li>每棵树的左子树都和另一棵树的右子树镜像对称；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>) <span class="comment">// 两个都空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">NULL</span> || t2 == <span class="literal">NULL</span>) <span class="comment">// 一个空，一个不空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 两个都不空</span></span><br><span class="line">        <span class="keyword">return</span> (t1-&gt;val==t2-&gt;val) &amp;&amp; isMirror(t1-&gt;left,t2-&gt;right) &amp;&amp; isMirror(t1-&gt;right, t2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代方法</strong></p><p>用<strong>队列</strong>进行迭代，队列中每两个相邻的值应该是相等的，且其子树也互为镜像。队列由两个连续的<code>root</code>节点开始。每次提取两个节点进行比较，然后<strong>把两个节点的左右子节点按相反顺序插入队列</strong>。队列为空，或检测到不对称时，算法结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="comment">// 队列以两个连续的root开始</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            TreeNode* t1 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode* t2 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(t1==<span class="literal">NULL</span> &amp;&amp; t2==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1==<span class="literal">NULL</span> || t2==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 左右子节点按相反顺序插入队列</span></span><br><span class="line">            q.push(t1-&gt;left);</span><br><span class="line">            q.push(t2-&gt;right);</span><br><span class="line">            q.push(t1-&gt;right);</span><br><span class="line">            q.push(t2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：路径综合"><a href="#练习：路径综合" class="headerlink" title="练习：路径综合"></a>练习：路径综合</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure><p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val==sum;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>多练习就对了，，，</p><h2 id="练习：从中序与后序遍历序列构造二叉树"><a href="#练习：从中序与后序遍历序列构造二叉树" class="headerlink" title="练习：从中序与后序遍历序列构造二叉树"></a>练习：从中序与后序遍历序列构造二叉树</h2><blockquote><p>【LeetCode】106</p></blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder = [9,15,7,20,3]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>中序遍历结果为<code>左中右</code>，后序遍历结果为<code>左右中</code>，题目假设树中没有重复元素，则可以先用后序遍历结果的尾值确定当前根节点P，在中序遍历中找到当前根节点P（假设位置为$n$），并将其分为左右两个子树（根节点P左侧为左孩子，右侧为右孩子，两个子树为$inorder[:n] , inorder[n+1:]$）。根据这个划分位置$n$，再将后序遍历序列也分隔成两部分（两部分为$postorder[:n] , postorder[n:-1]$），之后递归构造左右子树。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> instart, <span class="keyword">int</span> inend, <span class="keyword">int</span> poststart, <span class="keyword">int</span> postend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(poststart &gt; postend)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 后序遍历的尾值作为当前根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(postorder[postend]);</span><br><span class="line">        <span class="comment">// 在中序遍历中找到当前根节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> idx = instart;</span><br><span class="line">        <span class="keyword">while</span>(inorder[idx] != postorder[postend])</span><br><span class="line">            idx++;</span><br><span class="line">        <span class="comment">// 将中序遍历和后序遍历序列分别划分为两部分，并递归构造左右子树</span></span><br><span class="line">        root-&gt;left = build(inorder, postorder, instart, idx<span class="number">-1</span>, poststart, poststart+idx<span class="number">-1</span>-instart);</span><br><span class="line">        root-&gt;right = build(inorder, postorder, idx+<span class="number">1</span>, inend, poststart+idx-instart, postend<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 完全构造结束，返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, postorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>, <span class="number">0</span>, postorder.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：从前序与中序遍历序列构造二叉树"><a href="#练习：从前序与中序遍历序列构造二叉树" class="headerlink" title="练习：从前序与中序遍历序列构造二叉树"></a>练习：从前序与中序遍历序列构造二叉树</h2><blockquote><p>【LeetCode】105</p></blockquote><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>前序遍历结果为<code>中左右</code>，中序遍历结果为<code>左中右</code>，可以按照前面中序和后序构造二叉树的方法进行。</p><p>首先取前序遍历结果的首值作为当前根节点P，并在中序遍历结果中找到当前根节点P的位置$n$，并以此为依据，将中序遍历序列划分为左右两个子树$inorder[:n] , inorder[n+1:]$。同时根据这个位置$n$，再将前序遍历序列也划分为两部分$preorder[1:n+1] , preorder[n+1:]$。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> prestart, <span class="keyword">int</span> preend, <span class="keyword">int</span> instart, <span class="keyword">int</span> inend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prestart &gt; preend)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 前序遍历首值作为当前根节点</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[prestart]);</span><br><span class="line">        <span class="comment">// 在中序遍历序列中找到当前根节点位置</span></span><br><span class="line">        <span class="keyword">int</span> idx = instart;</span><br><span class="line">        <span class="keyword">while</span>(inorder[idx] != preorder[prestart])</span><br><span class="line">            idx++;</span><br><span class="line">        <span class="comment">// 将前序遍历和中序遍历序列分别划分为两部分，并递归构造左右子树</span></span><br><span class="line">        root-&gt;left = build(preorder, inorder, prestart+<span class="number">1</span>, prestart+idx-instart, instart, idx<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = build(preorder, inorder, prestart+idx-instart+<span class="number">1</span>, preend, idx+<span class="number">1</span>, inend);</span><br><span class="line">        <span class="comment">// 完全构造结束，返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, inorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, <span class="number">0</span>, inorder.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：填充每个节点的下一个右侧节点指针"><a href="#练习：填充每个节点的下一个右侧节点指针" class="headerlink" title="练习：填充每个节点的下一个右侧节点指针"></a>练习：填充每个节点的下一个右侧节点指针</h2><blockquote><p>【LeetCode】116</p></blockquote><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>示例：</strong></p><p><img src="/2019/04/02/leetcode_explore_binary_tree/116_sample.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;<span class="string">"$id"</span>:<span class="string">"1"</span>,<span class="string">"left"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"2"</span>,<span class="string">"left"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"3"</span>,<span class="string">"left"</span>:null,<span class="string">"next"</span>:null,<span class="string">"right"</span>:null,<span class="string">"val"</span>:<span class="number">4</span>&#125;,<span class="string">"next"</span>:null,<span class="string">"right"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"4"</span>,<span class="string">"left"</span>:null,<span class="string">"next"</span>:null,<span class="string">"right"</span>:null,<span class="string">"val"</span>:<span class="number">5</span>&#125;,<span class="string">"val"</span>:<span class="number">2</span>&#125;,<span class="string">"next"</span>:null,<span class="string">"right"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"5"</span>,<span class="string">"left"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"6"</span>,<span class="string">"left"</span>:null,<span class="string">"next"</span>:null,<span class="string">"right"</span>:null,<span class="string">"val"</span>:<span class="number">6</span>&#125;,<span class="string">"next"</span>:null,<span class="string">"right"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"7"</span>,<span class="string">"left"</span>:null,<span class="string">"next"</span>:null,<span class="string">"right"</span>:null,<span class="string">"val"</span>:<span class="number">7</span>&#125;,<span class="string">"val"</span>:<span class="number">3</span>&#125;,<span class="string">"val"</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">输出：&#123;<span class="string">"$id"</span>:<span class="string">"1"</span>,<span class="string">"left"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"2"</span>,<span class="string">"left"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"3"</span>,<span class="string">"left"</span>:null,<span class="string">"next"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"4"</span>,<span class="string">"left"</span>:null,<span class="string">"next"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"5"</span>,<span class="string">"left"</span>:null,<span class="string">"next"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"6"</span>,<span class="string">"left"</span>:null,<span class="string">"next"</span>:null,<span class="string">"right"</span>:null,<span class="string">"val"</span>:<span class="number">7</span>&#125;,<span class="string">"right"</span>:null,<span class="string">"val"</span>:<span class="number">6</span>&#125;,<span class="string">"right"</span>:null,<span class="string">"val"</span>:<span class="number">5</span>&#125;,<span class="string">"right"</span>:null,<span class="string">"val"</span>:<span class="number">4</span>&#125;,<span class="string">"next"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"7"</span>,<span class="string">"left"</span>:&#123;<span class="string">"$ref"</span>:<span class="string">"5"</span>&#125;,<span class="string">"next"</span>:null,<span class="string">"right"</span>:&#123;<span class="string">"$ref"</span>:<span class="string">"6"</span>&#125;,<span class="string">"val"</span>:<span class="number">3</span>&#125;,<span class="string">"right"</span>:&#123;<span class="string">"$ref"</span>:<span class="string">"4"</span>&#125;,<span class="string">"val"</span>:<span class="number">2</span>&#125;,<span class="string">"next"</span>:null,<span class="string">"right"</span>:&#123;<span class="string">"$ref"</span>:<span class="string">"7"</span>&#125;,<span class="string">"val"</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>解题思路</strong></p><p>按照题意思路直接遍历即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || root-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 题目说明左右子节点都存在，所以不用额外判断</span></span><br><span class="line">        root-&gt;left-&gt;next = root-&gt;right; <span class="comment">// 直接连接</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;next)</span><br><span class="line">            root-&gt;right-&gt;next = root-&gt;next-&gt;left; <span class="comment">// 用来连接示例中5和6类型的节点，即root为左孩子的情况</span></span><br><span class="line">        <span class="comment">//else</span></span><br><span class="line">        <span class="comment">//    root-&gt;right-&gt;next = NULL; // 用来连接示例中7和NULL类型的节点，即root为右孩子的情况</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        root-&gt;left = dfs(root-&gt;left);</span><br><span class="line">        root-&gt;right = dfs(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：填充每个节点的下一个右侧节点指针-II"><a href="#练习：填充每个节点的下一个右侧节点指针-II" class="headerlink" title="练习：填充每个节点的下一个右侧节点指针 II"></a>练习：填充每个节点的下一个右侧节点指针 II</h2><blockquote><p>【LeetCode】117</p></blockquote><p>给定一个二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>示例：</strong></p><p><img src="/2019/04/02/leetcode_explore_binary_tree/117_sample.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">输出：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p>代码如下，详见注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 保存原始根节点</span></span><br><span class="line">        Node* oriroot = root;</span><br><span class="line">        <span class="comment">// start用来连接两个层，start-&gt;next为下一层的首元素</span></span><br><span class="line">        <span class="comment">// tmp用来遍历整个树，且tmp始终比root低一层</span></span><br><span class="line">        Node* start = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node* tmp = start; <span class="comment">// tmp指向start</span></span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="comment">// 如果根节点有左孩子，则tmp连接根节点的左孩子，并修改tmp到同层的下一个节点，对每一层的第一个元素，这个步骤完成了start与下层第一个元素的连接</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) &#123;</span><br><span class="line">                tmp-&gt;next = root-&gt;left;</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果根节点有右孩子，则tmp连接根节点的右孩子，修改tmp到同层下一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">                tmp-&gt;next = root-&gt;right;</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// root向同层下一个节点移动</span></span><br><span class="line">            root = root-&gt;next;</span><br><span class="line">            <span class="comment">// 如果root不存在，则该层遍历结束，修改root为下一层的第一个节点，并修改start为NULL，tmp指向start（用来连接下一层）</span></span><br><span class="line">            <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">                root = start-&gt;next;</span><br><span class="line">                start-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                tmp = start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oriroot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="小结：填充每个节点的下一个右侧节点指针问题"><a href="#小结：填充每个节点的下一个右侧节点指针问题" class="headerlink" title="小结：填充每个节点的下一个右侧节点指针问题"></a>小结：填充每个节点的下一个右侧节点指针问题</h2><h3 id="1、调试环境"><a href="#1、调试环境" class="headerlink" title="1、调试环境"></a>1、调试环境</h3><blockquote><p>对于上述两道填充右侧节点指针的题目，LeetCode上没有给出调试环境，在网上看到有相关的内容，记录如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeLinkNode *left, *right, *next;</span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimLeftTrailingSpaces</span><span class="params">(<span class="built_in">string</span> &amp;input)</span> </span>&#123;</span><br><span class="line">    input.erase(input.begin(), find_if(input.begin(), input.end(), [](<span class="keyword">int</span> ch) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">isspace</span>(ch);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimRightTrailingSpaces</span><span class="params">(<span class="built_in">string</span> &amp;input)</span> </span>&#123;</span><br><span class="line">    input.erase(find_if(input.rbegin(), input.rend(), [](<span class="keyword">int</span> ch) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">isspace</span>(ch);</span><br><span class="line">    &#125;).base(), input.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeLinkNode* <span class="title">stringToTreeNode</span><span class="params">(<span class="built_in">string</span> input)</span> </span>&#123;</span><br><span class="line">    trimLeftTrailingSpaces(input);</span><br><span class="line">    trimRightTrailingSpaces(input);</span><br><span class="line">    input = input.substr(<span class="number">1</span>, input.length() - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!input.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> item;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss.str(input);</span><br><span class="line"></span><br><span class="line">    getline(ss, item, <span class="string">','</span>);</span><br><span class="line">    TreeLinkNode* root = <span class="keyword">new</span> TreeLinkNode(stoi(item));</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeLinkNode*&gt; nodeQueue;</span><br><span class="line">    nodeQueue.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        TreeLinkNode* node = nodeQueue.front();</span><br><span class="line">        nodeQueue.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!getline(ss, item, <span class="string">','</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trimLeftTrailingSpaces(item);</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="string">"null"</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftNumber = stoi(item);</span><br><span class="line">            node-&gt;left = <span class="keyword">new</span> TreeLinkNode(leftNumber);</span><br><span class="line">            nodeQueue.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!getline(ss, item, <span class="string">','</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trimLeftTrailingSpaces(item);</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="string">"null"</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rightNumber = stoi(item);</span><br><span class="line">            node-&gt;right = <span class="keyword">new</span> TreeLinkNode(rightNumber);</span><br><span class="line">            nodeQueue.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeLinkNode * root;</span><br><span class="line">    root = stringToTreeNode(<span class="string">"&#123;2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、通用解法"><a href="#2、通用解法" class="headerlink" title="2、通用解法"></a>2、通用解法</h3><p>可以利用之前层序遍历的思路，维护一个树节点<strong>队列queue</strong>（先进先出），记录本层剩余的节点数和下一层的节点数。</p><p>上述两个问题均可用该方法解决。</p><p>具体过程：</p><ul><li>初始将根节点插入到队列中，每次从队列中取一个节点；</li><li>判断该节点是否有左右子节点，若有则加入到队列中，并将下一层节点数加一；</li><li>从队列中弹出该节点，将本层剩余节点数减一；</li><li>若本层还有剩余节点，说明该节点有同层的兄弟节点，则将其next指针指向队首节点；</li><li>若剩余节点数为0，则说明本层遍历结束，将剩余节点数置为下一层的节点数，并将下一层的节点数置为0；</li></ul><p>按照上述过程遍历，直至队列为空，则可完成树中所有next指针指向同层兄弟节点的操作。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        <span class="keyword">int</span> nextLevel = <span class="number">0</span>, remain = <span class="number">1</span>;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="comment">// 取队首节点</span></span><br><span class="line">            Node* tmpNode = q.front();</span><br><span class="line">            <span class="comment">// 将左右子节点插入队列，并修改下一层节点数</span></span><br><span class="line">            <span class="keyword">if</span>(tmpNode-&gt;left) &#123;</span><br><span class="line">                q.push(tmpNode-&gt;left);</span><br><span class="line">                nextLevel++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpNode-&gt;right) &#123;</span><br><span class="line">                q.push(tmpNode-&gt;right);</span><br><span class="line">                nextLevel++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 弹出队首节点，当前层剩余数减一</span></span><br><span class="line">            q.pop();</span><br><span class="line">            remain--;</span><br><span class="line">            <span class="comment">// 如果本层剩余数为0，则本层遍历结束，本层剩余节点数置为下一层节点数，下一层节点数归零</span></span><br><span class="line">            <span class="comment">// 如果本层剩余数不为0，则将next指针指向队首节点，继续上述过程</span></span><br><span class="line">            <span class="keyword">if</span>(remain) &#123;</span><br><span class="line">                tmpNode-&gt;next = q.front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                remain = nextLevel;</span><br><span class="line">                nextLevel = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：二叉树的最近公共祖先"><a href="#练习：二叉树的最近公共祖先" class="headerlink" title="练习：二叉树的最近公共祖先"></a>练习：二叉树的最近公共祖先</h2><blockquote><p>【LeetCode】236</p></blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="/2019/04/02/leetcode_explore_binary_tree/binarytree.png"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p><strong>解题思路</strong></p><p>按前序遍历的思路，从根节点开始遍历左右子树，直到找到第一个在左右子树中找到目标节点的节点。若该子树不包含目标节点，则返回NULL。</p><p>具体过程：</p><ul><li>先判断当前节点是否是目标节点，是则返回该节点（空节点则返回NULL）；</li><li>递归在左右子树中查找最近公共祖先节点；</li><li>若在左右子树都找到目标节点，则说明目标节点刚好分布在当前节点的左右两侧，则返回当前节点；</li><li>若左右子树只有一侧找到目标节点，则返回找到的那个节点，对应题目中一个节点是其本身的祖先的情况；（有一侧返回NULL说明目标节点都在另一侧，题目明确目标节点都存在于树中，所以另一侧初次找到其中一个目标节点的地方就是最近公共祖先，另一个节点必然在该节点的子树中）</li><li>若两侧都未找到，则返回NULL；</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 共同祖先只可能是该节点或该节点的祖先，所以找到p或q时递归可终止</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 递归查找左右子树</span></span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="comment">// 两侧都不空，说明p q刚好分布在root的左右两侧</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 哪侧不空，则说明在哪侧找到p、q节点，返回即可</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">NULL</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：二叉树的序列化与反序列化"><a href="#练习：二叉树的序列化与反序列化" class="headerlink" title="练习：二叉树的序列化与反序列化"></a>练习：二叉树的序列化与反序列化</h2><blockquote><p>【LeetCode】297</p></blockquote><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>示例:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure><p><strong>提示:</strong> 这与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://leetcode-cn.com/faq/#binary-tree" target="_blank" rel="noopener">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>说明:</strong> 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p><p><strong>解题思路</strong></p><p>按先序遍历的思路，将二叉树进行序列化，空节点用“#”保存（以确保节点插入到正确的位置）。为反序列化过程读取节点值方便，节点值之间用空格隔开。反序列化时，仍然按照先序遍历的思路即可。</p><p>序列化过程：</p><ul><li>如果当前节点为空，则str += “# “；</li><li>递归进行先序遍历，并记录节点值；<ul><li>str += root-&gt;val + “ “</li><li>serialize(root-&gt;left, str)</li><li>serialize(root-&gt;right, str)</li></ul></li></ul><p>反序列化过程：</p><ul><li>读取字符串中一个节点值；</li><li>如果该值是数字，则以该值构建当前根节点 root = new TreeNode(val)；<ul><li>递归构建左右子树；</li></ul></li><li>如果该值不是数字，则 root = NULL，返回；</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            str += <span class="string">"# "</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ostringstream</span> valstr;</span><br><span class="line">            valstr &lt;&lt; root-&gt;val;</span><br><span class="line">            str += valstr.str() + <span class="string">" "</span>;</span><br><span class="line">            </span><br><span class="line">            serialize(root-&gt;left, str);</span><br><span class="line">            serialize(root-&gt;right, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(TreeNode* &amp;root, <span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(str.length() == 0)</span></span><br><span class="line">        <span class="comment">//    return;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="built_in">string</span> tmp = str.substr(<span class="number">0</span>, str.find(<span class="string">" "</span>));</span><br><span class="line">        str = str.substr(str.find(<span class="string">" "</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(atoi(tmp.c_str()) || tmp.compare(<span class="string">"0"</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">            val = atoi(tmp.c_str());</span><br><span class="line">            root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            deserialize(root-&gt;left, str);</span><br><span class="line">            deserialize(root-&gt;right, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">        serialize(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        TreeNode* result = <span class="literal">NULL</span>;</span><br><span class="line">        deserialize(result, data);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure><blockquote><p>实际在LeetCode解题时，题目说明代码验证方式是<code>codec.deserialize(codec.serialize(root));</code>，只验证最后deserialize的返回值，并没有验证serialize的值（题目说序列化方法不限，所以也没法验证这个序列化结果的正确性的感觉），所以就意味着验证过程的返回值必然和输入值一样。</p><p>参考代码如下（Java）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">&gt;     TreeNode root;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">this</span>.root = root;</span><br><span class="line">&gt;         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">return</span> root;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考自LeetCode上Explore模块的&lt;a href=&quot;https://leetcode.com/explore/learn/card/data-structure-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Binary Tree&lt;/a&gt;，作为笔记记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Overview-综述&quot;&gt;&lt;a href=&quot;#Overview-综述&quot; class=&quot;headerlink&quot; title=&quot;Overview 综述&quot;&gt;&lt;/a&gt;Overview 综述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;树&lt;/code&gt;可以视为包含N个节点和N-1条边的有向无环图。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;二叉树&lt;/code&gt;是每个节点最多有两个子树的树结构，子树称为左子树和右子树。&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="https://lesley0416.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="树" scheme="https://lesley0416.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="https://lesley0416.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="Binary Tree" scheme="https://lesley0416.github.io/tags/Binary-Tree/"/>
    
      <category term="遍历" scheme="https://lesley0416.github.io/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】779、第k个语法符号</title>
    <link href="https://lesley0416.github.io/2019/03/26/leetcode_779/"/>
    <id>https://lesley0416.github.io/2019/03/26/leetcode_779/</id>
    <published>2019-03-26T03:07:50.000Z</published>
    <updated>2019-03-27T14:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>21、<a href="https://leetcode.com/problems/k-th-symbol-in-grammar/" target="_blank" rel="noopener">K-th Symbol in Grammar</a>第k个语法符号</p><p>难度：中等</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code>with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p><p>Given row <code>N</code> and index <code>K</code>, return the <code>K</code>-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p></li><li><p>中文：</p><p>在第一行我们写上一个 <code>0</code>。接下来的每一行，将前一行中的<code>0</code>替换为<code>01</code>，<code>1</code>替换为<code>10</code>。</p><p>给定行数 <code>N</code> 和序数 <code>K</code>，返回第 <code>N</code> 行中第 <code>K</code>个字符。（<code>K</code>从1开始）</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 1, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: N = 4, K = 5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row 1: 0</span><br><span class="line">row 2: 01</span><br><span class="line">row 3: 0110</span><br><span class="line">row 4: 01101001</span><br></pre></td></tr></table></figure></li><li><p>注意</p><ol><li><code>N</code> 的范围 <code>[1, 30]</code>.</li><li><code>K</code> 的范围 <code>[1, 2^(N-1)]</code>.</li></ol></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路。</p><p>整个结构可以看做是一棵二叉树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    0</span><br><span class="line">   / \</span><br><span class="line">  0   1</span><br><span class="line"> /\   /\</span><br><span class="line">0  1 1  0</span><br></pre></td></tr></table></figure><p>当一个节点是0的时候，两个子节点分别为0和1，当节点是1的时候，两个子节点分别为1和0。通过把K除以2，可以知道K的位置是左节点还是右节点。如果K是偶数，那么当前节点为右子节点，父节点是$N-1$行的第$K/2$个节点，如果K为奇数的话，则当前节点为左子节点。父节点是$N-1$行的第$(K+1)/2$个节点。</p><p>当前节点依赖于父节点，所以递归向前查找父节点，直至第一行结束。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存8.1M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (K%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthGrammar(N<span class="number">-1</span>, K/<span class="number">2</span>)==<span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> kthGrammar(N<span class="number">-1</span>, (K+<span class="number">1</span>)/<span class="number">2</span>)==<span class="number">0</span> ? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;21、&lt;a href=&quot;https://leetcode.com/problems/k-th-symbol-in-grammar/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K-th Symbol in Grammar&lt;/a&gt;第k个语法符号&lt;/p&gt;
&lt;p&gt;难度：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="链表" scheme="https://lesley0416.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】21、合并两个有序链表</title>
    <link href="https://lesley0416.github.io/2019/03/26/leetcode_21/"/>
    <id>https://lesley0416.github.io/2019/03/26/leetcode_21/</id>
    <published>2019-03-26T03:07:50.000Z</published>
    <updated>2019-03-26T03:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>21、<a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">Merge Two Sorted Lists</a>合并两个有序链表</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p></li><li><p>中文：</p><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路，比较头结点，保留较小值，再合并后续内容。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时8ms，内存9M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val&lt;l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;21、&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Merge Two Sorted Lists&lt;/a&gt;合并两个有序链表&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="链表" scheme="https://lesley0416.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】50、Pow(x,n)</title>
    <link href="https://lesley0416.github.io/2019/03/25/leetcode_50/"/>
    <id>https://lesley0416.github.io/2019/03/25/leetcode_50/</id>
    <published>2019-03-25T09:10:50.000Z</published>
    <updated>2019-03-25T09:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>50、<a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">Pow(x,n)</a>Pow(x,n)</p><p>难度：中等</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a>, which calculates <em>x</em> raised to the power <em>n</em>(xn).</p></li><li><p>中文：</p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure></li><li><p>Note:</p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> is a 32-bit signed integer, within the range $[-2^{31},2^{31}-1]$</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路，直接用for循环让x乘以自己n次会超时。用递归的思路，对计算过程进行二分计算。每次把n缩小一半，直至n缩小为0。任何数的0次方都为1，这是终止条件。如果n是偶数，返回值算个平方返回即可，如果n是奇数，则平方之后再乘以一次x。</p><p>需要注意的是，n可能为负数，如果n是负数的话，就先用绝对值计算，再对结果取倒数。</p><p>但按上述思路简单实现后，对于<code>负2的31次方</code>这个测试用例，由于绝对值超过整型最大值，所以溢出了。所以换一种写法，在每次递归中都处理n的正负，然后做相应的变换。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时8ms，内存10M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> half = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) <span class="keyword">return</span> half * half * x;</span><br><span class="line">        <span class="keyword">return</span> half * half / x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>用迭代的方法，将i初始化为n，看i是否是2的倍数，如果是，则x乘以自己即可，如果不是，则temp要再乘以x，i逐次减半，直到为0停止循环。最后看n的正负，并做相应处理。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时8ms，内存10M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i != <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;50、&lt;a href=&quot;https://leetcode.com/problems/powx-n/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pow(x,n)&lt;/a&gt;Pow(x,n)&lt;/p&gt;
&lt;p&gt;难度：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="数学" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分查找" scheme="https://lesley0416.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】104、二叉树的最大深度</title>
    <link href="https://lesley0416.github.io/2019/03/25/leetcode_104/"/>
    <id>https://lesley0416.github.io/2019/03/25/leetcode_104/</id>
    <published>2019-03-25T08:51:50.000Z</published>
    <updated>2019-03-25T09:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>104、<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a>二叉树的最大深度</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Note:</strong> A leaf is a node with no children.</p></li><li><p>中文：</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p></li><li><p>示例</p><p><strong>Example：</strong></p><p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its depth = 3.</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路，最大深度等于左节点和右节点最大深度的较大值加1。</p><blockquote><p>C++，用时16ms，内存19M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (leftDepth &gt; rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;104、&lt;a href=&quot;https://leetcode.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maximum Depth of Binary Tree&lt;/a&gt;二叉树的最大深度&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="树" scheme="https://lesley0416.github.io/tags/%E6%A0%91/"/>
    
      <category term="深度优先搜索" scheme="https://lesley0416.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="二叉树" scheme="https://lesley0416.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】509、斐波那契数</title>
    <link href="https://lesley0416.github.io/2019/03/25/leetcode_509/"/>
    <id>https://lesley0416.github.io/2019/03/25/leetcode_509/</id>
    <published>2019-03-25T02:10:50.000Z</published>
    <updated>2019-03-25T02:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>509、<a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">Fibonacci Number</a>斐波那契数</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code>and <code>1</code>. That is,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), for N &gt; 1.</span><br></pre></td></tr></table></figure><p>Given <code>N</code>, calculate <code>F(N)</code>.</p></li><li><p>中文：</p><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>给定 <code>N</code>，计算 <code>F(N)</code>。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure></li><li><p>提示</p><p>0 ≤ N ≤ 30</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用递归方法。</p><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python，用时20ms，内存11.8M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur_fib</span><span class="params">(N)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> N <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[N]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">                result = N</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = recur_fib(N<span class="number">-1</span>) + recur_fib(N<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># put result in cache for later reference.</span></span><br><span class="line">            cache[N] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur_fib(N)</span><br></pre></td></tr></table></figure><p>使用decorator模式做递归方法中的缓存计算。</p><blockquote><p>Python，用时20ms，内存12.1M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cache</span><span class="params">(func)</span>:</span> </span><br><span class="line">        caches = &#123;&#125; </span><br><span class="line"><span class="meta">        @wraps(func) </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args)</span>:</span> </span><br><span class="line">            <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> caches: </span><br><span class="line">                caches[args] = func(*args)</span><br><span class="line">            <span class="keyword">return</span> caches[args] </span><br><span class="line">        <span class="keyword">return</span> wrap </span><br><span class="line">    </span><br><span class="line"><span class="meta">    @cache </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span> </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: </span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.fib(n<span class="number">-1</span>) + self.fib(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;509、&lt;a href=&quot;https://leetcode.com/problems/fibonacci-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fibonacci Number&lt;/a&gt;斐波那契数&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="数组" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="斐波那契数列" scheme="https://lesley0416.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——decorator</title>
    <link href="https://lesley0416.github.io/2019/03/25/decorator_python/"/>
    <id>https://lesley0416.github.io/2019/03/25/decorator_python/</id>
    <published>2019-03-25T02:08:50.000Z</published>
    <updated>2019-03-26T06:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>后续补充</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;后续补充&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="Python" scheme="https://lesley0416.github.io/categories/Python/"/>
    
    
      <category term="decorator" scheme="https://lesley0416.github.io/tags/decorator/"/>
    
      <category term="Python" scheme="https://lesley0416.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://lesley0416.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】206、反转链表</title>
    <link href="https://lesley0416.github.io/2019/03/22/leetcode_206/"/>
    <id>https://lesley0416.github.io/2019/03/22/leetcode_206/</id>
    <published>2019-03-22T06:33:50.000Z</published>
    <updated>2019-03-27T13:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>206、<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a>反转链表</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Reverse a singly linked list.</p></li><li><p>中文：</p><p>反转一个单链表。</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure></li><li><p>进阶<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="递归解决方法的视频讲解"><a href="#递归解决方法的视频讲解" class="headerlink" title="递归解决方法的视频讲解"></a>递归解决方法的视频讲解</h3><p><a href="https://www.youtube.com/watch?v=MRe3UsRadKw" target="_blank" rel="noopener">Reverse a Linked List Recursively</a></p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>参考讨论区的一种做法。</p></blockquote><p>时间复杂度O(N)，空间复杂度O(1)</p><p>这里给出两种方法：迭代法（循环），递归方法。</p><p>两种方法的思路都是一样的。如下所示</p><blockquote><p>…&lt;-x&lt;-x&lt;-x&lt;-x&lt;-pre  ||  cur-&gt;y-&gt;y-&gt;y-&gt;y…</p></blockquote><ol><li>将整个链表分成两个部分；前半部分链表，后半部分链表</li><li>pre为已经 反转 好的部分链表的头节点；</li><li>cur为当前仍然没有反转部分链表的头节点；</li><li>我们当前需要做的事情就是将cur节点加入到前半部分的链表中，<br>直到右边的链表全部加入到左边的链表中即可。</li><li>用递归的思想理解4很容易。</li></ol><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><p><strong>递归方法</strong></p><blockquote><p>C++，用时8ms，内存9M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre, ListNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>) &#123; <span class="comment">// 递归结束的判断</span></span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        <span class="keyword">return</span> reverse(pre, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>, *cur = head;</span><br><span class="line">        <span class="keyword">return</span> head ? reverse(pre, cur) : head; <span class="comment">// 如果head为空的话，我们直接返回head/NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代方法</strong></p><blockquote><p>C++，用时8ms，内存9.1M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>, *cur = head, *next = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">            next = next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>参考LeetCode上<code>递归</code>探索页给出的解决方案。</p><p>递归版，是从后往前来转变链表指针的方向；迭代版是从前往后来转变链表的方向。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 递归版</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == null || head.next == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = null;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代版</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != null)&#123;</span><br><span class="line">            ListNode p1 = null;</span><br><span class="line">            ListNode next = null;</span><br><span class="line">            ListNode p2 = head;</span><br><span class="line">            <span class="keyword">while</span> (p2 != null)&#123;</span><br><span class="line">                next = p2.next;</span><br><span class="line">                p2.next = p1;</span><br><span class="line">                p1 = p2;</span><br><span class="line">                p2 = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h3><p>参考网上的解法，巧妙利用Python的多元赋值，实现非常简洁。</p><p>具体的执行过程可参考下面的举例说明：</p><blockquote><p>前置条件：迭代指针：p = head、结果指针：res = none</p><p><strong>以1-&gt;2-&gt;3-&gt;4-&gt;5为例：</strong></p><p>过程：</p><p>res:None</p><p>第一层循环</p><p>res:1-&gt;2-&gt;3-&gt;4-&gt;5    res = p</p><p>res:1-&gt;None    res.next = res</p><p>p:2-&gt;3-&gt;4-&gt;5    p = p.next</p><p>第二层循环</p><p>res:2-&gt;3-&gt;4-&gt;5    res = p</p><p>res:2-&gt;1-&gt;None    res.next = res</p><p>p:3-&gt;4-&gt;5    p = p.next</p><p>第三层循环</p><p>res:3-&gt;4-&gt;5    res = p</p><p>res:3-&gt;2-&gt;1-&gt;None    res.next = res</p><p>p:4-&gt;5    p = p.next</p><p>第四层循环</p><p>res:4-&gt;5    res = p</p><p>res:4-&gt;3-&gt;2-&gt;1-&gt;None    res.next = res</p><p>p:5    p = p.next</p><p>第五层循环</p><p>res:5    res = p</p><p>res:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;None    res.next = res</p><p>p:None    p = p.next</p><p>end…</p></blockquote><h4 id="代码提交-2"><a href="#代码提交-2" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>Python，用时32ms，内存12.7M</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        L = ListNode(float(<span class="string">"-inf"</span>))</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="comment"># 把当前 L.next （如 [2,1]）内容临时保存起来，然后把head此时剩下的内容（如 [3,4,5]）赋给L （变成[3,4,5]），再把之前保存的L.next接回来（L变成[3,2,1]），最后head后移一步</span></span><br><span class="line">            L.next, head.next, head = head, L.next, head.next</span><br><span class="line">        <span class="keyword">return</span> L.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;206、&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reverse Linked List&lt;/a&gt;反转链表&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="Python" scheme="https://lesley0416.github.io/tags/Python/"/>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="链表" scheme="https://lesley0416.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="多元赋值" scheme="https://lesley0416.github.io/tags/%E5%A4%9A%E5%85%83%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】119、杨辉三角2</title>
    <link href="https://lesley0416.github.io/2019/03/22/leetcode_119/"/>
    <id>https://lesley0416.github.io/2019/03/22/leetcode_119/</id>
    <published>2019-03-22T06:16:50.000Z</published>
    <updated>2019-03-27T13:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>119、<a href="https://leetcode.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">Pascal’s Triangle II</a>杨辉三角2</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p><p>Note that the row index starts from 0.</p></li><li><p>中文：</p><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p><p><img src="/2019/03/22/leetcode_119/210px-PascalTriangleAnimated2.gif"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure></li><li><p>进阶</p><p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote><p><strong>递归关系</strong></p><p>我们从定义杨辉三角的递归关系开始。</p><p>首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下：</p><script type="math/tex; mode=display">f(i,j)=f(i-1,j-1)+f(i-1,j)</script><p><strong>基本情况</strong></p><p>在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1.</p><p>所以，我们可以定义基本情况如下：</p><script type="math/tex; mode=display">f(i,j)=1\qquad where\qquad j=1\ or\ j=i</script><blockquote><p>代码没有完全对应Recursion相应位置的方法，实现过程中，采用自底向上的方法，保存前一行的中间结果。</p><p>代码上注意一下，此处的<code>rowIndex</code>从0开始。</p></blockquote><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存8.3M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        temp.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= rowIndex; row++) &#123;</span><br><span class="line">            result.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt;= row; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">0</span> || col == row) &#123;</span><br><span class="line">                    result.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.push_back(temp[col - <span class="number">1</span>] + temp[col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>和思路一类似，先开辟一个大小为$k$的空间，保留每次前一行的中间结果，在其基础上直接修改获取当前行的结果。</p><p>修改过程中，先填充当前行的末尾值（比前一行最末的位置+1位），然后从右往左依次修改，当前行位置为$j$的值，仅依赖于上一行位置为$j-1$和$j$的值，所以，逆序修改的过程中，改掉的值都是下一步计算不再需要的值。</p><h4 id="代码提交-1"><a href="#代码提交-1" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存8.3M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(rowIndex + <span class="number">1</span>);<span class="comment">// 长度为K，默认值为0</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) &#123;<span class="comment">// 从第1行开始（从0开始数）计算每一行的参数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">                res[j] += res[j - <span class="number">1</span>];<span class="comment">// 更新j位置上的数为上一行的j-1位置与j位置的数的和，最末端为 0+上一行最末端</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;119、&lt;a href=&quot;https://leetcode.com/problems/pascals-triangle-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pascal’s Triangle II&lt;/a&gt;杨辉三角2&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="数组" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】118、杨辉三角</title>
    <link href="https://lesley0416.github.io/2019/03/22/leetcode_118/"/>
    <id>https://lesley0416.github.io/2019/03/22/leetcode_118/</id>
    <published>2019-03-22T03:54:50.000Z</published>
    <updated>2019-03-22T05:53:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>118、<a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">Pascal’s Triangle</a>杨辉三角</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p></li><li><p>中文：</p><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p><p><img src="/2019/03/22/leetcode_118/210px-PascalTriangleAnimated2.gif"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote><p><strong>递归关系</strong></p><p>我们从定义杨辉三角的递归关系开始。</p><p>首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下：</p><script type="math/tex; mode=display">f(i,j)=f(i-1,j-1)+f(i-1,j)</script><p><strong>基本情况</strong></p><p>在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1.</p><p>所以，我们可以定义基本情况如下：</p><script type="math/tex; mode=display">f(i,j)=1\qquad where\qquad j=1\ or\ j=i</script><blockquote><p>代码没有完全对应Recursion相应位置的方法，实现过程中，采用自底向上的方法，保存计算过的中间结果，避免了重复计算。</p></blockquote><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存8.8M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) &#123;</span><br><span class="line">            temp.push_back(<span class="number">1</span>);</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.push_back(<span class="number">1</span>);</span><br><span class="line">        result.push_back(temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; numRows; row++) &#123;</span><br><span class="line">            temp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt;= row; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">0</span> || col == row) &#123;</span><br><span class="line">                    temp.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.push_back(result[row - <span class="number">1</span>][col - <span class="number">1</span>] + result[row - <span class="number">1</span>][col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;118、&lt;a href=&quot;https://leetcode.com/problems/pascals-triangle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pascal’s Triangle&lt;/a&gt;杨辉三角&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="数组" scheme="https://lesley0416.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】24、两两交换链表中的节点</title>
    <link href="https://lesley0416.github.io/2019/03/21/leetcode_24/"/>
    <id>https://lesley0416.github.io/2019/03/21/leetcode_24/</id>
    <published>2019-03-21T09:32:50.000Z</published>
    <updated>2019-03-22T03:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>24、<a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a>两两交换链表中的节点</p><p>难度：中等</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p></li><li><p>中文：</p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p></li><li><p>示例</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote><p>定义函数<code>swap(head)</code>，其中输入参数<code>head</code>表示链表的头结点。函数应该返回相邻节点交换后的新链表的头结点。</p><p>按如下步骤实现这个函数：</p><ol><li>首先，我们交换链表的前两个节点，即<code>head</code>和<code>head.next</code>；</li><li>然后，我们递归调用函数<code>swap(head.next.next)</code>来处理链表的剩余部分；</li><li>最后，获得步骤2返回的子链表的头结点，并将其和步骤1的新链表相连接；</li></ol><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时4ms，内存9M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *t = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(head-&gt;next-&gt;next);</span><br><span class="line">        t-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;24、&lt;a href=&quot;https://leetcode.com/problems/swap-nodes-in-pairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swap Nodes in Pairs&lt;/a&gt;两两交换链表中的节点&lt;/p&gt;
&lt;p&gt;难度：中等&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="链表" scheme="https://lesley0416.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】344、反转字符串</title>
    <link href="https://lesley0416.github.io/2019/03/21/leetcode_344/"/>
    <id>https://lesley0416.github.io/2019/03/21/leetcode_344/</id>
    <published>2019-03-21T05:41:50.000Z</published>
    <updated>2019-03-22T03:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>344、<a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">Reverse String</a>反转字符串</p><p>难度：简单</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>英文：</p><p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>You may assume all the characters consist of <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters" target="_blank" rel="noopener">printable ascii characters</a>.</p></li><li><p>中文：</p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a> 码表中的可打印字符。</p></li><li><p>示例</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>递归思路，不使用额外空间，从首尾两端开始交换字符，并依次向内部缩小，直至交换到数组中间位置时结束。</p><p>用$s[x_i,…,x_j]$表示字符数组，其中$x_i , x_j$表示数组中的字符内容，$i,j$为对应的位置，则：</p><script type="math/tex; mode=display">s[x_i,...,x_j]=    \begin{cases}        s[x_i,...x_j], & \text{if $i>=j$}\\        s[x_j,...x_i], & \text{if $i<j$}    \end{cases}</script><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><blockquote><p>C++，用时60ms，内存19M</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        swap(s, left+<span class="number">1</span>, right<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        swap(s, <span class="number">0</span>, s.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>进行Recursion探索时完成的，其他解法后续补充。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;344、&lt;a href=&quot;https://leetcode.com/problems/reverse-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reverse String&lt;/a&gt;反转字符串&lt;/p&gt;
&lt;p&gt;难度：简单&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
      <category term="双指针" scheme="https://lesley0416.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="字符串" scheme="https://lesley0416.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】Explore：Recursion I 递归—1</title>
    <link href="https://lesley0416.github.io/2019/03/21/leetcode_explore_recursion/"/>
    <id>https://lesley0416.github.io/2019/03/21/leetcode_explore_recursion/</id>
    <published>2019-03-21T03:03:50.000Z</published>
    <updated>2019-03-27T14:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要翻译自LeetCode上Explore模块的<a href="https://leetcode.com/explore/learn/card/recursion-i/" target="_blank" rel="noopener">Recursion I</a>，有直译，也有非直译的个人理解。</p><p>其中涉及的题目附有相应的解答。</p></blockquote><h1 id="Overview-综述"><a href="#Overview-综述" class="headerlink" title="Overview 综述"></a>Overview 综述</h1><p><code>Recursion</code>（递归）是计算机科学中一个重要的概念，是很多算法和数据结构的基础。但是对于很多初学者都比较难把握。</p><a id="more"></a><p>在开始本节探索之前，我们强烈建议先完成<a href="https://leetcode.com/explore/learn/card/data-structure-tree/" target="_blank" rel="noopener">二叉树</a>和<a href="https://leetcode.com/explore/learn/card/queue-stack/" target="_blank" rel="noopener">堆栈</a>两个探索页。</p><p>在这个探索页，我们将回答以下几个问题：</p><ol><li>什么是<code>recursion</code>？它是如何工作的？</li><li>如何递归的解决一个问题？</li><li>如何分析递归算法的时间和空间复杂度（time and space complexity）？</li><li>如何更好的应用递归？</li></ol><p>完成本探索页后，你在解决递归问题和分析复杂度时会变得更加自信。</p><h1 id="一、Principle-of-Recursion-递归原理"><a href="#一、Principle-of-Recursion-递归原理" class="headerlink" title="一、Principle of Recursion 递归原理"></a>一、Principle of Recursion 递归原理</h1><p>在这章，我们将会：</p><ol><li>解释递归的基本概念；</li><li>演示如何应用递归解决确切的问题；</li><li>最后提供一些练习题来练习递归；</li></ol><h2 id="递归原理"><a href="#递归原理" class="headerlink" title="递归原理"></a>递归原理</h2><blockquote><p>递归是一种将函数本身作为子程序调用来解决问题的方法。</p></blockquote><p>你可能想知道一个函数怎样调用其自身。诀窍在于每次递归的调用其本身时，都将给定的问题缩小成其子问题，这样持续的递归调用，直到子问题可以不用递归就能解决的时候停止。</p><p>一个递归函数应该有以下属性，这样才不会导致无限循环：</p><ol><li>具有简单的基本情况，即递归出口、递归结束条件，即不使用递归即可获得答案的情况；</li><li>一系列规则，称为<code>recurrence relation</code>递归关系，可以将问题逐步缩小直至递归出口；</li></ol><p>注意，可能会有多个可以调用函数本身的地方。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>从一个简单的问题开始：逆序输出字符串。</p><blockquote><p>倒序输出一个字符串。</p></blockquote><p>你可以很容易的迭代解决这个问题，例如从字符串的结尾开始遍历字符串。但是如何递归的解决呢？</p><p>首先，我们定义函数<code>printReverse(str[0...n-1])</code>，其中<code>str[0]</code>表示字符串的第一个字符，然后我们通过以下两个步骤解决这个问题：</p><ol><li><code>printReverse(str[1...n-1])</code>：逆序输出子串<code>strp[1...n-1]</code>；</li><li><code>print(str[0])</code>：输出字符串的首字符；</li></ol><p>我们在第一步中定义了递归关系。</p><p>代码如下（C++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printReverse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!*str)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    printReverse(str+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，来处理一个和示例略有不同的练习，尽量用递归来解决。</p><h2 id="练习：反转字符串"><a href="#练习：反转字符串" class="headerlink" title="练习：反转字符串"></a>练习：反转字符串</h2><a href="/2019/03/21/leetcode_344/" title="【LeetCode】344、Reverse String">【LeetCode】344、Reverse String</a><p>写一个反转字符串的函数，输入字符数组<code>char[]</code>。</p><p>不要开辟额外的控件，必须使用$O(1)​$的空间复杂度就地修改输入的数组。</p><p>假定所有的字符都是可打印的ASCII码字符。</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><p>递归代码如下（自己写的，C++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        swap(s, left+<span class="number">1</span>, right<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        swap(s, <span class="number">0</span>, s.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：反转字符串"><a href="#解答：反转字符串" class="headerlink" title="解答：反转字符串"></a>解答：反转字符串</h2><p>本章，我们给出反转字符串问题的一个简单的解决方案。</p><blockquote><p>问题并不难，关键在于有一个额外的约束条件，即使用$O(1)$的额外空间进行修改。</p></blockquote><p>定义函数<code>reverseString(str[0...n-1])</code>，其中<code>str[0...n-1]</code>是一个首字符为<code>str[0]</code>的字符数组。</p><p>下面，我们讨论如何利用递归的思想来解决这个问题。</p><h3 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h3><p>如果我们按照上文逆序输出字符串的思路，我们可以有以下的方法：</p><ol><li>从输入字符串中取首字符<code>str[0]</code>；</li><li>对于剩下的子字符串，调用函数自身来递归解决，如<code>reverseString(str[1...n-1])</code>；</li><li>在步骤2返回的结果中添加首字符；</li></ol><p>这个方法可以实现题意效果，但是不满足约束条件。因为需要额外的空间来保存步骤2的中间结果，所需空间大小和字符串长度成正比（即需要$O(n)$的空间复杂度），这一点不满足$O(1)$空间复杂度的要求。</p><h3 id="另一种分治的方法"><a href="#另一种分治的方法" class="headerlink" title="另一种分治的方法"></a>另一种分治的方法</h3><p>考虑题目中的约束条件，将其放入到递归的问题中，可以理解为在两次连续的递归调用之间不使用额外的空间消耗，也就是说，我们应该把问题分解成独立的子问题。</p><p>分解成独立子问题的一个思路是将每次输入的字符串分成两部分：1、首尾字符；2、去掉首位字符后剩下的子字符串。然后可以独立的解决两部分内容。</p><p>按照上述方法，可以有以下的方法：</p><ol><li>从输入的字符串中取首尾字符<code>str[0]</code>和<code>str[n-1]</code>；</li><li>就地交换首尾字符；</li><li>递归调用函数来反转剩余的子字符串，即<code>reverseString(str[1...n-2])</code>；</li></ol><p>注意：步骤2、3可以交换，因为是两个独立的任务。但最好保持现状的顺序，这样可以使用尾递归优化调用。我们会在后面的章节详细了解尾递归。（先简单理解一下，尾递归是指函数运行的最后一步是调用其自身，尾递归由于递归在最后一步，不再需要考虑外层函数的信息，因此可以把这个函数的调用栈给优化掉，从而避免栈溢出的风险。）</p><p>代码如下（示例代码，Python3）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: List[str]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(start, end, ls)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment"># swap the first and last element</span></span><br><span class="line">            ls[start], ls[end] = ls[end], ls[start]        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> helper(start+<span class="number">1</span>, end<span class="number">-1</span>, ls)</span><br><span class="line">    </span><br><span class="line">        helper(<span class="number">0</span>, len(s)<span class="number">-1</span>, s)</span><br></pre></td></tr></table></figure><p>如图，用字符数组<code>[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</code>举例，可以看到如何进行分解并解决的。</p><p><img src="/2019/03/21/leetcode_explore_recursion/344_reverse_string.png" style="zoom:50%"></p><p>使用这种方法，在每次递归调用的时候只需要常数级内存空间用来交换首尾字符即可，满足题目的约束条件。</p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>对于一个问题而言，如果可以用递归的思路来解决的话，那我们一定可以遵循如下的思路来实现。</p><p>举例来说，我们用一个待实现的函数$F(X)$来表示问题，其中$X$表示函数的输入，也就是问题的范围。</p><p>那么，在函数$F (X)$中，我们将做如下操作：</p><ol><li>把问题分解为更小的范围，如$x_0\in X , x_1\in X , … , x_n\in X$；</li><li>递归调用函数$F(x_0),F(x_1),…,F(x_n)$来解决$X$的子问题；</li><li>最后，处理递归调用的结果，从而解决$X$对应的问题；</li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>通过递归解决另一个问题来展示上述思路。</p><blockquote><p>给定一个链表，交换其中每两个相邻节点，并返回头结点。</p><p>例如：给定列表<code>1-&gt;2-&gt;3-&gt;4</code>，应该返回交换后的列表<code>2-&gt;1-&gt;4-&gt;3</code>的头结点。</p></blockquote><p>定义函数<code>swap(head)</code>，其中输入参数<code>head</code>表示链表的头结点。函数应该返回相邻节点交换后的新链表的头结点。</p><p>按照上述思路，我们可以按如下步骤实现这个函数：</p><ol><li>首先，我们交换链表的前两个节点，即<code>head</code>和<code>head.next</code>；</li><li>然后，我们递归调用函数<code>swap(head.next.next)</code>来处理链表的剩余部分；</li><li>最后，获得步骤2返回的子链表的头结点，并将其和步骤1的新链表相连接；</li></ol><p>作为练习，可以按照上文提供的步骤试着实现该问题的完整代码。</p><h2 id="练习：两两交换链表中的节点"><a href="#练习：两两交换链表中的节点" class="headerlink" title="练习：两两交换链表中的节点"></a>练习：两两交换链表中的节点</h2><p>详见<a href="/2019/03/21/leetcode_24/" title="【LeetCode】24、Swap Nodes in Pairs">【LeetCode】24、Swap Nodes in Pairs</a></p><p><strong>Swap Nodes in Pairs </strong></p><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p>代码如下（C++，用时4ms，内存9M）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *t = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(head-&gt;next-&gt;next);</span><br><span class="line">        t-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、Recurrence-Relation-递归关系"><a href="#二、Recurrence-Relation-递归关系" class="headerlink" title="二、Recurrence Relation 递归关系"></a>二、Recurrence Relation 递归关系</h1><p>上一章我们了解了递归的基本概念。</p><p>在实现递归函数之前，有两个重要的点需要注意：<strong>基本情况</strong>和<strong>递归关系</strong>。</p><p>在这章，我们将：</p><ul><li>通过详细的例子来了解如何定义基本情况和递归关系；</li><li>做一些练习；</li></ul><h2 id="递归关系"><a href="#递归关系" class="headerlink" title="递归关系"></a>递归关系</h2><p>在实现递归函数之前，要注意两个重要的点：</p><ul><li>递归关系：总问题结果和子问题结果之间的关系；</li><li>基本情况：不需要继续递归调用就能够计算结果的情况，就是递归结束情况。（有时基本情况也被叫做<code>bottom cases</code>，因为如果我们用自顶向下的方式对问题进行分解的话，那么基本情况通常出现在问题已经被分解到最小范围的时候，即<code>bottom</code>）</li></ul><blockquote><p>一旦我们有了上述两方面内容，那么我们只需要按照<strong>递归关系</strong>不断的调用函数本身，直到到达<strong>基本情况</strong>。</p></blockquote><p>为了解释上述内容，我们来看一个经典问题：杨辉三角（也叫 帕斯卡三角）。</p><blockquote><p>杨辉三角是由一系列数字组成的三角形。其中，每一行的最左边和最右边永远是1，剩余的其他数字，每个数是其上面两个数的和。</p></blockquote><h3 id="示例：杨辉三角"><a href="#示例：杨辉三角" class="headerlink" title="示例：杨辉三角"></a>示例：杨辉三角</h3><p>下图是一个五层的杨辉三角示意图：</p><p><img src="/2019/03/21/leetcode_explore_recursion/210px-PascalTriangleAnimated2.gif"></p><p>基于以上定义，我们的问题就是生成指定层数的杨辉三角。</p><p><strong>递归关系</strong></p><p>我们从定义杨辉三角的递归关系开始。</p><p>首先，定义函数$f(i,j)$，表示杨辉三角中第$i$行$j$列的值，之后可以将递归关系表示如下：</p><script type="math/tex; mode=display">f(i,j)=f(i-1,j-1)+f(i-1,j)</script><p><strong>基本情况</strong></p><p>在杨辉三角中，每行的最左和最右数字是这个问题的基本情况，值总是为1.</p><p>所以，我们可以定义基本情况如下：</p><script type="math/tex; mode=display">f(i,j)=1\qquad where\qquad j=1\ or\ j=i</script><p><strong>示例</strong></p><p>可以看到，一旦定义了递归关系和基本情况之后，就可以很直观的实现递归函数了，特别是定义好数学公式以后。</p><p>如下是应用上述公式计算$f(5,3)$，即第5行第3列的值的过程。</p><p><img src="/2019/03/21/leetcode_explore_recursion/PascalTriangleAnimatedDemo.gif"></p><p>要计算$f(5,3)$，我们按照递归关系将问题分解$f(5,3)=f(4,2)+f(4,3)$，之后递归计算$f(4,2)$和$f(4,3)$的值：</p><ul><li><p>对于$f(4,2)$，我们可以继续分解，直至基本情况，如下所示：</p><script type="math/tex; mode=display">f(4,2)=f(3,1)+f(3,2)=f(3,1)+(f(2,1)+f(2,2))=1+(1+1)=3</script></li><li><p>对于$f(4,3)$，同样的，我们可以将其分解如下：</p><script type="math/tex; mode=display">f(4,3)=f(3,2)+f(3,3)=(f(2,1)+f(2,2))+f(3,3)=(1+1)+1=3</script></li><li><p>最后我们组合上述子问题的结果：</p><script type="math/tex; mode=display">f(5,3)=f(4,2)+f(4,3)=3+3=6</script></li></ul><p><strong>下一步</strong></p><p>在上面的示例中，可以注意到在递归解决方案中有一些重复的计算，就是说，我们为了计算最后一行的值，重复的计算了很多中间结果。例如，为了计算$f(5,3)$，我们在计算$f(4,2)$和$f(4,3)$的过程中重复计算了两边$f(3,2)$的值。</p><p>我们将在下一章讨论如何避免这些重复计算。</p><p>按照本章的内容，可以做一些和杨辉三角相关的练习题。</p><p>详见<a href="/2019/03/22/leetcode_118/" title="【LeetCode】118、杨辉三角">【LeetCode】118、杨辉三角</a>，<a href="/2019/03/22/leetcode_119/" title="【LeetCode】119、杨辉三角2">【LeetCode】119、杨辉三角2</a>，<a href="/2019/03/22/leetcode_206/" title="【LeetCode】206、反转链表">【LeetCode】206、反转链表</a>。</p><h2 id="练习：杨辉三角"><a href="#练习：杨辉三角" class="headerlink" title="练习：杨辉三角"></a>练习：杨辉三角</h2><p><strong>Pascal’s Triangle</strong></p><p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em>of Pascal’s triangle.</p><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码如下（C++，用时4ms，内存8.8M）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) &#123;</span><br><span class="line">            temp.push_back(<span class="number">1</span>);</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.push_back(<span class="number">1</span>);</span><br><span class="line">        result.push_back(temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; numRows; row++) &#123;</span><br><span class="line">            temp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt;= row; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">0</span> || col == row) &#123;</span><br><span class="line">                    temp.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.push_back(result[row - <span class="number">1</span>][col - <span class="number">1</span>] + result[row - <span class="number">1</span>][col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：杨辉三角2"><a href="#练习：杨辉三角2" class="headerlink" title="练习：杨辉三角2"></a>练习：杨辉三角2</h2><p><strong>Pascal’s Triangle II</strong></p><p>Given a non-negative index <em>k</em> where <em>k</em> ≤ 33, return the <em>k</em>th index row of the Pascal’s triangle.</p><p>Note that the row index starts from 0.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p><p>代码如下（C++，用时4ms，内存8.3M）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        temp.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= rowIndex; row++) &#123;</span><br><span class="line">            result.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt;= row; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col == <span class="number">0</span> || col == row) &#123;</span><br><span class="line">                    result.push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.push_back(temp[col - <span class="number">1</span>] + temp[col]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="练习：反转链表"><a href="#练习：反转链表" class="headerlink" title="练习：反转链表"></a>练习：反转链表</h2><p><strong>Reverse Linked List</strong></p><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><p>代码如下（C++，用时8ms，内存9M）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre, ListNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>) &#123; <span class="comment">// 递归结束的判断</span></span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        <span class="keyword">return</span> reverse(pre, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>, *cur = head;</span><br><span class="line">        <span class="keyword">return</span> head ? reverse(pre, cur) : head; <span class="comment">// 如果head为空的话，我们直接返回head/NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：反转链表"><a href="#解答：反转链表" class="headerlink" title="解答：反转链表"></a>解答：反转链表</h2><h3 id="方法1、迭代法"><a href="#方法1、迭代法" class="headerlink" title="方法1、迭代法"></a>方法1、迭代法</h3><p>假设有链表$1\rightarrow 2\rightarrow 3\rightarrow \emptyset$，要将其转为$\emptyset \leftarrow 1\leftarrow 2\leftarrow 3$。</p><p>遍历链表，将当前节点的<code>next</code>指针指向其前一个节点。由于链表没有指向前一个节点的指针，所以需要提前保存前一个节点的信息。同时还需要一个指针，在改变<code>next</code>指向时用来保存当前<code>next</code>的节点。最后不要忘了返回新的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O (n)$。$n$是链表长度。</li><li>空间复杂度：$O (1)$。</li></ul><h3 id="方法2、递归法"><a href="#方法2、递归法" class="headerlink" title="方法2、递归法"></a>方法2、递归法</h3><p>递归方法要考虑回退工作，略难一点。假设链表的剩余部分已经反转好了，怎么反转其前半部分呢？</p><p>对于链表$n_1\rightarrow …\rightarrow n_{k-1} \rightarrow n_k \rightarrow n_{k+1} \rightarrow … \rightarrow n_m \rightarrow \emptyset​$，假设从节点$n_{k+1}​$到节点$n_m​$已经反转好了，并且当前在节点$n_k​$处：$n_1 \rightarrow … \rightarrow n_{k-1} \rightarrow \mathbf{n_k} \rightarrow n_{k+1} \leftarrow … \leftarrow n_m​$。</p><p>我们想让$n_{k+1}$的下一个节点指向$n_k$，所以：$n_k .next.next=n_k$。</p><p>要注意的是$n_1$节点的<code>next</code>必须指向$\emptyset​$。如果忽略这一步的话，那就把链表变成首尾相接的圆形的了。如果测试链表长度为2的情况，可能会触发这个bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next); <span class="comment">// 保留头结点，递归反转剩余部分</span></span><br><span class="line">    head.next.next = head; <span class="comment">// 把剩余部分的头结点指向到保留的头结点上，类似上文说的 n(k+1) 的next指向到 nk ，实现反转</span></span><br><span class="line">    head.next = <span class="keyword">null</span>; <span class="comment">// 把保留的头结点反转，指向空，即 n(k+1) 指向 nk 后，再将 nk 指向空</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O (n)$。$n$是链表长度。</li><li>空间复杂度：$O(n)$。额外的空间消耗来源于递归所需的隐藏的栈空间，递归最深为$n$层。</li></ul><h1 id="三、Memoization-缓存计算"><a href="#三、Memoization-缓存计算" class="headerlink" title="三、Memoization 缓存计算"></a>三、Memoization 缓存计算</h1><p>在上一章，我们提到过递归算法中的<strong>重复计算</strong>问题。在最好的情况下，重复计算只是会增加算法的时间复杂度，但是在最差的情况，重复计算会导致无限循环。</p><p>因此，在这章，我们将：</p><ul><li>用一个例子开始，展示重复计算是如何导致的；</li><li>展示如何用缓存计算的技术来避免重复计算；</li></ul><h2 id="递归中的重复计算"><a href="#递归中的重复计算" class="headerlink" title="递归中的重复计算"></a>递归中的重复计算</h2><p>递归是实现算法的一种强有力的方法，但是如果不好好使用的话，也会带来额外的问题，如重复计算。例如，在上一章的后半部分，我们提到过杨辉三角中的重复计算问题，一些中间结果被反复计算了多次。</p><p>在这章，我们将进一步的讨论递归中可能发生的重复计算问题，并提出一种叫做<strong>缓存计算</strong>的常用技术手段来避免这个问题。</p><p>为了用另一个例子来演示重复计算问题，我们看一个大部分都熟悉的例子：斐波那契数列。如果我们定义函数$F(n)$来表示索引为$n$的斐波那契数，那可以得到如下所示的递归关系式：</p><script type="math/tex; mode=display">F(n)=F(n-1)+F(n-2)</script><p>而基本情况（递归结束条件）为：</p><script type="math/tex; mode=display">F(0)=0\ ,\ F(1)=1</script><p>有了斐波那契数的定义之后，可以按如下所示实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>现在，如果想计算$F(4)$，就可以按照上述公式来实现：</p><script type="math/tex; mode=display">F(4)=F(3)+F(2)=(F(2)+F(1))+F(2)</script><p>可以看到，按照上述过程，为了计算$F(4)$的结果，我们需要计算两遍$F(2)$。</p><p>如图所示，用一棵树展示了在计算$F(4)​$的过程中进行的所有重复计算（用颜色分类）：</p><p><img src="/2019/03/21/leetcode_explore_recursion/fibonacci.png" style="zoom:30%"></p><h3 id="缓存计算"><a href="#缓存计算" class="headerlink" title="缓存计算"></a>缓存计算</h3><p>为了尽可能多的消除上述情况中的重复计算，一个方法就是将中间结果<strong>保存</strong>在缓存中，这样下次遇到的时候就可以重复使用而不需要再次计算了。</p><p>这个方法就是<strong>缓存计算</strong>方法，是经常和递归一起使用的一种技术。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="noopener">Memoization</a> is an optimization technique used primarily to <strong>speed up</strong> computer programs by <strong>storing</strong> the results of expensive function calls and returning the cached result when the same inputs occur again. (Source: wikipedia)</p><p><strong>缓存计算</strong>是通过将高消耗的函数调用结果进行保存，并且在再次遇到相同输入的时候返回缓存结果，从而提升程序运行速度的一种优化技术。</p></blockquote><p>回到斐波那契函数$F(n)$，我们可以用一个哈希表来跟踪每个$F(n)$的值，用$n$做<code>key</code>。哈希表作为缓存使我们避免重复计算。缓存技术是一个很好的用一些额外空间来换取时间减少的例子。</p><p>为了对比，我们提供了如下的用缓存计算实现的斐波那契数。</p><p>作为练习，可以通过更一般性的方法来实现缓存计算，即不改变原来的函数而应用缓存计算。（可以引用设计模式<code>decorator</code>）</p><p>关于<code>decorator</code>设计模式可参考<a href="/2019/03/25/decorator_python/" title="设计模式——decorator">设计模式——decorator</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type N: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur_fib</span><span class="params">(N)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> N <span class="keyword">in</span> cache:</span><br><span class="line">            <span class="keyword">return</span> cache[N]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">            result = N</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = recur_fib(N<span class="number">-1</span>) + recur_fib(N<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># put result in cache for later reference.</span></span><br><span class="line">        cache[N] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recur_fib(N)</span><br></pre></td></tr></table></figure><p>使用<code>decorator</code>模式代码如下（自己实现）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cache</span><span class="params">(func)</span>:</span> </span><br><span class="line">        caches = &#123;&#125; </span><br><span class="line"><span class="meta">        @wraps(func) </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args)</span>:</span> </span><br><span class="line">            <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> caches: </span><br><span class="line">                caches[args] = func(*args)</span><br><span class="line">            <span class="keyword">return</span> caches[args] </span><br><span class="line">        <span class="keyword">return</span> wrap </span><br><span class="line">    </span><br><span class="line"><span class="meta">    @cache </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n)</span>:</span> </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: </span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.fib(n<span class="number">-1</span>) + self.fib(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>在这章中，可以通过斐波那契数和爬楼梯问题来进行练习。</p><p>详见：<a href="/2019/03/25/leetcode_509/" title="【LeetCode】509、斐波那契数">【LeetCode】509、斐波那契数</a>，<a href="/2019/03/14/leetcode_70/" title="【LeetCode】70、爬楼梯">【LeetCode】70、爬楼梯</a></p><p>在下一章，我们将深入讨论在递归算法中的复杂度分析。</p><h2 id="练习：斐波那契数"><a href="#练习：斐波那契数" class="headerlink" title="练习：斐波那契数"></a>练习：斐波那契数</h2><p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), for N &gt; 1.</span><br></pre></td></tr></table></figure><p>Given <code>N</code>, calculate <code>F(N)</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>0 ≤ <code>N</code> ≤ 30.</p><p>代码如下（Python，用时20ms，内存11.8M）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur_fib</span><span class="params">(N)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> N <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[N]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> N &lt; <span class="number">2</span>:</span><br><span class="line">                result = N</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = recur_fib(N<span class="number">-1</span>) + recur_fib(N<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># put result in cache for later reference.</span></span><br><span class="line">            cache[N] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur_fib(N)</span><br></pre></td></tr></table></figure><h2 id="练习：爬楼梯"><a href="#练习：爬楼梯" class="headerlink" title="练习：爬楼梯"></a>练习：爬楼梯</h2><p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><p>代码如下（Python3，用时80ms，内存13.2M）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        tempNum = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            tempNum.append(tempNum[i<span class="number">-1</span>] + tempNum[i<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> tempNum[n]</span><br></pre></td></tr></table></figure><h2 id="解答：爬楼梯"><a href="#解答：爬楼梯" class="headerlink" title="解答：爬楼梯"></a>解答：爬楼梯</h2><blockquote><p>本节代码均为原网页给出的参考代码，均为Java实现。</p></blockquote><h3 id="方法1：暴力法"><a href="#方法1：暴力法" class="headerlink" title="方法1：暴力法"></a>方法1：暴力法</h3><p>暴力法就是计算所有可能的走法组合，也就是每一步爬1层和每一步爬两层。在每一步我们都调用函数$climpStairs$来计算爬一层和爬两层的结果，并返回两个函数返回值的和。</p><script type="math/tex; mode=display">climbStairs(i,n)=climbStairs(i+1,n)+climbStairs(i+2,n)</script><p>其中$i$表示当前层数，$n$表示目标层数。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        climb_Stairs(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climb_Stairs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> climb_Stairs(i + <span class="number">1</span>, n) + climb_Stairs(i + <span class="number">2</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(2^n)$。递归树的大小是$2^n$。</p><p>如下所示为$n=5$时的递归树：</p><p><img src="/2019/03/21/leetcode_explore_recursion/70_Climbing_Stairs_rt.jpg" style="zoom:50%"></p></li><li><p>空间复杂度：$O(n)$。递归树的最大深度为$n$。</p></li></ul><h3 id="方法2：采用缓存计算的递归法"><a href="#方法2：采用缓存计算的递归法" class="headerlink" title="方法2：采用缓存计算的递归法"></a>方法2：采用缓存计算的递归法</h3><p>在上一种方法中重复计算了很多中间结果。可以用一个<code>memo</code>数组将每一步的结果进行存储，当再次调用这个函数的时候可以直接从<code>memo</code>数组中返回结果。</p><p>通过这种使用<code>memo</code>数组来调整递归树的方法，可以将递归树的大小减少到$n$。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> memo[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> climb_Stairs(<span class="number">0</span>, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climb_Stairs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">int</span> memo[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = climb_Stairs(i + <span class="number">1</span>, n, memo) + climb_Stairs(i + <span class="number">2</span>, n, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$。递归树的大小为$n$。</li><li>空间复杂度：$O(n)$。递归树的最大深度为$n$。</li></ul><h3 id="方法3：动态规划"><a href="#方法3：动态规划" class="headerlink" title="方法3：动态规划"></a>方法3：动态规划</h3><p>可以看到，这个问题可以分解成多个子问题，并且包含最优子结构性质，也就是说，这个问题的最优解可以通过其子问题的最优解来组合得到，所以我们可以采用动态规划方法来解决这个问题。</p><p>我们可以通过以下两种方法到达第$i$层：</p><ol><li>在第$i-1$层走一步；</li><li>在第$i-2$层走两步；</li></ol><p>所以，到达第$i$层的总方法数等于到达第$i-1$层的方法数和到达第$i-2$层的方法数的总和。</p><p>用$dp[i]$表示到达第$i$层所需的总方法数，则：</p><script type="math/tex; mode=display">dp[i]=dp[i-1]+dp[i-2]</script><p>例如：</p><p><img src="/2019/03/21/leetcode_explore_recursion/climbStairsAnimation.gif"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$。单层循环到$n$。</li><li>空间复杂度：$O(n)$。使用大小为$n$的$dp$数组。</li></ul><h3 id="方法4：斐波那契数法"><a href="#方法4：斐波那契数法" class="headerlink" title="方法4：斐波那契数法"></a>方法4：斐波那契数法</h3><p>在上面的方法中使用了$dp$数组，并且$dp[i]=dp[i-1]+dp[i-2]$。可以很容易的联想到，$dp[i]$正是斐波那契数的第$i$个值：</p><script type="math/tex; mode=display">Fib(n)=Fib(n-1)+Fib(n-2)</script><p>那么，我们只需要找到斐波那契数列的第$n$个值即可，其中前两个值分别为1和2，即$Fib(1)=1$，$Fib(2)=2$。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$。计算第$n$个斐波那契数需要循环到$n$。</li><li>空间复杂度：$O(1)$。使用固定的空间。</li></ul><h3 id="方法5：Binets-Method-（比奈法？）使用矩阵的方法"><a href="#方法5：Binets-Method-（比奈法？）使用矩阵的方法" class="headerlink" title="方法5：Binets Method （比奈法？）使用矩阵的方法"></a>方法5：Binets Method （比奈法？）使用矩阵的方法</h3><p>这是一个非常有趣的使用矩阵乘法来计算第$n$个斐波那契数的方法。矩阵形式如下：</p><script type="math/tex; mode=display">\begin{bmatrix}   F_{n+1} & F_n \\   F_n & F_{n-1}\end{bmatrix}=\begin{bmatrix}   1 & 1 \\   1 & 0\end{bmatrix}</script><p>令$Q= \begin{bmatrix}F_{n+1} &amp; F_n \\ F_n &amp; F_{n-1} \end{bmatrix}​$。按照这个方法，第$n​$个斐波那契数可以由$Q^{n-1}[0,0]​$得到。</p><p>我们来看方法的证明：</p><p>可以使用数学归纳法来证明这个方法。我们知道，这个矩阵给出了第3个斐波那契数（基本情况）的正确结果，$Q^2= \begin{bmatrix}2 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}​$。这证明了基本情况是适用于这个方法的。</p><p>假设这个方法也适用于第$n$个斐波那契数的问题，即$F_n = Q^{n-1}[0,0]$，其中$Q^{n-1}= \begin{bmatrix} F_n &amp; F_{n-1} \\ F_{n-1} &amp; F_{n-2} \end{bmatrix}$。</p><p>现在，我们需要证明在上述两个条件为真的情况下，这个方法对于计算第$n+1​$个斐波那契数也是有效的，即证明$F_{n+1}=Q^n[0,0]​$。</p><p>证明过程：</p><script type="math/tex; mode=display">Q^n=\begin{bmatrix}   F_{n} & F_{n-1} \\   F_{n-1} & F_{n-2}\end{bmatrix}\begin{bmatrix}    1 & 1 \\    1 & 0\end{bmatrix}=\begin{bmatrix}    F_n+F_{n-1} & F_n \\    F_{n-1}+F_{n-2} & F_{n-1}\end{bmatrix}=\begin{bmatrix}    F_{n+1} & F_n \\    F_n & F_{n-1}\end{bmatrix}</script><p>所以，$F_{n+1}=Q^n[0,0]$。</p><p>至此，完成了这个方法的证明。</p><p>用这个方法解决爬楼梯问题所要做的唯一的改动就是，修改初始值为2和1（斐波那契数列的初始值是1和0）。或者，另一个方法是不修改初始值，而是使用相同的矩阵，但是用结果$result=Q^n[0,0]$来得到爬楼梯问题的第$n$层最终解。做这种调整的原因是因为爬楼梯问题使用的是斐波那契数列列的第2、3项做基本情况。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] q = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] res = pow(q, n);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] pow(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(\log(n))$。</li><li>空间复杂度：$O(1)$。使用固定的空间。</li></ul><p>时间复杂度证明：</p><p>假设有一个$n$次幂的矩阵$M$，假设$n$是2的幂，那么$n=2^i , i \in \mathbb{N} $，其中$\mathbb {N}$表示自然数集合（包括0）。我们可以用如下形式的树来表示：</p><p><img src="/2019/03/21/leetcode_explore_recursion/70_Climbing_Stairs.PNG"></p><p>图中内容表示：$M^n=M^{n/2}=…=\prod_1^n{M^1}​$。</p><p>所以，为了计算矩阵$M^n$，我们需要计算$M^{n/2}$并且和自己相乘。为了计算$M^{n/2}$需要计算$M^{n/4}$，等等等等。</p><p>显然，树的高度为$\log_2{n}$。</p><p>下面来估计$M^n$的计算时间。矩阵$M$在任意次幂的大小都一样，所以我们可以在$O(1)$的时间内计算任意次幂的两个矩阵相乘。这样的计算需要执行$\log_2{n}$次。所以$M^n$的计算复杂度为$O(\log_2{n})$。</p><p>如果$n$不是2的幂，那么我们可以通过其二进制表示将其分解为用2的次幂表示：</p><script type="math/tex; mode=display">n=\sum_{p\in{P}}2^p\ ,\ \text{where}\ P\subset\mathbb{N}</script><p>这样我们可以通过如下公式来得到最终结果：</p><script type="math/tex; mode=display">M^n=\prod_{p\in P}M^{2^p}</script><p>这就是在实现中使用的方法？由于乘法的计算次数已经限制在$O(\log_2n)​$，所以总的复杂度就是$O(\log_2n)​$。</p><h3 id="方法6、斐波那契公式"><a href="#方法6、斐波那契公式" class="headerlink" title="方法6、斐波那契公式"></a>方法6、斐波那契公式</h3><blockquote><p>没太仔细理解这个方法。。。</p></blockquote><p>我们可以用如下公式计算得到第$n$个斐波那契数：</p><script type="math/tex; mode=display">F_n=\cfrac{1}{\sqrt{5}}\left[\left(\cfrac{1+\sqrt5}{2}\right)^n-\left(\cfrac{1-\sqrt5}{2}\right)^n\right]</script><p>对于给定的问题，斐波那契数列定义为：$F_0=1,F_1=1,F_2=2,F_{n+2}=F_{n+1}+F_n$。解决这种递归公式的一种标准方法是假设$F_n$的形式为$F_n=a^n$。这样的话，显然$F_{n+1}=a^{n+1}$并且$F_{n+2}=a^{n+2}$，所以等式就变为$a^{n+2}=a^{n+1}+a^n$。如果我们将整个等式除以$a^n$，就得到$a^2=a+1$，也就是二次方程$a^2-a-1=0$。</p><p>对这个二次方程求解，可以得到：</p><script type="math/tex; mode=display">a=1/\sqrt5\left(\left( \cfrac{1\pm \sqrt5}{2} \right)\right)</script><p>对于一般情况，可以得到等式：</p><script type="math/tex; mode=display">F_n=A\left( \cfrac{1+\sqrt 5}{2} \right)^n+B\left( \cfrac{1-\sqrt 5}{2} \right)^n</script><p>对于$n=0$的情况，有$A+B=1$，</p><p>对于$n=1$的情况，有$A\left( \cfrac{1+\sqrt 5}{2} \right)+B\left( \cfrac{1-\sqrt 5}{2} \right)=1$，</p><p>对上述等式求解，可以得到：</p><script type="math/tex; mode=display">A=\left( \cfrac{1+\sqrt 5}{2\sqrt 5} \right)\ ,\ B=\left( \cfrac{1-\sqrt 5}{2\sqrt 5} \right)</script><p>将$A$和$B$的值代入到上述的通用等式中，可以得到：</p><script type="math/tex; mode=display">F_n=\cfrac{1}{\sqrt{5}}\left[\left(\cfrac{1+\sqrt5}{2}\right)^{n+1}-\left(\cfrac{1-\sqrt5}{2}\right)^{n+1}\right]</script><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5=Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibn=Math.pow((<span class="number">1</span>+sqrt5)/<span class="number">2</span>,n+<span class="number">1</span>)-Math.pow((<span class="number">1</span>-sqrt5)/<span class="number">2</span>,n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(fibn/sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(\log(n))$。$pow$计算需要$\log(n)$的时间。</li><li>空间复杂度：$O(1)​$。使用固定空间。</li></ul><h1 id="四、Complexity-Analysis-复杂度分析"><a href="#四、Complexity-Analysis-复杂度分析" class="headerlink" title="四、Complexity Analysis 复杂度分析"></a>四、Complexity Analysis 复杂度分析</h1><p>在这一章，我们将讨论如何计算递归算法中的时间和空间复杂度。</p><p>特别的是，本章将展示一个非常有用的叫做<code>尾递归</code>的技术，可以用来优化递归问题中的空间复杂度，更重要的是可以避免栈溢出的问题。</p><h2 id="时间复杂度——递归"><a href="#时间复杂度——递归" class="headerlink" title="时间复杂度——递归"></a>时间复杂度——递归</h2><p>这一部分，我们主要讨论如何计算递归问题中的时间复杂度。</p><blockquote><p>给定一个递归问题，其时间复杂度$O(T)$主要是由递归调用的次数（用$R$表示）和每次递归中所需的计算时间（用$O(s)$表示）共同决定的：</p><script type="math/tex; mode=display">O(T)=R*O(s)</script></blockquote><p>来看一些例子。</p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>在反转字符串问题中，我们需要将一个字符串逆序输出。解决这个问题的一个递归关系可以表示如下：</p><script type="math/tex; mode=display">printReverse(str)=printReverse(str[1...n])+print(str[0])</script><p>其中$str[1…n]$是输入字符串$str$的子串，$str[0]$是首字符。</p><p>可以看到，函数递归调用$n$次，$n$是输入字符串的长度。在每一次递归中，只是简单的输出首字符，所以该操作的时间复杂度是常数级，即$O(1)$。</p><p>所以，递归函数$printReverse(str)$的总时间复杂度就是$O(printReverse)=n*O(1)=O(n)$。</p><h3 id="执行树"><a href="#执行树" class="headerlink" title="执行树"></a>执行树</h3><p>对于递归函数，调用次数刚好和输入成线性关系的情况是很少见的。例如，在上一章讨论过的斐波那契数列问题，递归函数定义为$f(n)=f(n-1)+f(n-2)$。乍一看，斐波那契函数的调用次数并不能够很直观的得到。</p><blockquote><p>在这种情况，最好是采用<code>execution tree 执行树</code>的方式，这种树是用来详细表示递归函数执行过程的。树上的每个节点表示递归函数的一次调用，所以总的节点数就是整个执行过程中递归调用的总次数了。</p></blockquote><p>执行树用一个$n$叉树来表示，其中$n$表示递归关系中出现递归调用的次数。例如，斐波那契数列问题的执行树是一颗二叉树，下图表示了计算斐波那契数$f(4)$的执行树：</p><p><img src="/2019/03/21/leetcode_explore_recursion/fibonacci.png"></p><p>对于一个$n$层的二叉树，其节点总数是$2^n-1$。所以，$f(n)$递归调用次数的上限（虽然不是很严格）就是$2^n-1$。所以，可以得到斐波那契数列问题$f(n)$的时间复杂度是$O(2^n)$。</p><h3 id="缓存计算-1"><a href="#缓存计算-1" class="headerlink" title="缓存计算"></a>缓存计算</h3><p>在上一章，讨论过递归算法中用于优化时间复杂度的方法——缓存计算。通过将中间结果进行缓存和重复使用，缓存计算可以大幅减少递归调用的次数，也就是减少执行树的分支数。所以应该考虑到使用缓存计算的递归算法时间复杂度。</p><p>回到斐波那契数列问题，使用缓存计算的话，可以将每个斐波那契数的结果进行保存。保证对每个斐波那契数的计算只执行一次。由递归关系可以知道，对于斐波那契数$f(n)$，依赖于前$n-1$个斐波那契数，所以，$f(n)$的递归计算过程将会调用$n-1$次，来计算其所依赖的所以前序数值。</p><p>现在可以直接使用本章开始时候给出的公式来计算时间复杂度，即$O(1)*n=O(n)$。缓存计算不仅优化了算法的时间复杂度，也简化了时间复杂度的分析过程。</p><p>接下来，我们讨论如何分析递归算法的空间复杂度。</p><h2 id="空间复杂度——递归"><a href="#空间复杂度——递归" class="headerlink" title="空间复杂度——递归"></a>空间复杂度——递归</h2><p>这一部分，将讨论如何分析递归算法中的空间复杂度。</p><blockquote><p>当讨论递归算法的空间复杂度时，应该考虑两部分的空间消耗：递归相关的空间和非递归相关的空间。</p></blockquote><h3 id="递归相关的空间"><a href="#递归相关的空间" class="headerlink" title="递归相关的空间"></a>递归相关的空间</h3><p>递归相关的空间指的是由递归调用所直接产生内存消耗，即保存递归函数调用所需的栈空间。为了完成一个典型的递归调用，系统需要分配一些空间来保存三部分重要的信息：</p><ol><li>函数的返回地址：一旦函数调用完成，程序应该知道返回到哪里，即函数调用之前的位置；</li><li>函数传递的参数；</li><li>函数的局部变量；</li></ol><p>这个栈空间是函数调用过程中所产生的最小开销，一旦函数执行结束，空间就会被释放。</p><p>对于递归算法，函数调用会链式累积，直到到达基本情况。这意味着每个函数调用所需的空间也会累积。</p><blockquote><p>对于递归算法，如果没有其他内存消耗，那么这个由递归行为本身所引起的空间消耗将会是整个算法的空间上限。</p></blockquote><p>例如，在逆序输出字符串的练习中，由于只是单纯的输出字符，所以在递归调用本身之外没有额外的空间消耗。对于每一个递归调用，我们假设需要一个常数级的空间。递归调用将持续$n$次，$n$是输入字符串的长度。所以这个递归算法的空间复杂度是$O(n)$。</p><p>为了说明这一点，以递归调用$f(x_1)\rightarrow f(x_2)\rightarrow f(x_3)$为例，展示了执行步骤的顺序和堆栈布局。</p><p><img src="/2019/03/21/leetcode_explore_recursion/card_recursion_stack.png"></p><p>为了调用$f(x_2)$，会给$f(x_1)$分配一个栈空间。同理，在$f(x_2)$中也会为了调用$f(x_3)$而分配另一个栈空间。最终在$f(x_3)$中，程序到达基本情况，因此没有在$f(x_3)$中进一步递归。</p><p>由于这些递归相关的空间消耗，有时会导致栈溢出的情况，就是分配给一个程序的栈空间超出了其最大空间限制，导致程序失败。因此，当设计递归算法时，要仔细考虑当输入规模比较大的时候是否可能导致栈溢出。</p><h3 id="非递归相关的空间"><a href="#非递归相关的空间" class="headerlink" title="非递归相关的空间"></a>非递归相关的空间</h3><p>如标题所示，非递归相关的空间主要是指和递归没有直接关系的内存空间，通常包括分配给全局变量的空间（通常为堆）。</p><p>不论是否递归，在任何后续函数调用前都需要将问题的输入作为全局变量保存。同时还需要存储递归调用的中间结果。后者就是我们在前面章节讨论过缓存计算。例如，对于使用缓存计算实现的计算斐波那契数列的递归算法，我们使用一个<code>map</code>来记录递归调用过程中出现的所有斐波那契数。因此，在分析空间复杂度的时候，我们应该考虑到缓存计算的空间成本。</p><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>在之前的页面，讨论过递归调用过程中系统分配栈空间所产生的隐藏空间开销。但是，我们应该学会识别一种递归的特殊情况——尾递归，尾递归避免了这部分空间开销。</p><blockquote><p>尾递归是指在递归函数执行的最后命令是递归调用，并且应该只有一个递归调用。</p></blockquote><p>在反转字符串的问题中我们已经看到了一个尾递归的例子。这里用另一个例子展示非尾递归和尾递归的区别。注意，非尾递归的例子在最后一个递归调用之后有一个额外的计算步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_non_tail_recursion</span><span class="params">(ls)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type ls: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int, the sum of the input list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(ls) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># not a tail recursion because it does some computation after the recursive call returned.</span></span><br><span class="line">    <span class="keyword">return</span> ls[<span class="number">0</span>] + sum_non_tail_recursion(ls[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_tail_recursion</span><span class="params">(ls)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type ls: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int, the sum of the input list.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(ls, acc)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(ls) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> acc</span><br><span class="line">        <span class="comment"># this is a tail recursion because the final instruction is a recursive call.</span></span><br><span class="line">        <span class="keyword">return</span> helper(ls[<span class="number">1</span>:], ls[<span class="number">0</span>] + acc)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(ls, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>尾递归的好处是可以避免递归调用过程中的堆栈开销累积，因为系统在每次递归调用的时候可以重复利用一部分栈空间。</p><p>以递归调用$f(x_1)\rightarrow f(x_2)\rightarrow f(x_3)$为例，其中函数$f(x)$是使用尾递归实现的，如下展示了执行步骤的顺序和堆栈布局。</p><p><img src="/2019/03/21/leetcode_explore_recursion/card_recursion_tail.png"></p><p>注意在尾递归中，一旦递归调用结束，我们就会理解知道返回值，所以图中跳过了递归返回的完整链路，直接返回到原始调用的地方。这意味着，我们不再需要对所有递归调用都分配栈，从而节省了空间。</p><p>例如，在步骤1中，为了调用$f(x_2)$而在$f(x_1)$中分配了栈空间。在步骤2中，$f(x_2)$会递归调用$f(x_3)$，但是系统可以直接重复使用之前为第二次递归调用分配的空间，而不是分配新的空间。最终，在函数$f(x_3)$中，我们到达了基本情况，函数可以直接返回到原始调用的地方，而不需要逐步返回到上一个调用的函数。</p><p>尾递归函数可以当做非尾递归函数执行，也就是调用成堆的栈，而不影响结果。通常，编译器会识别尾递归并优化执行过程。但是，并不是所有语言都支持这种优化。例如，C、C++支持尾递归优化，而Java和Python不支持尾递归优化。</p><h2 id="练习：二叉树的最大深度"><a href="#练习：二叉树的最大深度" class="headerlink" title="练习：二叉树的最大深度"></a>练习：二叉树的最大深度</h2><p>详见<a href="/2019/03/25/leetcode_104/" title="【LeetCode】104、二叉树的最大深度">【LeetCode】104、二叉树的最大深度</a></p><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example:</strong></p><p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its depth = 3.</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (leftDepth &gt; rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightDepth+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：二叉树的最大深度"><a href="#解答：二叉树的最大深度" class="headerlink" title="解答：二叉树的最大深度"></a>解答：二叉树的最大深度</h2><p>要花钱才能解锁，没有看:joy:。</p><h2 id="练习：Pow-x-n"><a href="#练习：Pow-x-n" class="headerlink" title="练习：Pow(x, n)"></a>练习：Pow(x, n)</h2><p>详见<a href="/2019/03/25/leetcode_50/" title="【LeetCode】50、Pow(x,n)">【LeetCode】50、Pow(x,n)</a></p><p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a>, which calculates <em>x</em> raised to the power <em>n</em> (xn).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> is a 32-bit signed integer, within the range $[-2^{31},2^{31}-1]​$</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> half = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) <span class="keyword">return</span> half * half * x;</span><br><span class="line">        <span class="keyword">return</span> half * half / x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：Pow-x-n"><a href="#解答：Pow-x-n" class="headerlink" title="解答：Pow(x, n)"></a>解答：Pow(x, n)</h2><p>要花钱才能解锁，没有看:joy:。</p><h1 id="五、Conclusion-总结"><a href="#五、Conclusion-总结" class="headerlink" title="五、Conclusion 总结"></a>五、Conclusion 总结</h1><p>在之前的章节，我们了解了递归的概念的原则。</p><p>作为提醒，以下是解决递归问题的共用工作流程：</p><ol><li>定义递归函数；</li><li>总结递归关系和基本情况；</li><li>如果有重复计算问题的话，使用缓存计算来消除；</li><li>如果可能，使用尾递归来优化空间复杂度；</li></ol><p>在本章，将对递归算法做一些总结，并且提供一些在利用递归解决问题的过程中可能用到的tips。</p><h2 id="总结——递归-1"><a href="#总结——递归-1" class="headerlink" title="总结——递归-1"></a>总结——递归-1</h2><p>现在，我们了解到递归确实是一个可以用来解决很多问题的有效方法。但是，由于时间和空间的限制，并不是所有问题都能用递归解决。递归可能会有一些负面效果，如栈溢出问题。</p><p>在这章，将分享一些可以更好的利用递归来解决实际问题的tips：</p><blockquote><p><strong>疑惑的时候，把递归关系写下来。</strong></p></blockquote><p>有时，乍一看，问题能够用递归算法解决并不明显。但是，由于递归算法和我们所熟悉的数学非常接近，所以利用数学公式推导出一些关系式总是有帮助的。通常，可以帮助澄清问题概念并揭示隐藏的递归关系。在本章后面，可以通过一个例子（Unique Binary Search Trees II）来了解在数学公式的辅助下利用递归方法解决问题。</p><blockquote><p><strong>如果可能，使用缓存计算。</strong></p></blockquote><p>在起草递归算法的时候，可以从最简单的策略开始。有时，在递归过程中会存在重复计算，如斐波那契数问题。在这种情况下，应该尝试使用缓存计算技术，将中间结果缓存以后后续重复使用。缓存计算利用空间上的一些折中来换取时间复杂度的大幅提升。</p><blockquote><p><strong>当出现栈溢出问题时，尾递归可能会有帮助。</strong></p></blockquote><p>使用递归算法通常有几种不同的实现。尾递归是其中一个特定的实现形式。和缓存计算不同，尾递归可以通过消除递归算法带来的堆栈开销来优化算法的空间复杂度。更重要的是，使用尾递归可以避免递归算法常出现的栈溢出问题。尾递归的另一个优点是比非尾递归更容易阅读和理解。因为和非尾递归不同，尾递归中不存在递归后调用的问题（即递归操作是函数的最后操作）。所以，只要可能，应该尽量使用尾递归。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>现在，利用目前为止所了解到的递归知识，可以在LeetCode上解决更多问题。在本章中，还提供了几个练习。</p><h2 id="练习：合并两个有序链表"><a href="#练习：合并两个有序链表" class="headerlink" title="练习：合并两个有序链表"></a>练习：合并两个有序链表</h2><p>详见<a href="/2019/03/26/leetcode_21/" title="【LeetCode】21、合并两个有序链表">【LeetCode】21、合并两个有序链表</a></p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val&lt;l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：合并两个有序链表"><a href="#解答：合并两个有序链表" class="headerlink" title="解答：合并两个有序链表"></a>解答：合并两个有序链表</h2><p>要花钱才能解锁，没有看:joy:。</p><h2 id="练习：第k个语法符号"><a href="#练习：第k个语法符号" class="headerlink" title="练习：第k个语法符号"></a>练习：第k个语法符号</h2><p>详见<a href="/2019/03/26/leetcode_779/" title="【LeetCode】779、第k个语法符号">【LeetCode】779、第k个语法符号</a></p><p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code>with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p><p>Given row <code>N</code> and index <code>K</code>, return the <code>K</code>-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line">Input: N = 1, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: N = 4, K = 5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row 1: 0</span><br><span class="line">row 2: 01</span><br><span class="line">row 3: 0110</span><br><span class="line">row 4: 01101001</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>N</code> will be an integer in the range <code>[1, 30]</code>.</li><li><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (K%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> kthGrammar(N<span class="number">-1</span>, K/<span class="number">2</span>)==<span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> kthGrammar(N<span class="number">-1</span>, (K+<span class="number">1</span>)/<span class="number">2</span>)==<span class="number">0</span> ? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解答：第k个语法符号"><a href="#解答：第k个语法符号" class="headerlink" title="解答：第k个语法符号"></a>解答：第k个语法符号</h2><p>要花钱才能解锁，没有看:joy:。</p><h2 id="练习：不同的二叉搜索树II"><a href="#练习：不同的二叉搜索树II" class="headerlink" title="练习：不同的二叉搜索树II"></a>练习：不同的二叉搜索树II</h2><p>Given an integer <em>n</em>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&apos;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><blockquote><p>等复习了二叉树再后续补充，，，</p></blockquote><h2 id="解答：不同的二叉搜索树II"><a href="#解答：不同的二叉搜索树II" class="headerlink" title="解答：不同的二叉搜索树II"></a>解答：不同的二叉搜索树II</h2><p>要花钱才能解锁，没有看:joy:。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要翻译自LeetCode上Explore模块的&lt;a href=&quot;https://leetcode.com/explore/learn/card/recursion-i/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Recursion I&lt;/a&gt;，有直译，也有非直译的个人理解。&lt;/p&gt;
&lt;p&gt;其中涉及的题目附有相应的解答。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Overview-综述&quot;&gt;&lt;a href=&quot;#Overview-综述&quot; class=&quot;headerlink&quot; title=&quot;Overview 综述&quot;&gt;&lt;/a&gt;Overview 综述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Recursion&lt;/code&gt;（递归）是计算机科学中一个重要的概念，是很多算法和数据结构的基础。但是对于很多初学者都比较难把握。&lt;/p&gt;
    
    </summary>
    
      <category term="基础" scheme="https://lesley0416.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="LeetCode" scheme="https://lesley0416.github.io/tags/LeetCode/"/>
    
      <category term="递归" scheme="https://lesley0416.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="recursion" scheme="https://lesley0416.github.io/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>Python中list的一些小技巧</title>
    <link href="https://lesley0416.github.io/2019/03/20/python_list_tips/"/>
    <id>https://lesley0416.github.io/2019/03/20/python_list_tips/</id>
    <published>2019-03-20T03:38:50.000Z</published>
    <updated>2019-03-20T03:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="列表展开"><a href="#列表展开" class="headerlink" title="列表展开"></a>列表展开</h3><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment">################ case 1</span></span><br><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="keyword">print</span> list(itertools.chain.from_iterable(a))</span><br><span class="line">%timeit -n <span class="number">10000</span> list(itertools.chain.from_iterable(a))</span><br><span class="line"><span class="keyword">print</span> sum(a, [])</span><br><span class="line">%timeit -n <span class="number">10000</span> sum(a, [])</span><br><span class="line"><span class="keyword">print</span> [x <span class="keyword">for</span> l <span class="keyword">in</span> a <span class="keyword">for</span> x <span class="keyword">in</span> l]</span><br><span class="line">%timeit -n <span class="number">10000</span> [x <span class="keyword">for</span> l <span class="keyword">in</span> a <span class="keyword">for</span> x <span class="keyword">in</span> l]</span><br><span class="line"></span><br><span class="line"><span class="comment"># result:</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># 10000 loops, best of 3: 801 ns per loop</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># 10000 loops, best of 3: 359 ns per loop</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># 10000 loops, best of 3: 371 ns per loop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################ case 2</span></span><br><span class="line">b = [[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line">[x <span class="keyword">for</span> l1 <span class="keyword">in</span> b <span class="keyword">for</span> l2 <span class="keyword">in</span> l1 <span class="keyword">for</span> x <span class="keyword">in</span> l2]</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################ case 3</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line">flatten = <span class="keyword">lambda</span> x: [y <span class="keyword">for</span> l <span class="keyword">in</span> x <span class="keyword">for</span> y <span class="keyword">in</span> flatten(l)] <span class="keyword">if</span> type(x) <span class="keyword">is</span> list <span class="keyword">else</span> [x]</span><br><span class="line">flatten(a)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h3 id="相邻元素压缩-amp-依次相连"><a href="#相邻元素压缩-amp-依次相连" class="headerlink" title="相邻元素压缩&amp;依次相连"></a>相邻元素压缩&amp;依次相连</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">list(zip(*([iter(a)] * <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># [(1, 2), (3, 4), (5, 6)]</span></span><br><span class="line">list(zip(*([iter(a)] * <span class="number">3</span>)))</span><br><span class="line"><span class="comment"># [(1, 2, 3), (4, 5, 6)]</span></span><br><span class="line"></span><br><span class="line">temp = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>,<span class="string">'f'</span>]</span><br><span class="line">list(zip(temp[:<span class="number">-1</span>],temp[<span class="number">1</span>:]))</span><br><span class="line"><span class="comment"># [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')]</span></span><br><span class="line">list(zip(temp[:<span class="number">-2</span>],temp[<span class="number">1</span>:<span class="number">-1</span>],temp[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment"># [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;列表展开&quot;&gt;&lt;a href=&quot;#列表展开&quot; class=&quot;headerlink&quot; title=&quot;列表展开&quot;&gt;&lt;/a&gt;列表展开&lt;/h3&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lesley0416.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lesley0416.github.io/tags/Python/"/>
    
      <category term="list" scheme="https://lesley0416.github.io/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>Python中zip的一些内容</title>
    <link href="https://lesley0416.github.io/2019/03/19/python_zip/"/>
    <id>https://lesley0416.github.io/2019/03/19/python_zip/</id>
    <published>2019-03-19T06:45:50.000Z</published>
    <updated>2019-03-20T14:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、zip基本说明"><a href="#1、zip基本说明" class="headerlink" title="1、zip基本说明"></a>1、zip基本说明</h2><p><code>zip</code>函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，返回由这些元组组成的列表。在Python3.x中为了减少内存，返回的是一个对象，可以用<code>list()</code>转换来输出列表。</p><p>如果各个迭代器的元素个数不一样，则返回列表长度与最短的对象相同，利用<code>*</code>号操作符，可以将元组解压为列表。</p><a id="more"></a><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([iterable, ...])</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>iterable：一个或多个迭代器；</li></ul></li><li>返回值：<ul><li>返回一个对象；</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">zipped = zip(a,b) <span class="comment"># 返回一个对象</span></span><br><span class="line">zipped</span><br><span class="line"><span class="comment"># &lt;zip object at 0x103abc288&gt;</span></span><br><span class="line">list(zipped) <span class="comment"># list() 转换为列表</span></span><br><span class="line"><span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">list(zip(a,c)) <span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line"><span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"></span><br><span class="line">a1, a2 = zip(*zip(a,b)) <span class="comment"># 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式，*是Python函数可变参数的一种表示形式，加*的表示传入一个元组对象进行解包</span></span><br><span class="line">list(a1)</span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br><span class="line">list(a2)</span><br><span class="line"><span class="comment"># [4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="2、一些使用"><a href="#2、一些使用" class="headerlink" title="2、一些使用"></a>2、一些使用</h2><h3 id="相邻元素压缩器"><a href="#相邻元素压缩器" class="headerlink" title="相邻元素压缩器"></a>相邻元素压缩器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">list(zip(*([iter(a)] * <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># [(1, 2), (3, 4), (5, 6)]</span></span><br><span class="line">list(zip(*([iter(a)] * <span class="number">3</span>)))</span><br><span class="line"><span class="comment"># [(1, 2, 3), (4, 5, 6)]</span></span><br></pre></td></tr></table></figure><ul><li><p>首先理解迭代器，<code>iter()</code>可以将一个序列生成为一个迭代器，迭代器的特点是可以用<code>for in</code>语句迭代。原理是迭代器对象有一个<code>next</code>方法，可以每次移动迭代的指针，一旦迭代完，没有下一个元素的时候，会触发一个<code>StopIteration</code>异常。<strong>迭代器的特点是，迭代了一次以后，指针就移动了，不会自动回溯。</strong>例如，可以用<code>for in</code>迭代列表无数次，但只能迭代一次迭代器，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line"><span class="meta">... </span>    print(i) <span class="comment"># 因为x已经被迭代过了，迭代的指针不会回溯，所以没有值了</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>而在上述相邻元素压缩器的使用过程中，可以发现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[iter(a)] * <span class="number">3</span></span><br><span class="line"><span class="comment"># [&lt;listiterator at 0x7fa6c00ec1d0&gt;,</span></span><br><span class="line"><span class="comment"># &lt;listiterator at 0x7fa6c00ec1d0&gt;,</span></span><br><span class="line"><span class="comment"># &lt;listiterator at 0x7fa6c00ec1d0&gt;]</span></span><br></pre></td></tr></table></figure><p>三个迭代器实际上是同一个迭代器。</p></li><li><p>再来理解<code>zip</code>，如前文所述，<code>zip</code>将两个序列对应打包，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(a1, a2))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>而<code>*</code>则表示传入一个对象进行解包，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (a1, a2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(t)) <span class="comment"># 不加*号，zip 只有一个参数 t</span></span><br><span class="line">[([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>],), ([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>],)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*t)) <span class="comment"># 加*号的作用就是将元祖t，解包成a1,a2为zip的两个函数参数</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure></li><li><p>最后理解为什么使用迭代器，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = iter(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = [a, a]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*t))                 <span class="comment"># case 1，不使用迭代器</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">5</span>), (<span class="number">6</span>, <span class="number">6</span>)]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tx = [x, x]                                   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*tx))                <span class="comment"># case 2，使用迭代器</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>在case 1中，<code>zip</code>传入的两个参数<code>a</code>，等于打包了两个列表，并在<code>zip(*)</code>中进行解包，等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>在case 2中，<code>x</code>是迭代器对象，迭代过程会调用<code>next</code>方法，迭代过一次后会自动移动且不会回溯。也就是说<code>zip</code>执行过程中先调用第一个参数<code>x</code>的<code>next</code>方法得到参数1，再调用第二个参数<code>x</code>的<code>next</code>方法，上文我们已知这两个迭代器其实是同一个迭代器对象，所以第二次调用<code>x</code>的<code>next</code>方法时，迭代器指针已经移动，所以得到参数2，整个过程类似如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x.next -&gt; 1</span><br><span class="line">x.next -&gt; 2</span><br><span class="line">zip(x.next(), x.next()) ---&gt; zip(1, 2)</span><br><span class="line">x.next -&gt; 3</span><br><span class="line">x.next -&gt; 4</span><br><span class="line">zip(x.next(), x.next()) ---&gt; zip(3, 4)</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure></li></ul><p>基于此，就可以理解使用<code>zip</code>做相邻元素压缩器的完整执行过程了。</p><h3 id="列表元素依次相连"><a href="#列表元素依次相连" class="headerlink" title="列表元素依次相连"></a>列表元素依次相连</h3><blockquote><p>注意与<code>相邻元素压缩器</code>的效果区别。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>,<span class="string">'f'</span>]</span><br><span class="line">print(temp)</span><br><span class="line"><span class="comment"># ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class="line">list(zip(temp[:<span class="number">-1</span>],temp[<span class="number">1</span>:]))</span><br><span class="line"><span class="comment"># [('a', 'b'), ('b', 'c'), ('c', 'd'), ('d', 'e'), ('e', 'f')]</span></span><br></pre></td></tr></table></figure><p>这个用法比较好理解，<code>temp[:-1]</code>去除列表最后一个元素，<code>temp[1:]</code>去除列表第一个元素，则上述过程等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>], [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br></pre></td></tr></table></figure><p>基于该用法可衍生出多个元素依次相连的用法，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(zip(temp[:<span class="number">-2</span>],temp[<span class="number">1</span>:<span class="number">-1</span>],temp[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment"># [('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e'), ('d', 'e', 'f')]</span></span><br></pre></td></tr></table></figure><p>也可以用这种方法实现列表相邻元素压缩器的效果，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">list(zip(a[::<span class="number">3</span>], a[<span class="number">1</span>::<span class="number">3</span>], a[<span class="number">2</span>::<span class="number">3</span>]))</span><br><span class="line"><span class="comment"># [(1, 2, 3), (4, 5, 6)]</span></span><br></pre></td></tr></table></figure><h3 id="取列表相同位置元素"><a href="#取列表相同位置元素" class="headerlink" title="取列表相同位置元素"></a>取列表相同位置元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="string">'flower'</span>,<span class="string">'flow'</span>,<span class="string">'flight'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip(*nums):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('f', 'f', 'f')</span></span><br><span class="line"><span class="comment"># ('l', 'l', 'l')</span></span><br><span class="line"><span class="comment"># ('o', 'o', 'i')</span></span><br><span class="line"><span class="comment"># ('w', 'w', 'g')</span></span><br></pre></td></tr></table></figure><h3 id="反转字典"><a href="#反转字典" class="headerlink" title="反转字典"></a>反转字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>&#125;</span><br><span class="line">dict(zip(m.values(), m.keys()))</span><br><span class="line"><span class="comment"># &#123;1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、zip基本说明&quot;&gt;&lt;a href=&quot;#1、zip基本说明&quot; class=&quot;headerlink&quot; title=&quot;1、zip基本说明&quot;&gt;&lt;/a&gt;1、zip基本说明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;zip&lt;/code&gt;函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，返回由这些元组组成的列表。在Python3.x中为了减少内存，返回的是一个对象，可以用&lt;code&gt;list()&lt;/code&gt;转换来输出列表。&lt;/p&gt;
&lt;p&gt;如果各个迭代器的元素个数不一样，则返回列表长度与最短的对象相同，利用&lt;code&gt;*&lt;/code&gt;号操作符，可以将元组解压为列表。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lesley0416.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lesley0416.github.io/tags/Python/"/>
    
      <category term="zip" scheme="https://lesley0416.github.io/tags/zip/"/>
    
      <category term="Python3" scheme="https://lesley0416.github.io/tags/Python3/"/>
    
  </entry>
  
</feed>
